# 1 "grep.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "grep.c"
# 35 "grep.c"
# 1 "/usr/include/errno.h" 1 3 4
# 29 "/usr/include/errno.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 313 "/usr/include/features.h" 3 4
# 1 "/usr/include/bits/predefs.h" 1 3 4
# 314 "/usr/include/features.h" 2 3 4
# 346 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 353 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 354 "/usr/include/sys/cdefs.h" 2 3 4
# 347 "/usr/include/features.h" 2 3 4
# 378 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4



# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 5 "/usr/include/gnu/stubs.h" 2 3 4


# 1 "/usr/include/gnu/stubs-32.h" 1 3 4
# 8 "/usr/include/gnu/stubs.h" 2 3 4
# 379 "/usr/include/features.h" 2 3 4
# 30 "/usr/include/errno.h" 2 3 4






# 1 "/usr/include/bits/errno.h" 1 3 4
# 25 "/usr/include/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4



# 1 "/usr/include/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4



# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 5 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/asm/errno.h" 2 3 4
# 5 "/usr/include/linux/errno.h" 2 3 4
# 26 "/usr/include/bits/errno.h" 2 3 4
# 43 "/usr/include/bits/errno.h" 3 4
extern int *__errno_location (void) ;
# 37 "/usr/include/errno.h" 2 3 4
# 59 "/usr/include/errno.h" 3 4

# 36 "grep.c" 2
# 1 "/usr/include/stdio.h" 1 3 4
# 30 "/usr/include/stdio.h" 3 4




# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 211 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 35 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/bits/types.h" 1 3 4
# 28 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
# 59 "/usr/include/bits/types.h" 3 4
typedef struct
{
  long __val[2];
} __quad_t;
typedef struct
{
  __u_long __val[2];
} __u_quad_t;
# 131 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 132 "/usr/include/bits/types.h" 2 3 4


 typedef __u_quad_t __dev_t;
 typedef unsigned int __uid_t;
 typedef unsigned int __gid_t;
 typedef unsigned long int __ino_t;
 typedef __u_quad_t __ino64_t;
 typedef unsigned int __mode_t;
 typedef unsigned int __nlink_t;
 typedef long int __off_t;
 typedef __quad_t __off64_t;
 typedef int __pid_t;
 typedef struct { int __val[2]; } __fsid_t;
 typedef long int __clock_t;
 typedef unsigned long int __rlim_t;
 typedef __u_quad_t __rlim64_t;
 typedef unsigned int __id_t;
 typedef long int __time_t;
 typedef unsigned int __useconds_t;
 typedef long int __suseconds_t;

 typedef int __daddr_t;
 typedef long int __swblk_t;
 typedef int __key_t;


 typedef int __clockid_t;


 typedef void * __timer_t;


 typedef long int __blksize_t;




 typedef long int __blkcnt_t;
 typedef __quad_t __blkcnt64_t;


 typedef unsigned long int __fsblkcnt_t;
 typedef __u_quad_t __fsblkcnt64_t;


 typedef unsigned long int __fsfilcnt_t;
 typedef __u_quad_t __fsfilcnt64_t;

 typedef int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


 typedef int __intptr_t;


 typedef unsigned int __socklen_t;
# 37 "/usr/include/stdio.h" 2 3 4
# 45 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 65 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 75 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 52 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 352 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 53 "/usr/include/wchar.h" 2 3 4
# 83 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 21 "/usr/include/_G_config.h" 2 3 4

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 53 "/usr/include/_G_config.h" 3 4
typedef int _G_int16_t ;
typedef int _G_int32_t ;
typedef unsigned int _G_uint16_t ;
typedef unsigned int _G_uint32_t ;
# 33 "/usr/include/libio.h" 2 3 4
# 53 "/usr/include/libio.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 54 "/usr/include/libio.h" 2 3 4
# 170 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 180 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 203 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 271 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 319 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 328 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 364 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);
# 416 "/usr/include/libio.h" 3 4
extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 460 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) ;
extern int _IO_ferror (_IO_FILE *__fp) ;

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) ;
extern void _IO_funlockfile (_IO_FILE *) ;
extern int _IO_ftrylockfile (_IO_FILE *) ;
# 490 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * , const char * ,
   __gnuc_va_list, int *);
extern int _IO_vfprintf (_IO_FILE *, const char *,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) ;
# 76 "/usr/include/stdio.h" 2 3 4
# 89 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;




# 141 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 142 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) ;

extern int rename (const char *__old, const char *__new) ;




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) ;








extern FILE *tmpfile (void) ;
# 186 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) ;





extern char *tmpnam_r (char *__s) ;
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 229 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 243 "/usr/include/stdio.h" 3 4






extern FILE *fopen (const char * __filename,
      const char * __modes) ;




extern FILE *freopen (const char * __filename,
        const char * __modes,
        FILE * __stream) ;
# 272 "/usr/include/stdio.h" 3 4

# 283 "/usr/include/stdio.h" 3 4
extern FILE *fdopen (int __fd, const char *__modes) ;
# 296 "/usr/include/stdio.h" 3 4
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) ;






extern void setbuf (FILE * __stream, char * __buf) ;



extern int setvbuf (FILE * __stream, char * __buf,
      int __modes, size_t __n) ;





extern void setbuffer (FILE * __stream, char * __buf,
         size_t __size) ;


extern void setlinebuf (FILE *__stream) ;








extern int fprintf (FILE * __stream,
      const char * __format, ...);




extern int printf (const char * __format, ...);

extern int sprintf (char * __s,
      const char * __format, ...) ;





extern int vfprintf (FILE * __s, const char * __format,
       __gnuc_va_list __arg);




extern int vprintf (const char * __format, __gnuc_va_list __arg);

extern int vsprintf (char * __s, const char * __format,
       __gnuc_va_list __arg) ;





extern int snprintf (char * __s, size_t __maxlen,
       const char * __format, ...)
     ;

extern int vsnprintf (char * __s, size_t __maxlen,
        const char * __format, __gnuc_va_list __arg)
     ;

# 394 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, const char * __fmt,
       __gnuc_va_list __arg)
     ;
extern int dprintf (int __fd, const char * __fmt, ...)
     ;








extern int fscanf (FILE * __stream,
     const char * __format, ...) ;




extern int scanf (const char * __format, ...) ;

extern int sscanf (const char * __s,
     const char * __format, ...) ;
# 434 "/usr/include/stdio.h" 3 4
extern int __isoc99_fscanf (FILE * __stream,
       const char * __format, ...) ;
extern int __isoc99_scanf (const char * __format, ...) ;
extern int __isoc99_sscanf (const char * __s,
       const char * __format, ...) ;














extern int vfscanf (FILE * __s, const char * __format,
      __gnuc_va_list __arg)
     ;





extern int vscanf (const char * __format, __gnuc_va_list __arg)
     ;


extern int vsscanf (const char * __s,
      const char * __format, __gnuc_va_list __arg)
     ;
# 490 "/usr/include/stdio.h" 3 4
extern int __isoc99_vfscanf (FILE * __s,
        const char * __format,
        __gnuc_va_list __arg) ;
extern int __isoc99_vscanf (const char * __format,
       __gnuc_va_list __arg) ;
extern int __isoc99_vsscanf (const char * __s,
        const char * __format,
        __gnuc_va_list __arg) ;















extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 532 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 543 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 576 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char * __s, int __n, FILE * __stream)
     ;






extern char *gets (char *__s) ;

# 638 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char ** __lineptr,
          size_t * __n, int __delimiter,
          FILE * __stream) ;
extern __ssize_t getdelim (char ** __lineptr,
        size_t * __n, int __delimiter,
        FILE * __stream) ;







extern __ssize_t getline (char ** __lineptr,
       size_t * __n,
       FILE * __stream) ;








extern int fputs (const char * __s, FILE * __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void * __ptr, size_t __size,
       size_t __n, FILE * __stream) ;




extern size_t fwrite (const void * __ptr, size_t __size,
        size_t __n, FILE * __s) ;

# 710 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void * __ptr, size_t __size,
         size_t __n, FILE * __stream) ;
extern size_t fwrite_unlocked (const void * __ptr, size_t __size,
          size_t __n, FILE * __stream) ;








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 746 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 765 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE * __stream, fpos_t * __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 788 "/usr/include/stdio.h" 3 4

# 797 "/usr/include/stdio.h" 3 4


extern void clearerr (FILE *__stream) ;

extern int feof (FILE *__stream) ;

extern int ferror (FILE *__stream) ;




extern void clearerr_unlocked (FILE *__stream) ;
extern int feof_unlocked (FILE *__stream) ;
extern int ferror_unlocked (FILE *__stream) ;








extern void perror (const char *__s);






# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 27 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];
# 827 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) ;




extern int fileno_unlocked (FILE *__stream) ;
# 846 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) ;
# 886 "/usr/include/stdio.h" 3 4
extern void flockfile (FILE *__stream) ;



extern int ftrylockfile (FILE *__stream) ;


extern void funlockfile (FILE *__stream) ;
# 916 "/usr/include/stdio.h" 3 4

# 37 "grep.c" 2
# 48 "grep.c"
# 1 "/usr/include/stdlib.h" 1 3 4
# 33 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 323 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stddef.h" 3 4
typedef int wchar_t;
# 34 "/usr/include/stdlib.h" 2 3 4


# 96 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







 typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 140 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) ;




extern double atof (const char *__nptr)
     ;

extern int atoi (const char *__nptr)
     ;

extern long int atol (const char *__nptr)
     ;





 extern long long int atoll (const char *__nptr)
     ;





extern double strtod (const char * __nptr,
        char ** __endptr)
     ;





extern float strtof (const char * __nptr,
       char ** __endptr) ;

extern long double strtold (const char * __nptr,
       char ** __endptr)
     ;





extern long int strtol (const char * __nptr,
   char ** __endptr, int __base)
     ;

extern unsigned long int strtoul (const char * __nptr,
      char ** __endptr, int __base)
     ;

# 207 "/usr/include/stdlib.h" 3 4



extern long long int strtoll (const char * __nptr,
         char ** __endptr, int __base)
     ;


extern unsigned long long int strtoull (const char * __nptr,
     char ** __endptr, int __base)
     ;

# 311 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) ;


extern long int a64l (const char *__s)
     ;




# 1 "/usr/include/sys/types.h" 1 3 4
# 29 "/usr/include/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;
# 62 "/usr/include/sys/types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;
# 100 "/usr/include/sys/types.h" 3 4
typedef __pid_t pid_t;




typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 133 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 74 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 92 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 104 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 134 "/usr/include/sys/types.h" 2 3 4
# 147 "/usr/include/sys/types.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 148 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 163 "/usr/include/sys/types.h" 3 4
typedef char int8_t;
typedef short int int16_t;
typedef int int32_t;
# 174 "/usr/include/sys/types.h" 3 4
typedef unsigned char u_int8_t;
typedef unsigned short int u_int16_t;
typedef unsigned int u_int32_t;






typedef int register_t;
# 217 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 38 "/usr/include/endian.h" 2 3 4
# 61 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 28 "/usr/include/bits/byteswap.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/byteswap.h" 2 3 4
# 62 "/usr/include/endian.h" 2 3 4
# 218 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/select.h" 1 3 4
# 31 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 23 "/usr/include/bits/select.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/select.h" 2 3 4
# 32 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 24 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 35 "/usr/include/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;





# 1 "/usr/include/time.h" 1 3 4
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };
# 45 "/usr/include/sys/select.h" 2 3 4

# 1 "/usr/include/bits/time.h" 1 3 4
# 69 "/usr/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 47 "/usr/include/sys/select.h" 2 3 4


typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
# 67 "/usr/include/sys/select.h" 3 4
typedef struct
  {






    __fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];


  } fd_set;






typedef __fd_mask fd_mask;
# 99 "/usr/include/sys/select.h" 3 4

# 109 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set * __readfds,
     fd_set * __writefds,
     fd_set * __exceptfds,
     struct timeval * __timeout);
# 121 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set * __readfds,
      fd_set * __writefds,
      fd_set * __exceptfds,
      const struct timespec * __timeout,
      const __sigset_t * __sigmask);



# 221 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 224 "/usr/include/sys/types.h" 2 3 4
# 235 "/usr/include/sys/types.h" 3 4
typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 270 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/pthreadtypes.h" 2 3 4
# 50 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


typedef union
{
  char __size[36];
  long int __align;
} pthread_attr_t;
# 67 "/usr/include/bits/pthreadtypes.h" 3 4
typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;





typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;





    int __kind;





    unsigned int __nusers;
    union
    {
      int __spins;
      __pthread_slist_t __list;
    };

  } __data;
  char __size[24];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    unsigned long long int __total_seq;
    unsigned long long int __wakeup_seq;
    unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{
# 170 "/usr/include/bits/pthreadtypes.h" 3 4
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;


    unsigned char __flags;
    unsigned char __shared;
    unsigned char __pad1;
    unsigned char __pad2;
    int __writer;
  } __data;

  char __size[32];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[20];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 271 "/usr/include/sys/types.h" 2 3 4



# 321 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) ;


extern void srandom (unsigned int __seed) ;





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) ;



extern char *setstate (char *__statebuf) ;







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data * __buf,
       int32_t * __result) ;

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     ;

extern int initstate_r (unsigned int __seed, char * __statebuf,
   size_t __statelen,
   struct random_data * __buf)
     ;

extern int setstate_r (char * __statebuf,
         struct random_data * __buf)
     ;






extern int rand (void) ;

extern void srand (unsigned int __seed) ;




extern int rand_r (unsigned int *__seed) ;







extern double drand48 (void) ;
extern double erand48 (unsigned short int __xsubi[3]) ;


extern long int lrand48 (void) ;
extern long int nrand48 (unsigned short int __xsubi[3])
     ;


extern long int mrand48 (void) ;
extern long int jrand48 (unsigned short int __xsubi[3])
     ;


extern void srand48 (long int __seedval) ;
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     ;
extern void lcong48 (unsigned short int __param[7]) ;





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data * __buffer,
        double * __result) ;
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data * __buffer,
        double * __result) ;


extern int lrand48_r (struct drand48_data * __buffer,
        long int * __result)
     ;
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data * __buffer,
        long int * __result)
     ;


extern int mrand48_r (struct drand48_data * __buffer,
        long int * __result)
     ;
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data * __buffer,
        long int * __result)
     ;


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     ;

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) ;

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     ;









extern void *malloc (size_t __size) ;

extern void *calloc (size_t __nmemb, size_t __size)
     ;










extern void *realloc (void *__ptr, size_t __size)
     ;

extern void free (void *__ptr) ;




extern void cfree (void *__ptr) ;



# 1 "/usr/include/alloca.h" 1 3 4
# 25 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 26 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) ;






# 498 "/usr/include/stdlib.h" 2 3 4




extern void *valloc (size_t __size) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     ;




extern void abort (void) ;



extern int atexit (void (*__func) (void)) ;
# 530 "/usr/include/stdlib.h" 3 4





extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     ;






extern void exit (int __status) ;
# 553 "/usr/include/stdlib.h" 3 4






extern void _Exit (int __status) ;






extern char *getenv (const char *__name) ;




extern char *__secure_getenv (const char *__name)
     ;





extern int putenv (char *__string) ;





extern int setenv (const char *__name, const char *__value, int __replace)
     ;


extern int unsetenv (const char *__name) ;






extern int clearenv (void) ;
# 604 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) ;
# 615 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) ;
# 637 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) ;
# 658 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) ;
# 707 "/usr/include/stdlib.h" 3 4





extern int system (const char *__command) ;

# 729 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char * __name,
         char * __resolved) ;






typedef int (*__compar_fn_t) (const void *, const void *);
# 747 "/usr/include/stdlib.h" 3 4



extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     ;



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) ;
# 766 "/usr/include/stdlib.h" 3 4
extern int abs (int __x) ;
extern long int labs (long int __x) ;



 extern long long int llabs (long long int __x)
     ;







extern div_t div (int __numer, int __denom)
     ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     ;




 extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     ;

# 802 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int * __decpt,
     int * __sign) ;




extern char *fcvt (double __value, int __ndigit, int * __decpt,
     int * __sign) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     ;




extern char *qecvt (long double __value, int __ndigit,
      int * __decpt, int * __sign)
     ;
extern char *qfcvt (long double __value, int __ndigit,
      int * __decpt, int * __sign)
     ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     ;




extern int ecvt_r (double __value, int __ndigit, int * __decpt,
     int * __sign, char * __buf,
     size_t __len) ;
extern int fcvt_r (double __value, int __ndigit, int * __decpt,
     int * __sign, char * __buf,
     size_t __len) ;

extern int qecvt_r (long double __value, int __ndigit,
      int * __decpt, int * __sign,
      char * __buf, size_t __len)
     ;
extern int qfcvt_r (long double __value, int __ndigit,
      int * __decpt, int * __sign,
      char * __buf, size_t __len)
     ;







extern int mblen (const char *__s, size_t __n) ;


extern int mbtowc (wchar_t * __pwc,
     const char * __s, size_t __n) ;


extern int wctomb (char *__s, wchar_t __wchar) ;



extern size_t mbstowcs (wchar_t * __pwcs,
   const char * __s, size_t __n) ;

extern size_t wcstombs (char * __s,
   const wchar_t * __pwcs, size_t __n)
     ;








extern int rpmatch (const char *__response) ;
# 907 "/usr/include/stdlib.h" 3 4
extern int posix_openpt (int __oflag) ;
# 942 "/usr/include/stdlib.h" 3 4
extern int getloadavg (double __loadavg[], int __nelem)
     ;
# 958 "/usr/include/stdlib.h" 3 4

# 49 "grep.c" 2
# 58 "grep.c"
# 1 "/usr/include/string.h" 1 3 4
# 28 "/usr/include/string.h" 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4









extern void *memcpy (void * __dest,
       const void * __src, size_t __n)
     ;


extern void *memmove (void *__dest, const void *__src, size_t __n)
     ;






extern void *memccpy (void * __dest, const void * __src,
        int __c, size_t __n)
     ;





extern void *memset (void *__s, int __c, size_t __n) ;


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     ;
# 94 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      ;


# 125 "/usr/include/string.h" 3 4


extern char *strcpy (char * __dest, const char * __src)
     ;

extern char *strncpy (char * __dest,
        const char * __src, size_t __n)
     ;


extern char *strcat (char * __dest, const char * __src)
     ;

extern char *strncat (char * __dest, const char * __src,
        size_t __n) ;


extern int strcmp (const char *__s1, const char *__s2)
     ;

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     ;


extern int strcoll (const char *__s1, const char *__s2)
     ;

extern size_t strxfrm (char * __dest,
         const char * __src, size_t __n)
     ;






# 1 "/usr/include/xlocale.h" 1 3 4
# 28 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 162 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     ;

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) ;




extern char *strdup (const char *__s)
     ;






extern char *strndup (const char *__string, size_t __n)
     ;
# 208 "/usr/include/string.h" 3 4

# 233 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     ;
# 260 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     ;


# 279 "/usr/include/string.h" 3 4



extern size_t strcspn (const char *__s, const char *__reject)
     ;


extern size_t strspn (const char *__s, const char *__accept)
     ;
# 312 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     ;
# 340 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     ;




extern char *strtok (char * __s, const char * __delim)
     ;




extern char *__strtok_r (char * __s,
    const char * __delim,
    char ** __save_ptr)
     ;

extern char *strtok_r (char * __s, const char * __delim,
         char ** __save_ptr)
     ;
# 395 "/usr/include/string.h" 3 4


extern size_t strlen (const char *__s)
     ;





extern size_t strnlen (const char *__string, size_t __maxlen)
     ;





extern char *strerror (int __errnum) ;

# 429 "/usr/include/string.h" 3 4
extern int __xpg_strerror_r (int __errnum, char *__buf, size_t __buflen)
     ;
# 443 "/usr/include/string.h" 3 4
extern char *strerror_l (int __errnum, __locale_t __l) ;





extern void __bzero (void *__s, size_t __n) ;



extern void bcopy (const void *__src, void *__dest, size_t __n)
     ;


extern void bzero (void *__s, size_t __n) ;


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     ;
# 487 "/usr/include/string.h" 3 4
extern char *index (const char *__s, int __c)
     ;
# 515 "/usr/include/string.h" 3 4
extern char *rindex (const char *__s, int __c)
     ;




extern int ffs (int __i) ;
# 534 "/usr/include/string.h" 3 4
extern int strcasecmp (const char *__s1, const char *__s2)
     ;


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     ;
# 557 "/usr/include/string.h" 3 4
extern char *strsep (char ** __stringp,
       const char * __delim)
     ;




extern char *strsignal (int __sig) ;


extern char *__stpcpy (char * __dest, const char * __src)
     ;
extern char *stpcpy (char * __dest, const char * __src)
     ;



extern char *__stpncpy (char * __dest,
   const char * __src, size_t __n)
     ;
extern char *stpncpy (char * __dest,
        const char * __src, size_t __n)
     ;
# 644 "/usr/include/string.h" 3 4

# 59 "grep.c" 2
# 80 "grep.c"
# 1 "/usr/include/fcntl.h" 1 3 4
# 30 "/usr/include/fcntl.h" 3 4




# 1 "/usr/include/bits/fcntl.h" 1 3 4
# 25 "/usr/include/bits/fcntl.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 26 "/usr/include/bits/fcntl.h" 2 3 4
# 160 "/usr/include/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };
# 259 "/usr/include/bits/fcntl.h" 3 4

# 304 "/usr/include/bits/fcntl.h" 3 4

# 35 "/usr/include/fcntl.h" 2 3 4
# 64 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 73 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) ;
# 97 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...)
     ;
# 108 "/usr/include/fcntl.h" 3 4
extern int openat64 (int __fd, const char *__file, int __oflag, ...)
     ;
# 118 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, __mode_t __mode) ;
# 147 "/usr/include/fcntl.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len);
# 164 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, __off_t __offset, __off_t __len,
     int __advise) ;
# 186 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, __off_t __offset, __off_t __len);
# 208 "/usr/include/fcntl.h" 3 4

# 81 "grep.c" 2
# 1 "/usr/include/unistd.h" 1 3 4
# 28 "/usr/include/unistd.h" 3 4

# 203 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/bits/posix_opt.h" 1 3 4
# 204 "/usr/include/unistd.h" 2 3 4
# 227 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 228 "/usr/include/unistd.h" 2 3 4
# 256 "/usr/include/unistd.h" 3 4
typedef __useconds_t useconds_t;
# 268 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 288 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) ;
# 305 "/usr/include/unistd.h" 3 4
extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     ;
# 331 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) ;
# 350 "/usr/include/unistd.h" 3 4
extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 414 "/usr/include/unistd.h" 3 4
extern int pipe (int __pipedes[2]) ;
# 429 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) ;
# 441 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);






extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     ;






extern int usleep (__useconds_t __useconds);
# 465 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     ;



extern int chdir (const char *__path) ;



extern int fchdir (int __fd) ;
# 507 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) ;
# 520 "/usr/include/unistd.h" 3 4
extern char *getwd (char *__buf)
     ;




extern int dup (int __fd) ;


extern int dup2 (int __fd, int __fd2) ;
# 538 "/usr/include/unistd.h" 3 4
extern char **__environ;







extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) ;




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     ;




extern int execv (const char *__path, char *const __argv[])
     ;



extern int execle (const char *__path, const char *__arg, ...)
     ;



extern int execl (const char *__path, const char *__arg, ...)
     ;



extern int execvp (const char *__file, char *const __argv[])
     ;




extern int execlp (const char *__file, const char *__arg, ...)
     ;
# 593 "/usr/include/unistd.h" 3 4
extern int nice (int __inc) ;




extern void _exit (int __status) ;





# 1 "/usr/include/bits/confname.h" 1 3 4
# 26 "/usr/include/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS

  };
# 605 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     ;


extern long int fpathconf (int __fd, int __name) ;


extern long int sysconf (int __name) ;



extern size_t confstr (int __name, char *__buf, size_t __len) ;




extern __pid_t getpid (void) ;


extern __pid_t getppid (void) ;




extern __pid_t getpgrp (void) ;
# 641 "/usr/include/unistd.h" 3 4
extern __pid_t __getpgid (__pid_t __pid) ;
# 650 "/usr/include/unistd.h" 3 4
extern int setpgid (__pid_t __pid, __pid_t __pgid) ;
# 667 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) ;
# 684 "/usr/include/unistd.h" 3 4
extern __pid_t setsid (void) ;







extern __uid_t getuid (void) ;


extern __uid_t geteuid (void) ;


extern __gid_t getgid (void) ;


extern __gid_t getegid (void) ;




extern int getgroups (int __size, __gid_t __list[]) ;
# 717 "/usr/include/unistd.h" 3 4
extern int setuid (__uid_t __uid) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) ;




extern int seteuid (__uid_t __uid) ;






extern int setgid (__gid_t __gid) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) ;




extern int setegid (__gid_t __gid) ;
# 773 "/usr/include/unistd.h" 3 4
extern __pid_t fork (void) ;






extern __pid_t vfork (void) ;





extern char *ttyname (int __fd) ;



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     ;



extern int isatty (int __fd) ;





extern int ttyslot (void) ;




extern int link (const char *__from, const char *__to)
     ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     ;




extern int symlink (const char *__from, const char *__to)
     ;




extern ssize_t readlink (const char * __path,
    char * __buf, size_t __len)
     ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) ;


extern ssize_t readlinkat (int __fd, const char * __path,
      char * __buf, size_t __len)
     ;



extern int unlink (const char *__name) ;



extern int unlinkat (int __fd, const char *__name, int __flag)
     ;



extern int rmdir (const char *__path) ;



extern __pid_t tcgetpgrp (int __fd) ;


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) ;






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) ;




extern int setlogin (const char *__name) ;
# 887 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 59 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 73 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 152 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       ;
# 888 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) ;






extern int sethostname (const char *__name, size_t __len)
     ;



extern int sethostid (long int __id) ;





extern int getdomainname (char *__name, size_t __len)
     ;
extern int setdomainname (const char *__name, size_t __len)
     ;





extern int vhangup (void) ;


extern int revoke (const char *__file) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     ;





extern int acct (const char *__name) ;



extern char *getusershell (void) ;
extern void endusershell (void) ;
extern void setusershell (void) ;





extern int daemon (int __nochdir, int __noclose) ;






extern int chroot (const char *__path) ;



extern char *getpass (const char *__prompt) ;
# 973 "/usr/include/unistd.h" 3 4
extern int fsync (int __fd);






extern long int gethostid (void);


extern void sync (void) ;




extern int getpagesize (void) ;




extern int getdtablesize (void) ;




extern int truncate (const char *__file, __off_t __length)
     ;
# 1020 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) ;
# 1040 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) ;





extern void *sbrk (intptr_t __delta) ;
# 1061 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) ;
# 1115 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);
# 1153 "/usr/include/unistd.h" 3 4

# 82 "grep.c" 2





# 1 "getpagesize.h" 1
# 88 "grep.c" 2
# 1 "grep.h" 1
# 20 "grep.h"
extern void fatal(const char *, int);





extern struct matcher
{
  char *name;
  void (*compile)(char *, size_t);
  char *(*execute)(char *, size_t, char **);
} matchers[];
# 47 "grep.h"
extern char *matcher;



extern int match_icase;
extern int match_words;
extern int match_lines;
# 89 "grep.c" 2
# 123 "grep.c"
char *matcher;
int match_icase;
int match_words;
int match_lines;


static void (*compile)();
static char *(*execute)();


static char *prog;
static char *filename;
static int errseen;



#define KCOV_BIDS 1675
static unsigned int kcov_branches = 3101;
static unsigned int kcov_lines[KCOV_BIDS] = {
3314, 3342, 3355, 3359, 3643, 3647, 3656, 3663, 3688, 3691, 3693, 3697, 3706, 3715, 3721, 3742, 3752, 3783, 3784, 3795, 3797, 3803, 3806, 3818, 3820, 3823, 3843, 3848, 3852, 3853, 3854, 3855, 3861, 3864, 3872, 3875, 3877, 3881, 3888, 3909, 3912, 3914, 3919, 3926, 3954, 3956, 3962, 3964, 3967, 3970, 3973, 3978, 3981, 3985, 3989, 3992, 3995, 4021, 4022, 4047, 4059, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4076, 4078, 4081, 4083, 4086, 4089, 4090, 4094, 4095, 4099, 4100, 4104, 4107, 4108, 4112, 4115, 4119, 4122, 4128, 4129, 4130, 4132, 4136, 4138, 4142, 4145, 4148, 4152, 4155, 4156, 4159, 4165, 4169, 4172, 4175, 4178, 4181, 4184, 4187, 4192, 4193, 4201, 4204, 4209, 4214, 4215, 4217, 4218, 4220, 4225, 4227, 4229, 4233, 4236, 4239, 4242, 4250, 4252, 4255, 4258, 4262, 4273, 4278, 4281, 4284, 4808, 4832, 4834, 4844, 4852, 4854, 4854, 4854, 4858, 4860, 4866, 4866, 4866, 4866, 4866, 4866, 4866, 4866, 4866, 4866, 4873, 4875, 4881, 4881, 4881, 4881, 4881, 4881, 4881, 4881, 4881, 4881, 4888, 4889, 4890, 4894, 4896, 4898, 4900, 4916, 4921, 4924, 4924, 4924, 4926, 4930, 4932, 4934, 4934, 4934, 4935, 4955, 4960, 4966, 4966, 4966, 4966, 4966, 4966, 4966, 4966, 4966, 4973, 4973, 4973, 4975, 4975, 4991, 4991, 4991, 4991, 4991, 4991, 4991, 4991, 4991, 4992, 4998, 5005, 5005, 5005, 5005, 5005, 5005, 5005, 5005, 5005, 5013, 5015, 5015, 5015, 5015, 5015, 5015, 5015, 5015, 5015, 5015, 5019, 5023, 5027, 5027, 5027, 5027, 5027, 5027, 5027, 5027, 5027, 5033, 5033, 5033, 5033, 5033, 5033, 5033, 5033, 5033, 5033, 5033, 5034, 5041, 5041, 5041, 5041, 5041, 5041, 5041, 5041, 5041, 5041, 5047, 5052, 5054, 5056, 5056, 5056, 5059, 5061, 5063, 5063, 5063, 5071, 5076, 5083, 5090, 5093, 5098, 5098, 5098, 5101, 5107, 5111, 5111, 5111, 5115, 5117, 5119, 5119, 5119, 5120, 5130, 5146, 5150, 5150, 5150, 5152, 5154, 5156, 5175, 5191, 5198, 5199, 5205, 5206, 5212, 5213, 5219, 5220, 5226, 5227, 5233, 5234, 5239, 5239, 5243, 5244, 5251, 5255, 5266, 5274, 5277, 5277, 5277, 5277, 5277, 5277, 5277, 5277, 5277, 5277, 5292, 5293, 5295, 5296, 5302, 5307, 5307, 5307, 5307, 5307, 5307, 5307, 5307, 5307, 5307, 5315, 5316, 5333, 5345, 5351, 5351, 5351, 5351, 5351, 5351, 5351, 5351, 5351, 5351, 5358, 5359, 5362, 5367, 5367, 5367, 5367, 5367, 5367, 5367, 5367, 5367, 5372, 5379, 5379, 5379, 5379, 5379, 5379, 5379, 5379, 5379, 5387, 5389, 5405, 5407, 5413, 5413, 5413, 5413, 5413, 5413, 5413, 5413, 5413, 5413, 5415, 5417, 5417, 5417, 5417, 5417, 5417, 5417, 5417, 5417, 5417, 5418, 5424, 5427, 5433, 5435, 5437, 5437, 5437, 5440, 5442, 5451, 5453, 5455, 5464, 5466, 5466, 5466, 5466, 5466, 5466, 5466, 5466, 5466, 5476, 5476, 5476, 5476, 5476, 5476, 5476, 5476, 5476, 5495, 5524, 5524, 5524, 5526, 5528, 5533, 5535, 5535, 5535, 5535, 5535, 5535, 5535, 5535, 5535, 5535, 5539, 5541, 5541, 5541, 5541, 5541, 5541, 5541, 5541, 5541, 5541, 5545, 5546, 5546, 5546, 5546, 5546, 5546, 5546, 5546, 5546, 5546, 5549, 5550, 5550, 5550, 5550, 5550, 5550, 5550, 5550, 5550, 5550, 5553, 5554, 5554, 5554, 5554, 5554, 5554, 5554, 5554, 5554, 5554, 5557, 5558, 5558, 5558, 5558, 5558, 5558, 5558, 5558, 5558, 5558, 5561, 5562, 5562, 5562, 5562, 5562, 5562, 5562, 5562, 5562, 5562, 5565, 5566, 5566, 5566, 5566, 5566, 5566, 5566, 5566, 5566, 5566, 5569, 5569, 5569, 5569, 5569, 5570, 5570, 5570, 5570, 5571, 5576, 5580, 5584, 5584, 5584, 5584, 5584, 5584, 5584, 5584, 5584, 5584, 5588, 5589, 5590, 5595, 5600, 5606, 5610, 5620, 5624, 5632, 5632, 5632, 5632, 5632, 5632, 5632, 5632, 5632, 5632, 5636, 5636, 5636, 5636, 5636, 5636, 5636, 5636, 5636, 5636, 5645, 5648, 5670, 5683, 5684, 5701, 5720, 5757, 5761, 5764, 5779, 5782, 5800, 5811, 5812, 5818, 5820, 5820, 5866, 5866, 5871, 5873, 5898, 5906, 5911, 5912, 5913, 5918, 5920, 5923, 5924, 5929, 5930, 5931, 5936, 5937, 5938, 5943, 5945, 5949, 5954, 5960, 5961, 5962, 5963, 5964, 5965, 5966, 5967, 5968, 5969, 5973, 5974, 5975, 5976, 5977, 5978, 5979, 5979, 5981, 5989, 5994, 5994, 5998, 6005, 6006, 6008, 6008, 6010, 6012, 6012, 6012, 6012, 6018, 6020, 6020, 6027, 6032, 6032, 6033, 6042, 6047, 6048, 6053, 6080, 6128, 6133, 6135, 6140, 6142, 6149, 6150, 6154, 6160, 6162, 6168, 6171, 6175, 6176, 6181, 6188, 6192, 6192, 6198, 6204, 6207, 6211, 6213, 6334, 6334, 6341, 6353, 6361, 6370, 6383, 6394, 6411, 6431, 6435, 6441, 6445, 6451, 6460, 6470, 6481, 6484, 6495, 6498, 6502, 6505, 6509, 6513, 6518, 6532, 6535, 6541, 6541, 6543, 6547, 6548, 6557, 6567, 6585, 6593, 6599, 6601, 6603, 6603, 6604, 6611, 6613, 6613, 6614, 6618, 6618, 6623, 6626, 6626, 6628, 6628, 6629, 6632, 6632, 6638, 6639, 6646, 6646, 6647, 6651, 6657, 6659, 6659, 6670, 6676, 6685, 6686, 6702, 6713, 6721, 6722, 6735, 6746, 6749, 6763, 6773, 6775, 6776, 6777, 6778, 6779, 6779, 6780, 6784, 6794, 6798, 6805, 6810, 6815, 6815, 6816, 6816, 6816, 6816, 6816, 6816, 6829, 6836, 6847, 6850, 6854, 6856, 6857, 6864, 6867, 6867, 6874, 6879, 6879, 6892, 6895, 6895, 6897, 6899, 6908, 6911, 6913, 6917, 6917, 6926, 6928, 6928, 6934, 6936, 6940, 6943, 6943, 6946, 6946, 6946, 6946, 6946, 6946, 6949, 6953, 6953, 6962, 6965, 6972, 6977, 6977, 6977, 6977, 6977, 6977, 6983, 6984, 6984, 6989, 6995, 7005, 7009, 7015, 7022, 7027, 7033, 7042, 7049, 7061, 7061, 7069, 7071, 7071, 7080, 7090, 7094, 7094, 7094, 7094, 7094, 7094, 7103, 7107, 7107, 7107, 7107, 7107, 7107, 7112, 7113, 7118, 7122, 7122, 7125, 7134, 7135, 7139, 7142, 7150, 7154, 7154, 7156, 7156, 7158, 7162, 7164, 7164, 7164, 7164, 7164, 7164, 7168, 7170, 7170, 7170, 7170, 7170, 7170, 7174, 7176, 7176, 7176, 7176, 7176, 7176, 7180, 7182, 7182, 7182, 7182, 7183, 7183, 7187, 7189, 7189, 7190, 7190, 7190, 7192, 7192, 7196, 7198, 7198, 7199, 7199, 7199, 7201, 7201, 7206, 7214, 7217, 7217, 7222, 7227, 7235, 7237, 7238, 7239, 7241, 7241, 7244, 7249, 7254, 7261, 7278, 7287, 7289, 7289, 7294, 7297, 7303, 7313, 7319, 7319, 7320, 7331, 7333, 7341, 7347, 7348, 7369, 7377, 7379, 7379, 7383, 7384, 7410, 7411, 7412, 7413, 7414, 7415, 7416, 7417, 7418, 7426, 7434, 7437, 7442, 7443, 7443, 7444, 7450, 7453, 7453, 7455, 7458, 7458, 7465, 7466, 7470, 7473, 7493, 7495, 7534, 7548, 7553, 7557, 7558, 7564, 7582, 7611, 7616, 7623, 7626, 7628, 7632, 7645, 7662, 7674, 7679, 7681, 7700, 7707, 7712, 7956, 7968, 7981, 8017, 8027, 8037, 8048, 8049, 8064, 8065, 8067, 8067, 8144, 8163, 8165, 8165, 8168, 8169, 8171, 8176, 8177, 8179, 8186, 8187, 8189, 8191, 8194, 8202, 8203, 8204, 8205, 8206, 8207, 8208, 8209, 8210, 8211, 8218, 8219, 8223, 8224, 8228, 8229, 8233, 8234, 8238, 8239, 8241, 8243, 8247, 8248, 8250, 8254, 8255, 8257, 8259, 8263, 8264, 8266, 8274, 8274, 8275, 8278, 8280, 8280, 8281, 8286, 8288, 8289, 8291, 8291, 8292, 8298, 8300, 8302, 8302, 8304, 8309, 8310, 8312, 8317, 8318, 8325, 8326, 8332, 8333, 8335, 8341, 8342, 8346, 8348, 8353, 8354, 8355, 8358, 8359, 8361, 8366, 8367, 8370, 8370, 8371, 8373, 8373, 8378, 8386, 8387, 8388, 8390, 8391, 8395, 8395, 8398, 8399, 8399, 8400, 8400, 8401, 8403, 8403, 8404, 8414, 8416, 8416, 8417, 8417, 8422, 8425, 8426, 8428, 8436, 8439, 8445, 8448, 8452, 8482, 8482, 8487, 8488, 8489, 8492, 8493, 8494, 8498, 8500, 8504, 8516, 8523, 8527, 8543, 8545, 8546, 8547, 8549, 8550, 8551, 8564, 8574, 8575, 8579, 8581, 8583, 8588, 8607, 8619, 8623, 8647, 8655, 8661, 8677, 8694, 8696, 8702, 8722, 8723, 8725, 8732, 8734, 8746, 8747, 8749, 8750, 8769, 8770, 8772, 8776, 8778, 8781, 8782, 8786, 8791, 8791, 8800, 8801, 8804, 8804, 8804, 8804, 8804, 8805, 8805, 8805, 8805, 8806, 8806, 8806, 8806, 8807, 8807, 8807, 8807, 8809, 8812, 8838, 8841, 8842, 8849, 8857, 8860, 8863, 8866, 8869, 8872, 8875, 8878, 8923, 8929, 8935, 8943, 8944, 8950, 8953, 8953, 8958, 8960, 8964, 8970, 8973, 8973, 8980, 8988, 8993, 9005, 9006, 9020, 9040, 9041, 9047, 9055, 9061, 9062, 9109, 9112, 9113, 9120, 9123, 9125, 9132, 9134, 9134, 9134, 9137, 9137, 9137, 9139, 9141, 9141, 9141, 9143, 9145, 9145, 9145, 9147, 9151, 9153, 9157, 9162, 9169, 9170, 9171, 9176, 9181, 9182, 9186, 9201, 9207, 9224, 9228, 9230, 9232, 9237, 9241, 9245, 9246, 9248, 9254, 9257, 9263, 9264, 9269, 9270, 9275, 9276, 9277, 9281, 9282, 9284, 9285, 9286, 9291, 9295, 9301, 9302, 9303, 9307, 9309, 9311, 9316, 9334, 9336, 9337, 9342, 9354, 9354, 9354, 9354, 9354, 9357, 9357, 9357, 9357, 9357, 9360, 9360, 9360, 9360, 9360, 9370, 9371, 9375, 9382, 9394, 9430, 9435, 9436, 9438, 9444, 9452, 9455, 9456, 9459, 9469, 9471, 9473, 9474, 9487, 9491, 9494, 9501, 9539, 9545, 9550, 9551, 9584, 9587, 9588, 9591, 9592, 9594, 9599, 9615, 9616, 9618, 9621, 9625, 9646, 9647, 9656, 9666, 9668, 9683, 9685, 9692, 9693, 9700, 9701, 9706, 9713, 9733, 9736, 9739, 9743, 9745, 9747, 9751, 9753, 9766, 9768, 9771, 9788, 9791, 9794, 9796, 9799, 9806, 9846, 9849, 9851, 9857, 9864, 9868, 9869, 9871, 9872, 9873, 9874, 9875, 9876, 9877, 9878, 9881, 9882, 9883, 9888, 9889, 9890, 9901, 9905, 9912, 9914, 9915, 9917, 9921, 9928, 9929, 9934, 9935, 9937, 9938, 9940, 9943, 9944, 9956, 9958, 9964, 9967, 9972, 9976, 9980, 9984, 9987, 9990, 9993, 10000, 10001, 10006, 10011, 10023, 10032, 10042, 10258, 10264, 10264, 10264, 10265, 10308, 10310, 10320, 10323, 10332, 10334, 10334, 10334, 10336, 10340, 10340, 10340, 10342, 10355, 10361, 10363, 10371, 10374, 10376, 10377, 10379, 10384, 10388, 10389, 10394, 10395, 10397, 10402, 10406, 10407, 10414, 10426, 10431, 10433, 10446, 10464, 10472, 10475, 10476, 10480, 10499, 10503, 10513, 10515, 10517, 10519, 10520, 10534, 10559, 10560, 10563, 10568, 10571, 10571, 10571, 10572, 10578, 10583, 10584, 10591, 10607, 10612, 10613, 10619, 10626, 10628, 10630, 10636, 10640, 10641, 10644, 10649, 10650, 10653, 10676, 10678, 10680, 10690, 10692, 10694, 10698, 10703, 10708, 10715, 10717, 10719, 10729, 10732, 10734, 10736, 10738, 10766, 10773, 10781, 10786, 10788, 10791, 10801, 10805, 10811, 10813, 10815, 10816, 10820, 10823, 10833, 10842, 10846, 10848, 10851, 10856, 10862, 10864, 10866, 10867, 10871, 10874, 10884, 10889, 10893, 10913, 10916, 10936, 10990, 10991, 10992, 10994, 10994, 11008, 11014, 11016, 11019, 11024, 11026, 11028, 11031, 11049, 11058, 11071, 11073, 11080, 11082, 11104, 11115, 11124, 11137, 11139, 11146, 11148, 11174, 11176, 11180, 11185, 11187, 11190, 11192, 11199, 11208, 11212, 11214, 11217, 11223, 11226, 11234, 11235, 11237, 11240, 11247, 11250, 11266, 11279, 11281, 11283, 11285, 11291, 11305, 11307, 11310, 11312, 11314, 11318, 11319, 11321, 11323, 11338, 11343, };
static unsigned int kcov_counts[KCOV_BIDS];
static unsigned int kcov_thens[KCOV_BIDS];
static char *kcov_exprs[KCOV_BIDS] = {
"errnum",
"size && !result",
"ptr",
"size && !result",
"!initialized",
"(8192) > (getpagesize())",
"!buffer",
"fstat(fd, &bufstat) < 0 || !((((bufstat.st_mode)) & 61440) == (32768))",
"pagesize == 0 && (pagesize = getpagesize()) == 0",
"save > bufsalloc",
"save > bufsalloc",
"!nbuffer",
"save--",
"bufmapped && bufoffset % pagesize == 0 && bufstat.st_size - bufoffset >= bufalloc - bufsalloc",
"maddr == (caddr_t)-1",
"bufmapped",
"cc > 0",
"beg < lim",
"*beg == '\\n'",
"out_file",
"out_line",
"out_byte",
"ferror(stdout)",
"!lastout",
"pending > 0 && lastout < lim",
"(nl = memchr(lastout, '\\n', lim - lastout)) != 0",
"!out_quiet && pending > 0",
"!out_quiet",
"lastout",
"i < out_before",
"p > bp",
"p > bp && p[-1] != '\\n'",
"(out_before || out_after) && used && p != lastout",
"p < beg",
"nlinesp",
"p < lim",
"(nl = memchr(p, '\\n', lim - p)) != 0",
"!out_quiet",
"!out_quiet",
"(b = (*execute)(p, lim - p, &endp)) != 0",
"b == lim && ((b > beg && b[-1] == '\\n') || b == beg)",
"!out_invert",
"p < b",
"out_invert && p < lim",
"",
"fillbuf(save) < 0",
"lastout",
"buflim - bufbeg == save",
"lim > beg && lim[-1] != '\\n'",
"beg < lim",
"pending",
"i < out_before && beg > bufbeg && beg != lastout",
"beg > bufbeg && beg[-1] != '\\n'",
"beg != lastout",
"out_line",
"residue",
"pending",
"matchers[i].name",
"strcmp(name, matchers[i].name) == 0",
"prog && strrchr(prog, '/')",
"(opt = getopt(argc, argv, \"0123456789A:B:CEFGVX:bce:f:hiLlnqsvwxy\")) != (-1)",
"'0'",
"'1'",
"'2'",
"'3'",
"'4'",
"'5'",
"'6'",
"'7'",
"'8'",
"'9'",
"'A'",
"out_after < 0",
"'B'",
"out_before < 0",
"'C'",
"'E'",
"matcher && strcmp(matcher, \"egrep\") != 0",
"'F'",
"matcher && strcmp(matcher, \"fgrep\") != 0",
"'G'",
"matcher && strcmp(matcher, \"grep\") != 0",
"'V'",
"'X'",
"matcher",
"'b'",
"'c'",
"'e'",
"keyfound",
"'f'",
"strcmp(optarg, \"-\") != 0",
"!fp",
"keyalloc <= keycc",
"keyfound",
"!feof(fp) && (cc = fread(keys + keycc, 1, keyalloc - keycc, fp)) > 0",
"keycc == keyalloc",
"fp != stdin",
"keycc - oldcc > 0 && keys[keycc - 1] == '\\n'",
"'h'",
"'i'",
"'y'",
"'L'",
"'l'",
"'n'",
"'q'",
"'s'",
"'v'",
"'w'",
"'x'",
"\"default\"",
"!keyfound",
"optind < argc",
"!matcher",
"!setmatcher(matcher) && !setmatcher(\"default\")",
"argc - optind > 1 && !no_filenames",
"optind < argc",
"optind < argc",
"strcmp(argv[optind], \"-\")",
"desc < 0",
"!suppress_errors",
"desc == 0",
"count_matches",
"out_file",
"count",
"list_files == 1",
"list_files == -1",
"desc != 0",
"count_matches",
"count",
"list_files == 1",
"list_files == -1",
"errseen",
"done",
"c <= 'z'",
"c <= 'Z'",
"c <= '9'",
"compile_stack.stack == ((void *)0)",
"bufp->allocated == 0",
"bufp->buffer",
"!bufp->buffer",
"p != pend",
"0",
"p == pend",
"translate",
"'^'",
"p == pattern + 1 || syntax & ((((1) << 1) << 1) << 1) || at_begline_loc_p(pattern, p, syntax)",
"0",
"b - bufp->buffer + (1) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"'$'",
"p == pend || syntax & ((((1) << 1) << 1) << 1) || at_endline_loc_p(p, pend, syntax)",
"0",
"b - bufp->buffer + (1) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"'+'",
"'?'",
"(syntax & ((1) << 1)) || (syntax & (((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))",
"'*'",
"!laststart",
"syntax & ((((((1) << 1) << 1) << 1) << 1) << 1)",
"!(syntax & (((((1) << 1) << 1) << 1) << 1))",
"",
"p == pend",
"0",
"p == pend",
"translate",
"c == '*' || (!(syntax & ((1) << 1)) && (c == '+' || c == '?'))",
"syntax & ((1) << 1) && c == '\\\\'",
"p == pend",
"0",
"p == pend",
"translate",
"!(c1 == '+' || c1 == '?')",
"!laststart",
"many_times_ok",
"b - bufp->buffer + (3) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"(translate ? translate[(unsigned char)(*(p - 2))] : (*(p - 2))) == (translate ? translate[(unsigned char)('.')] : ('.')) && zero_times_ok && p < pend && (translate ? translate[(unsigned char)(*p)] : (*p)) == (translate ? translate[(unsigned char)('\\n')] : ('\\n')) && !(syntax & (((((((1) << 1) << 1) << 1) << 1) << 1) << 1))",
"translate",
"translate",
"translate",
"translate",
"b - bufp->buffer + (3) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"keep_string_p",
"!zero_times_ok",
"b - bufp->buffer + (3) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"'.'",
"0",
"b - bufp->buffer + (1) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"'['",
"p == pend",
"b - bufp->buffer + (34) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"0",
"b - bufp->buffer + (1) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"*p == '^'",
"*p == '^'",
"0",
"b - bufp->buffer + (1) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"(re_opcode_t)b[-2] == charset_not && (syntax & (((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))",
"",
"p == pend",
"0",
"p == pend",
"translate",
"(syntax & (1)) && c == '\\\\'",
"p == pend",
"0",
"p == pend",
"translate",
"c == ']' && p != p1 + 1",
"had_char_class && c == '-' && *p != ']'",
"c == '-' && !(p - 2 >= pattern && p[-2] == '[') && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^') && *p != ']'",
"ret != REG_NOERROR",
"p[0] == '-' && p[1] != ']'",
"0",
"p == pend",
"translate",
"ret != REG_NOERROR",
"syntax & (((1) << 1) << 1) && c == '[' && *p == ':'",
"0",
"p == pend",
"translate",
"p == pend",
"",
"0",
"p == pend",
"translate",
"c == ':' || c == ']' || p == pend || c1 == 6",
"c == ':' && *p == ']'",
"!(((strcmp(str, \"alpha\") == 0)) || ((strcmp(str, \"upper\") == 0)) || ((strcmp(str, \"lower\") == 0)) || ((strcmp(str, \"digit\") == 0)) || ((strcmp(str, \"alnum\") == 0)) || ((strcmp(str, \"xdigit\") == 0)) || ((strcmp(str, \"space\") == 0)) || ((strcmp(str, \"print\") == 0)) || ((strcmp(str, \"punct\") == 0)) || ((strcmp(str, \"graph\") == 0)) || ((strcmp(str, \"cntrl\") == 0)) || ((strcmp(str, \"blank\") == 0)))",
"0",
"p == pend",
"translate",
"p == pend",
"ch < 1 << 8",
"(is_alnum && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISalnum))) || (is_alpha && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISalpha))) || (is_blank && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISblank))) || (is_cntrl && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_IScntrl))) || (is_digit && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISdigit))) || (is_graph && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISgraph))) || (is_lower && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISlower))) || (is_print && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISprint))) || (is_punct && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISpunct))) || (is_space && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISspace))) || (is_upper && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISupper))) || (is_xdigit && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISxdigit)))",
"c1--",
"(int)b[-1] > 0 && b[b[-1] - 1] == 0",
"'('",
"syntax & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"')'",
"syntax & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"'\\n'",
"syntax & ((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"'|'",
"syntax & ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"'{'",
"syntax & ((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) && syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"'\\\\'",
"p == pend",
"0",
"p == pend",
"'('",
"syntax & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"(compile_stack.avail == compile_stack.size)",
"compile_stack.stack == ((void *)0)",
"fixup_alt_jump",
"regnum <= 255",
"0",
"b - bufp->buffer + (3) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"')'",
"syntax & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"(compile_stack.avail == 0)",
"syntax & ((((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"fixup_alt_jump",
"0",
"b - bufp->buffer + (1) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"(compile_stack.avail == 0)",
"syntax & ((((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"(compile_stack.stack[compile_stack.avail]).fixup_alt_jump",
"this_group_regnum <= 255",
"0",
"b - bufp->buffer + (3) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"'|'",
"syntax & (((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) || syntax & ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"syntax & (((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"b - bufp->buffer + (3) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"fixup_alt_jump",
"b - bufp->buffer + (3) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"'{'",
"!(syntax & ((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) || ((syntax & ((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && (syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) || (p - 2 == pattern && p == pend)",
"p == pend",
"syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"p != pend",
"0",
"p == pend",
"translate",
"(1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit))",
"lower_bound < 0",
"p == pend",
"0",
"p == pend",
"translate",
"c == ','",
"p != pend",
"0",
"p == pend",
"translate",
"(1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit))",
"upper_bound < 0",
"p == pend",
"0",
"p == pend",
"translate",
"upper_bound < 0",
"lower_bound < 0 || upper_bound > ((1 << 15) - 1) || lower_bound > upper_bound",
"syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"!(syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))",
"c != '\\\\'",
"0",
"p == pend",
"translate",
"c != '}'",
"syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"!laststart",
"syntax & ((((((1) << 1) << 1) << 1) << 1) << 1)",
"syntax & (((((1) << 1) << 1) << 1) << 1)",
"upper_bound == 0",
"b - bufp->buffer + (3) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"b - bufp->buffer + (nbytes) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"upper_bound > 1",
"0",
"p == pend",
"translate",
"!(syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))",
"p > pattern && p[-1] == '\\\\'",
"'w'",
"0",
"b - bufp->buffer + (1) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"'W'",
"0",
"b - bufp->buffer + (1) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"'<'",
"0",
"b - bufp->buffer + (1) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"'>'",
"0",
"b - bufp->buffer + (1) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"'b'",
"0",
"b - bufp->buffer + (1) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"'B'",
"0",
"b - bufp->buffer + (1) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"'`'",
"0",
"b - bufp->buffer + (1) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"'\\''",
"0",
"b - bufp->buffer + (1) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"'1'",
"'2'",
"'3'",
"'4'",
"'5'",
"'6'",
"'7'",
"'8'",
"'9'",
"syntax & (((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"c1 > regnum",
"group_in_compile_stack(compile_stack, c1)",
"0",
"b - bufp->buffer + (2) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"'+'",
"'?'",
"syntax & ((1) << 1)",
"\"default\"",
"translate",
"\"default\"",
"!pending_exact || pending_exact + *pending_exact + 1 != b || *pending_exact == (1 << 8) - 1 || *p == '*' || *p == '^' || ((syntax & ((1) << 1)) ? *p == '\\\\' && (p[1] == '+' || p[1] == '?') : (*p == '+' || *p == '?')) || ((syntax & ((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && ((syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) ? *p == '{' : (p[0] == '\\\\' && p[1] == '{')))",
"(syntax & ((1) << 1))",
"(syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))",
"0",
"b - bufp->buffer + (2) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"0",
"b - bufp->buffer + (1) > bufp->allocated",
"0",
"bufp->allocated == (1L << 16)",
"bufp->allocated > (1L << 16)",
"bufp->buffer == ((void *)0)",
"old_buffer != bufp->buffer",
"fixup_alt_jump",
"laststart",
"pending_exact",
"fixup_alt_jump",
"!(compile_stack.avail == 0)",
"0",
"0",
"0",
"pfrom != loc",
"pfrom != loc",
"p + 1 < pend",
"syntax & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"syntax & ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"this_element >= 0",
"compile_stack.stack[this_element].regnum == regnum",
"p == pend",
"range_start > range_end",
"syntax & (((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"this_char <= range_end",
"translate",
"translate",
"0",
"fail_stack.stack == ((void *)0)",
"p != pend || !(fail_stack.avail == 0)",
"p == pend",
"duplicate",
"exactn",
"charset",
"j >= 0",
"p[j / 8] & (1 << (j % 8))",
"charset_not",
"j < (1 << 8)",
"j >= 0",
"!(p[j / 8] & (1 << (j % 8)))",
"wordchar",
"j < (1 << 8)",
"re_syntax_table[j] == 1",
"notwordchar",
"j < (1 << 8)",
"re_syntax_table[j] != 1",
"anychar",
"j < (1 << 8)",
"!(bufp->syntax & (((((((1) << 1) << 1) << 1) << 1) << 1) << 1))",
"bufp->can_be_null",
"no_op",
"begline",
"endline",
"begbuf",
"endbuf",
"wordbound",
"notwordbound",
"wordbeg",
"wordend",
"push_dummy_failure",
"jump_n",
"pop_failure_jump",
"maybe_pop_jump",
"jump",
"jump_past_alt",
"dummy_failure_jump",
"0",
"0",
"j > 0",
"(re_opcode_t)*p != on_failure_jump && (re_opcode_t)*p != succeed_n",
"0",
"0",
"!(fail_stack.avail == 0) && fail_stack.stack[fail_stack.avail - 1] == p",
"on_failure_jump",
"on_failure_keep_string_jump",
"0",
"0",
"p + j < pend",
"!(((fail_stack.avail == fail_stack.size) && !((fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4) ? 0 : ((fail_stack).stack = (fail_stack_elt_t *)(destination = (char *)alloca(((fail_stack).size << 1) * sizeof(fail_stack_elt_t)) , memcpy((destination), ((fail_stack).stack), ((fail_stack).size * sizeof(fail_stack_elt_t))) , destination) , (fail_stack).stack == ((void *)0) ? 0 : ((fail_stack).size <<= 1 , 1)))) ? 0 : ((fail_stack).stack[(fail_stack).avail++] = p + j , 1))",
"((fail_stack.avail == fail_stack.size) && !((fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4) ? 0 : ((fail_stack).stack = (fail_stack_elt_t *)(destination = (char *)alloca(((fail_stack).size << 1) * sizeof(fail_stack_elt_t)) , memcpy((destination), ((fail_stack).stack), ((fail_stack).size * sizeof(fail_stack_elt_t))) , destination) , (fail_stack).stack == ((void *)0) ? 0 : ((fail_stack).size <<= 1 , 1))))",
"(fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4)",
"(fail_stack).stack == ((void *)0)",
"succeed_n_p",
"0",
"0",
"succeed_n",
"0",
"0",
"k == 0",
"set_number_at",
"start_memory",
"stop_memory",
"\"default\"",
"num_regs",
"startpos < 0 || startpos > total_size",
"endpos < -1",
"endpos > total_size",
"bufp->used > 0 && (re_opcode_t)bufp->buffer[0] == begbuf && range > 0",
"startpos > 0",
"fastmap && !bufp->fastmap_accurate",
"re_compile_fastmap(bufp) == -2",
"",
"fastmap && startpos < total_size && !bufp->can_be_null",
"range > 0",
"startpos < size1 && startpos + range >= size1",
"startpos >= size1",
"translate",
"range > lim && !fastmap[(unsigned char)translate[(unsigned char)*d++]]",
"range > lim && !fastmap[(unsigned char)*d++]",
"size1 == 0 || startpos >= size1",
"!fastmap[(unsigned char)(translate ? translate[(unsigned char)(c)] : (c))]",
"translate",
"range >= 0 && startpos == total_size && fastmap && !bufp->can_be_null",
"val >= 0",
"val == -2",
"!range",
"range > 0",
"0",
"fail_stack.stack == ((void *)0)",
"bufp->re_nsub",
"!(regstart && regend && old_regstart && old_regend && reg_info && best_regstart && best_regend && reg_dummy && reg_info_dummy)",
"pos < 0 || pos > size1 + size2",
"mcnt < num_regs",
"size2 == 0 && string1 != ((void *)0)",
"stop <= size1",
"size1 > 0 && pos <= size1",
"",
"p == pend",
"d != end_match_2",
"!(fail_stack.avail == 0)",
"!best_regs_set || (same_str_p && d > match_end) || (!same_str_p && !(dend == end_match_1))",
"mcnt < num_regs",
"best_regs_set",
"(d >= string1 && d <= end1)",
"mcnt < num_regs",
"regs && !bufp->no_sub",
"bufp->regs_allocated == 0",
"(30) > (num_regs + 1)",
"regs->start == ((void *)0) || regs->end == ((void *)0)",
"bufp->regs_allocated == 1",
"regs->num_regs < num_regs + 1",
"regs->start == ((void *)0) || regs->end == ((void *)0)",
"regs->num_regs > 0",
"(dend == end_match_1)",
"mcnt < ((num_regs) < (regs->num_regs) ? (num_regs) : (regs->num_regs))",
"(num_regs) < (regs->num_regs)",
"((regstart[mcnt]) == ((char *)-1)) || ((regend[mcnt]) == ((char *)-1))",
"(size1 && string1 <= (regstart[mcnt]) && (regstart[mcnt]) <= string1 + size1)",
"(size1 && string1 <= (regend[mcnt]) && (regend[mcnt]) <= string1 + size1)",
"mcnt < regs->num_regs",
"(dend == end_match_1)",
"no_op",
"exactn",
"translate",
"--mcnt",
"d == dend",
"dend == end_match_2",
"translate[(unsigned char)*d++] != (char)*p++",
"--mcnt",
"d == dend",
"dend == end_match_2",
"*d++ != (char)*p++",
"0",
"r <= highest_active_reg",
"anychar",
"d == dend",
"dend == end_match_2",
"(!(bufp->syntax & (((((((1) << 1) << 1) << 1) << 1) << 1) << 1)) && (translate ? translate[(unsigned char)(*d)] : (*d)) == '\\n') || (bufp->syntax & ((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) && (translate ? translate[(unsigned char)(*d)] : (*d)) == '\\x00')",
"translate",
"translate",
"0",
"r <= highest_active_reg",
"charset",
"charset_not",
"d == dend",
"dend == end_match_2",
"translate",
"c < (unsigned int)(*p * 8) && p[1 + c / 8] & (1 << (c % 8))",
"!not",
"0",
"r <= highest_active_reg",
"start_memory",
"((reg_info[*p]).bits.match_null_string_p) == 3",
"((reg_info[*p]).bits.match_null_string_p)",
"((regstart[*p]) == ((char *)-1))",
"lowest_active_reg == ((1 << 8) + 1)",
"stop_memory",
"((reg_info[*p]).bits.match_null_string_p)",
"((regend[*p]) == ((char *)-1))",
"lowest_active_reg == highest_active_reg",
"r > 0 && !((reg_info[r]).bits.is_active)",
"r == 0",
"(!((reg_info[*p]).bits.matched_something) || (re_opcode_t)p[-3] == start_memory) && (p + 2) < pend",
"jump_n",
"pop_failure_jump",
"maybe_pop_jump",
"jump",
"dummy_failure_jump",
"0",
"0",
"is_a_jump_n",
"\"default\"",
"mcnt < 0 && (re_opcode_t)*p1 == on_failure_jump && (re_opcode_t)p1[3] == start_memory && p1[4] == *p",
"((reg_info[*p]).bits.ever_matched_something)",
"r < *p + *(p + 1)",
"(int)old_regend[r] >= (int)regstart[r]",
"0",
"0",
"0",
"((fail_stack).size - (fail_stack).avail) < ((highest_active_reg - lowest_active_reg + 1) * 3 + 4)",
"!((fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4) ? 0 : ((fail_stack).stack = (fail_stack_elt_t *)(destination = (char *)alloca(((fail_stack).size << 1) * sizeof(fail_stack_elt_t)) , memcpy((destination), ((fail_stack).stack), ((fail_stack).size * sizeof(fail_stack_elt_t))) , destination) , (fail_stack).stack == ((void *)0) ? 0 : ((fail_stack).size <<= 1 , 1)))",
"(fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4)",
"(fail_stack).stack == ((void *)0)",
"this_reg <= highest_active_reg",
"duplicate",
"((regstart[regno]) == ((char *)-1)) || ((regend[regno]) == ((char *)-1))",
"((size1 && string1 <= (regstart[regno]) && (regstart[regno]) <= string1 + size1) == (size1 && string1 <= (regend[regno]) && (regend[regno]) <= string1 + size1))",
"",
"d2 == dend2",
"dend2 == end_match_2",
"dend2 == regend[regno]",
"d2 == dend2",
"d == dend",
"dend == end_match_2",
"mcnt > dend2 - d2",
"translate ? bcmp_translate(d, d2, mcnt, translate) : memcmp((d), (d2), (mcnt))",
"translate",
"begline",
"((d) == (size1 ? string1 : string2) || !size2)",
"size1",
"!bufp->not_bol",
"d[-1] == '\\n' && bufp->newline_anchor",
"endline",
"((d) == end2)",
"!bufp->not_eol",
"(d == end1 ? *string2 : *d) == '\\n' && bufp->newline_anchor",
"d == end1",
"begbuf",
"((d) == (size1 ? string1 : string2) || !size2)",
"size1",
"endbuf",
"((d) == end2)",
"on_failure_keep_string_jump",
"0",
"0",
"0",
"((fail_stack).size - (fail_stack).avail) < ((highest_active_reg - lowest_active_reg + 1) * 3 + 4)",
"!((fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4) ? 0 : ((fail_stack).stack = (fail_stack_elt_t *)(destination = (char *)alloca(((fail_stack).size << 1) * sizeof(fail_stack_elt_t)) , memcpy((destination), ((fail_stack).stack), ((fail_stack).size * sizeof(fail_stack_elt_t))) , destination) , (fail_stack).stack == ((void *)0) ? 0 : ((fail_stack).size <<= 1 , 1)))",
"(fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4)",
"(fail_stack).stack == ((void *)0)",
"this_reg <= highest_active_reg",
"on_failure_jump",
"0",
"0",
"p1 < pend && (re_opcode_t)*p1 == no_op",
"p1 < pend && (re_opcode_t)*p1 == start_memory",
"lowest_active_reg == ((1 << 8) + 1)",
"0",
"((fail_stack).size - (fail_stack).avail) < ((highest_active_reg - lowest_active_reg + 1) * 3 + 4)",
"!((fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4) ? 0 : ((fail_stack).stack = (fail_stack_elt_t *)(destination = (char *)alloca(((fail_stack).size << 1) * sizeof(fail_stack_elt_t)) , memcpy((destination), ((fail_stack).stack), ((fail_stack).size * sizeof(fail_stack_elt_t))) , destination) , (fail_stack).stack == ((void *)0) ? 0 : ((fail_stack).size <<= 1 , 1)))",
"(fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4)",
"(fail_stack).stack == ((void *)0)",
"this_reg <= highest_active_reg",
"maybe_pop_jump",
"0",
"0",
"p2 + 2 < pend && ((re_opcode_t)*p2 == stop_memory || (re_opcode_t)*p2 == start_memory)",
"p2 == pend",
"(re_opcode_t)*p2 == exactn || (bufp->newline_anchor && (re_opcode_t)*p2 == endline)",
"*p2 == (unsigned char)endline",
"(re_opcode_t)p1[3] == exactn && p1[5] != c",
"(re_opcode_t)p1[3] == charset || (re_opcode_t)p1[3] == charset_not",
"c < (unsigned char)(p1[4] * 8) && p1[5 + c / 8] & (1 << (c % 8))",
"!not",
"(re_opcode_t)p[-1] != pop_failure_jump",
"pop_failure_jump",
"string_temp != ((void *)0)",
"this_reg >= dummy_low_reg",
"jump",
"0",
"0",
"jump_past_alt",
"dummy_failure_jump",
"0",
"((fail_stack).size - (fail_stack).avail) < ((highest_active_reg - lowest_active_reg + 1) * 3 + 4)",
"!((fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4) ? 0 : ((fail_stack).stack = (fail_stack_elt_t *)(destination = (char *)alloca(((fail_stack).size << 1) * sizeof(fail_stack_elt_t)) , memcpy((destination), ((fail_stack).stack), ((fail_stack).size * sizeof(fail_stack_elt_t))) , destination) , (fail_stack).stack == ((void *)0) ? 0 : ((fail_stack).size <<= 1 , 1)))",
"(fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4)",
"(fail_stack).stack == ((void *)0)",
"this_reg <= highest_active_reg",
"push_dummy_failure",
"0",
"((fail_stack).size - (fail_stack).avail) < ((highest_active_reg - lowest_active_reg + 1) * 3 + 4)",
"!((fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4) ? 0 : ((fail_stack).stack = (fail_stack_elt_t *)(destination = (char *)alloca(((fail_stack).size << 1) * sizeof(fail_stack_elt_t)) , memcpy((destination), ((fail_stack).stack), ((fail_stack).size * sizeof(fail_stack_elt_t))) , destination) , (fail_stack).stack == ((void *)0) ? 0 : ((fail_stack).size <<= 1 , 1)))",
"(fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4)",
"(fail_stack).stack == ((void *)0)",
"this_reg <= highest_active_reg",
"succeed_n",
"0",
"mcnt > 0",
"0",
"0",
"mcnt == 0",
"jump_n",
"0",
"mcnt",
"0",
"set_number_at",
"0",
"0",
"0",
"0",
"0",
"wordbound",
"(((d) == (size1 ? string1 : string2) || !size2) || ((d) == end2) || (re_syntax_table[(d - 1) == end1 ? *string2 : (d - 1) == string2 - 1 ? *(end1 - 1) : *(d - 1)] == 1) != (re_syntax_table[(d) == end1 ? *string2 : (d) == string2 - 1 ? *(end1 - 1) : *(d)] == 1))",
"size1",
"(d - 1) == end1",
"(d - 1) == string2 - 1",
"(d) == end1",
"(d) == string2 - 1",
"notwordbound",
"(((d) == (size1 ? string1 : string2) || !size2) || ((d) == end2) || (re_syntax_table[(d - 1) == end1 ? *string2 : (d - 1) == string2 - 1 ? *(end1 - 1) : *(d - 1)] == 1) != (re_syntax_table[(d) == end1 ? *string2 : (d) == string2 - 1 ? *(end1 - 1) : *(d)] == 1))",
"size1",
"(d - 1) == end1",
"(d - 1) == string2 - 1",
"(d) == end1",
"(d) == string2 - 1",
"wordbeg",
"(re_syntax_table[(d) == end1 ? *string2 : (d) == string2 - 1 ? *(end1 - 1) : *(d)] == 1) && (((d) == (size1 ? string1 : string2) || !size2) || !(re_syntax_table[(d - 1) == end1 ? *string2 : (d - 1) == string2 - 1 ? *(end1 - 1) : *(d - 1)] == 1))",
"(d) == end1",
"(d) == string2 - 1",
"size1",
"(d - 1) == end1",
"(d - 1) == string2 - 1",
"wordend",
"!((d) == (size1 ? string1 : string2) || !size2) && (re_syntax_table[(d - 1) == end1 ? *string2 : (d - 1) == string2 - 1 ? *(end1 - 1) : *(d - 1)] == 1) && (!(re_syntax_table[(d) == end1 ? *string2 : (d) == string2 - 1 ? *(end1 - 1) : *(d)] == 1) || ((d) == end2))",
"size1",
"(d - 1) == end1",
"(d - 1) == string2 - 1",
"(d) == end1",
"(d) == string2 - 1",
"wordchar",
"d == dend",
"dend == end_match_2",
"!(re_syntax_table[(d) == end1 ? *string2 : (d) == string2 - 1 ? *(end1 - 1) : *(d)] == 1)",
"(d) == end1",
"(d) == string2 - 1",
"0",
"r <= highest_active_reg",
"notwordchar",
"d == dend",
"dend == end_match_2",
"(re_syntax_table[(d) == end1 ? *string2 : (d) == string2 - 1 ? *(end1 - 1) : *(d)] == 1)",
"(d) == end1",
"(d) == string2 - 1",
"0",
"r <= highest_active_reg",
"\"default\"",
"!(fail_stack.avail == 0)",
"string_temp != ((void *)0)",
"this_reg >= lowest_active_reg",
"!p",
"p < pend",
"jump_n",
"maybe_pop_jump",
"pop_failure_jump",
"jump",
"0",
"0",
"(is_a_jump_n && (re_opcode_t)*p1 == succeed_n) || (!is_a_jump_n && (re_opcode_t)*p1 == on_failure_jump)",
"\"default\"",
"d >= string1 && d <= end1",
"best_regs_set",
"p1 < end",
"on_failure_jump",
"0",
"0",
"mcnt >= 0",
"(re_opcode_t)p1[mcnt - 3] == jump_past_alt",
"!alt_match_null_string_p(p1, p1 + mcnt - 3, reg_info)",
"(re_opcode_t)*p1 != on_failure_jump",
"0",
"0",
"(re_opcode_t)p1[mcnt - 3] != jump_past_alt",
"0",
"!alt_match_null_string_p(p1, p1 + mcnt, reg_info)",
"stop_memory",
"\"default\"",
"!common_op_match_null_string_p(&p1, end, reg_info)",
"p1 < end",
"on_failure_jump",
"0",
"0",
"\"default\"",
"!common_op_match_null_string_p(&p1, end, reg_info)",
"no_op",
"begline",
"endline",
"begbuf",
"endbuf",
"wordbeg",
"wordend",
"wordbound",
"notwordbound",
"start_memory",
"((reg_info[reg_no]).bits.match_null_string_p) == 3",
"!ret",
"jump",
"0",
"0",
"mcnt >= 0",
"succeed_n",
"0",
"0",
"mcnt == 0",
"0",
"0",
"duplicate",
"!((reg_info[*p1]).bits.match_null_string_p)",
"set_number_at",
"\"default\"",
"len",
"translate[*p1++] != translate[*p2++]",
"(cflags & 1)",
"cflags & (1 << 1)",
"preg->translate == ((void *)0)",
"i < 256",
"(1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper))",
"cflags & ((1 << 1) << 1)",
"ret == REG_ERPAREN",
"want_reg_info",
"regs.start == ((void *)0) || regs.end == ((void *)0)",
"want_reg_info",
"want_reg_info",
"ret >= 0",
"r < nmatch",
"ret >= 0",
"errcode < 0 || errcode >= (sizeof (re_error_msg) / sizeof (re_error_msg[0]))",
"!msg",
"errbuf_size != 0",
"msg_size > errbuf_size",
"preg->buffer != ((void *)0)",
"preg->fastmap != ((void *)0)",
"preg->translate != ((void *)0)",
"!r",
"!r",
"!r",
"i < (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int)))",
"i < (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int)))",
"i < (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int)))",
"i < (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int)))",
"s1[i] != s2[i]",
"i < dfa->cindex",
"equal(s, dfa->charclasses[i])",
"(dfa->cindex) >= (dfa->calloc)",
"(dfa->cindex) >= (dfa->calloc)",
"lexleft < len",
"i < 2",
"!lexleft",
"0 != 0",
"'\\\\'",
"backslash",
"lexleft == 0",
"'^'",
"backslash",
"syntax_bits & ((((1) << 1) << 1) << 1) || lasttok == END || lasttok == LPAREN || lasttok == OR",
"'$'",
"backslash",
"syntax_bits & ((((1) << 1) << 1) << 1) || lexleft == 0 || (syntax_bits & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) ? lexleft > 0 && *lexptr == ')' : lexleft > 1 && lexptr[0] == '\\\\' && lexptr[1] == ')') || (syntax_bits & ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) ? lexleft > 0 && *lexptr == '|' : lexleft > 1 && lexptr[0] == '\\\\' && lexptr[1] == '|') || ((syntax_bits & ((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && lexleft > 0 && *lexptr == '\\n')",
"syntax_bits & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"syntax_bits & ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"'1'",
"'2'",
"'3'",
"'4'",
"'5'",
"'6'",
"'7'",
"'8'",
"'9'",
"backslash && !(syntax_bits & (((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))",
"'<'",
"backslash",
"'>'",
"backslash",
"'b'",
"backslash",
"'B'",
"backslash",
"'?'",
"syntax_bits & (((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"backslash != ((syntax_bits & ((1) << 1)) != 0)",
"!(syntax_bits & (((((1) << 1) << 1) << 1) << 1)) && laststart",
"'*'",
"backslash",
"!(syntax_bits & (((((1) << 1) << 1) << 1) << 1)) && laststart",
"'+'",
"syntax_bits & (((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"backslash != ((syntax_bits & ((1) << 1)) != 0)",
"!(syntax_bits & (((((1) << 1) << 1) << 1) << 1)) && laststart",
"'{'",
"!(syntax_bits & ((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))",
"backslash != ((syntax_bits & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0)",
"!lexleft",
"\"unfinished repeat count\" != 0",
"(1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit))",
"",
"!lexleft",
"\"unfinished repeat count\" != 0",
"!(1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit))",
"c != ','",
"c == ','",
"",
"!lexleft",
"\"unfinished repeat count\" != 0",
"!(1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit))",
"!(syntax_bits & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))",
"c != '\\\\'",
"!lexleft",
"\"unfinished repeat count\" != 0",
"c != '}'",
"'|'",
"syntax_bits & (((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"backslash != ((syntax_bits & ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0)",
"'\\n'",
"syntax_bits & (((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) || backslash || !(syntax_bits & ((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))",
"'('",
"backslash != ((syntax_bits & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0)",
"')'",
"backslash != ((syntax_bits & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0)",
"parens == 0 && syntax_bits & ((((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"'.'",
"backslash",
"!(syntax_bits & (((((((1) << 1) << 1) << 1) << 1) << 1) << 1))",
"syntax_bits & ((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"'w'",
"'W'",
"!backslash",
"c2 < (1 << 8)",
"(1 && ((*__ctype_b_loc())[(int)((c2))] & (unsigned short)_ISalnum))",
"c == 'W'",
"'['",
"backslash",
"!lexleft",
"\"Unbalanced [\" != 0",
"c == '^'",
"!lexleft",
"\"Unbalanced [\" != 0",
"(c = c1) != ']'",
"c == '[' && (syntax_bits & (((1) << 1) << 1))",
"prednames[c1].name",
"looking_at(prednames[c1].name)",
"c2 < (1 << 8)",
"(*prednames[c1].pred)(c2)",
"!lexleft",
"\"Unbalanced [\" != 0",
"c == '\\\\' && (syntax_bits & (1))",
"!lexleft",
"\"Unbalanced [\" != 0",
"!lexleft",
"\"Unbalanced [\" != 0",
"c1 == '-'",
"!lexleft",
"\"Unbalanced [\" != 0",
"c2 == ']'",
"c2 == '\\\\' && (syntax_bits & (1))",
"!lexleft",
"\"Unbalanced [\" != 0",
"!lexleft",
"\"Unbalanced [\" != 0",
"c <= c2",
"case_fold",
"(1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISupper))",
"(1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISlower))",
"invert",
"syntax_bits & (((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)",
"\"default\"",
"case_fold && (1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha))",
"((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISupper)",
"(dfa->tindex) >= (dfa->talloc)",
"(dfa->tindex) >= (dfa->talloc)",
"QMARK",
"STAR",
"PLUS",
"CAT",
"OR",
"ORTOP",
"\"default\"",
"EMPTY",
"depth > dfa->depth",
"(tok >= 0 && tok < (1 << 8)) || tok >= CSET || tok == BACKREF || tok == BEGLINE || tok == ENDLINE || tok == BEGWORD || tok == ENDWORD || tok == LIMWORD || tok == NOTLIMWORD",
"tok == LPAREN",
"tok != RPAREN",
"\"default\"",
"QMARK",
"STAR",
"PLUS",
"CAT",
"OR",
"ORTOP",
"i < ntokens",
"tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN",
"tok == REPMN",
"maxrep == 0",
"minrep == 0",
"i < minrep",
"i < maxrep",
"tok != RPAREN && tok != OR && tok >= 0",
"tok == OR",
"toplevel",
"!syntax_bits_set",
"tok != END",
"d->nregexps",
"i < src->nelem",
"i < s->nelem && p.strchr < s->elems[i].strchr",
"i < s->nelem && p.strchr == s->elems[i].strchr",
"i < s->nelem",
"i < s1->nelem && j < s2->nelem",
"s1->elems[i].strchr > s2->elems[j].strchr",
"s1->elems[i].strchr < s2->elems[j].strchr",
"i < s1->nelem",
"j < s2->nelem",
"i < s->nelem",
"p.strchr == s->elems[i].strchr",
"i < s->nelem",
"i < s->nelem",
"newline",
"letter",
"i < s->nelem",
"i < d->sindex",
"hash != d->states[i].hash || s->nelem != d->states[i].elems.nelem || newline != d->states[i].newline || letter != d->states[i].letter",
"j < s->nelem",
"s->elems[j].constraint != d->states[i].elems.elems[j].constraint || s->elems[j].strchr != d->states[i].elems.elems[j].strchr",
"j == s->nelem",
"(d->sindex) >= (d->salloc)",
"(d->sindex) >= (d->salloc)",
"j < s->nelem",
"d->tokens[s->elems[j].strchr] < 0",
"(((constraint) & 1 << (((newline) ? 2 : 0) + ((0) ? 1 : 0) + 4)) && ((constraint) & 1 << (((letter) ? 2 : 0) + ((0) ? 1 : 0)))) || (((constraint) & 1 << (((newline) ? 2 : 0) + ((0) ? 1 : 0) + 4)) && ((constraint) & 1 << (((letter) ? 2 : 0) + ((1) ? 1 : 0)))) || (((constraint) & 1 << (((newline) ? 2 : 0) + ((1) ? 1 : 0) + 4)) && ((constraint) & 1 << (((letter) ? 2 : 0) + ((0) ? 1 : 0)))) || (((constraint) & 1 << (((newline) ? 2 : 0) + ((1) ? 1 : 0) + 4)) && ((constraint) & 1 << (((letter) ? 2 : 0) + ((1) ? 1 : 0))))",
"(newline)",
"(0)",
"(letter)",
"(0)",
"(newline)",
"(0)",
"(letter)",
"(1)",
"(newline)",
"(1)",
"(letter)",
"(0)",
"(newline)",
"(1)",
"(letter)",
"(1)",
"!d->states[i].first_end",
"d->tokens[s->elems[j].strchr] == BACKREF",
"i < d->tindex",
"i < s->nelem",
"d->tokens[s->elems[i].strchr] >= (1 << 8) && d->tokens[s->elems[i].strchr] != BACKREF && d->tokens[s->elems[i].strchr] < CSET",
"visited[old.strchr]",
"BEGLINE",
"ENDLINE",
"BEGWORD",
"ENDWORD",
"LIMWORD",
"NOTLIMWORD",
"\"default\"",
"j < d->follows[old.strchr].nelem",
"i < d->tindex",
"i < d->tindex",
"EMPTY",
"STAR",
"PLUS",
"j < nlastpos[-1]",
"(merged.nelem - 1) >= (nalloc[pos[j].strchr])",
"(merged.nelem - 1) >= (nalloc[pos[j].strchr])",
"QMARK",
"d->tokens[i] != PLUS",
"CAT",
"j < nlastpos[-2]",
"(merged.nelem - 1) >= (nalloc[pos[j].strchr])",
"(merged.nelem - 1) >= (nalloc[pos[j].strchr])",
"nullable[-2]",
"nullable[-1]",
"j >= 0",
"OR",
"ORTOP",
"\"default\"",
"i < d->tindex",
"d->tokens[i] < (1 << 8) || d->tokens[i] == BACKREF || d->tokens[i] >= CSET",
"d->follows[i].nelem < merged.nelem",
"i < nfirstpos[-1]",
"i < merged.nelem",
"(((merged.elems[i].constraint) & 192) >> 2 != ((merged.elems[i].constraint) & 48))",
"!initialized",
"i < (1 << 8)",
"(1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISalnum))",
"i < d->states[s].elems.nelem",
"d->tokens[pos.strchr] >= 0 && d->tokens[pos.strchr] < (1 << 8)",
"d->tokens[pos.strchr] >= CSET",
"pos.constraint != 255",
"!((pos.constraint) & 1 << (((d->states[s].newline) ? 2 : 0) + ((1) ? 1 : 0) + 4))",
"(d->states[s].newline)",
"(1)",
"!((pos.constraint) & 1 << (((d->states[s].newline) ? 2 : 0) + ((0) ? 1 : 0) + 4))",
"(d->states[s].newline)",
"(0)",
"j < (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int)))",
"!((pos.constraint) & 1 << (((d->states[s].letter) ? 2 : 0) + ((1) ? 1 : 0)))",
"(d->states[s].letter)",
"(1)",
"j < (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int)))",
"!((pos.constraint) & 1 << (((d->states[s].letter) ? 2 : 0) + ((0) ? 1 : 0)))",
"(d->states[s].letter)",
"(0)",
"j < (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int)))",
"j < (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int))) && !matches[j]",
"j == (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int)))",
"j < ngrps",
"d->tokens[pos.strchr] >= 0 && d->tokens[pos.strchr] < (1 << 8) && !tstbit(d->tokens[pos.strchr], labels[j])",
"k < (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int)))",
"(intersect[k] = matches[k] & labels[j][k])",
"!intersectf",
"k < (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int)))",
"(leftovers[k] = ~match & label)",
"(matches[k] = match & ~label)",
"leftoversf",
"!matchesf",
"j == ngrps",
"d->searchflag",
"i < d->states[0].elems.nelem",
"(((d->states[0].elems.elems[i].constraint) & 192) >> 2 != ((d->states[0].elems.elems[i].constraint) & 48))",
"(((d->states[0].elems.elems[i].constraint) & 12) >> 2 != ((d->states[0].elems.elems[i].constraint) & 3))",
"wants_newline",
"wants_letter",
"i < (1 << 8)",
"i == '\\n'",
"(1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISalnum))",
"i < (1 << 8)",
"i < ngrps",
"j < grps[i].nelem",
"k < d->follows[grps[i].elems[j].strchr].nelem",
"d->searchflag",
"j < d->states[0].elems.nelem",
"tstbit('\\n', labels[i])",
"j < follows.nelem",
"(((follows.elems[j].constraint) & 192) >> 2 != ((follows.elems[j].constraint) & 48))",
"j < (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int)))",
"labels[i][j] & letters[j]",
"j < (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int)))",
"j < follows.nelem",
"(((follows.elems[j].constraint) & 12) >> 2 != ((follows.elems[j].constraint) & 3))",
"wants_newline",
"wants_letter",
"j < (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int)))",
"k < (8 * sizeof(int))",
"labels[i][j] & 1 << k",
"c == '\\n'",
"(1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalnum))",
"c < (1 << 8)",
"i < ngrps",
"d->trcount >= 1024",
"i < d->tralloc",
"d->trans[i]",
"d->fails[i]",
"((((*d).states[s].constraint) & 1 << (((d->states[s].newline) ? 2 : 0) + ((1) ? 1 : 0) + 4)) && (((*d).states[s].constraint) & 1 << (((d->states[s].letter) ? 2 : 0) + ((0) ? 1 : 0))))",
"(d->states[s].newline)",
"(1)",
"(d->states[s].letter)",
"(0)",
"((((*d).states[s].constraint) & 1 << (((d->states[s].newline) ? 2 : 0) + ((0) ? 1 : 0) + 4)) && (((*d).states[s].constraint) & 1 << (((d->states[s].letter) ? 2 : 0) + ((1) ? 1 : 0))))",
"(d->states[s].newline)",
"(0)",
"(d->states[s].letter)",
"(1)",
"((((*d).states[s].constraint) & 1 << (((d->states[s].newline) ? 2 : 0) + ((0) ? 1 : 0) + 4)) && (((*d).states[s].constraint) & 1 << (((d->states[s].letter) ? 2 : 0) + ((0) ? 1 : 0))))",
"(d->states[s].newline)",
"(0)",
"(d->states[s].letter)",
"(0)",
"i < (1 << 8)",
"trans[i] >= d->tralloc",
"trans[i] >= d->tralloc",
"oldalloc < d->tralloc",
"((*d).states[s].constraint)",
"!sbit_init",
"i < (1 << 8)",
"i == '\\n'",
"(1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISalnum))",
"!d->tralloc",
"",
"(t = trans[s]) != 0",
"(t = trans[s]) != 0",
"!(t = trans[s1])",
"s >= 0 && p <= (unsigned char *)end && d->fails[s]",
"d->success[s] & sbit[*p]",
"backref",
"d->states[s].backref",
"count && (char *)p <= end && p[-1] == '\\n'",
"(char *)p > end",
"s >= 0",
"p[-1] == '\\n' && newline",
"case_fold",
"!copy",
"i < len",
"(1 && ((*__ctype_b_loc())[(int)((s[i]))] & (unsigned short)_ISupper))",
"i < d->sindex",
"i < d->tindex",
"d->follows[i].elems",
"i < d->tralloc",
"d->trans[i]",
"d->fails[i]",
"dm",
"(new == ((void *)0))",
"old == ((void *)0)",
"newsize == 0",
"old == ((void *)0)",
"result != ((void *)0) && new != ((void *)0)",
"*cp != '\\x00'",
"strncmp(cp, lookfor, len) == 0",
"cp != ((void *)0)",
"cpp == ((void *)0)",
"cpp[i] != ((void *)0)",
"cpp == ((void *)0)",
"(new = icpyalloc(new)) == ((void *)0)",
"cpp[i] != ((void *)0)",
"istrstr(cpp[i], new) != ((void *)0)",
"cpp[j] != ((void *)0)",
"istrstr(new, cpp[j]) == ((void *)0)",
"--i == j",
"cpp == ((void *)0)",
"left == ((void *)0) || right == ((void *)0)",
"cpp == ((void *)0)",
"*lcp != '\\x00'",
"rcp != ((void *)0)",
"lcp[i] != '\\x00' && lcp[i] == rcp[i]",
"i > len",
"len == 0",
"(cpp = enlist(cpp, lcp, len)) == ((void *)0)",
"old == ((void *)0) || new == ((void *)0)",
"new[i] != ((void *)0)",
"old == ((void *)0)",
"left == ((void *)0) || right == ((void *)0)",
"both == ((void *)0)",
"left[lnum] != ((void *)0)",
"right[rnum] != ((void *)0)",
"temp == ((void *)0)",
"both == ((void *)0)",
"musts == ((void *)0)",
"i <= dfa->tindex",
"i <= dfa->tindex",
"mp[i].in == ((void *)0) || mp[i].left == ((void *)0) || mp[i].right == ((void *)0) || mp[i].is == ((void *)0)",
"ri < dfa->tindex",
"LPAREN",
"RPAREN",
"EMPTY",
"BEGLINE",
"ENDLINE",
"BEGWORD",
"ENDWORD",
"LIMWORD",
"NOTLIMWORD",
"BACKREF",
"STAR",
"QMARK",
"mp <= musts",
"OR",
"ORTOP",
"mp < &musts[2]",
"strcmp(lmp->is, rmp->is) != 0",
"lmp->left[i] != '\\x00' && lmp->left[i] == rmp->left[i]",
"n > rn",
"i < n",
"lmp->right[ln - i - 1] != rmp->right[rn - i - 1]",
"j < i",
"new == ((void *)0)",
"PLUS",
"mp <= musts",
"END",
"mp != &musts[1]",
"musts[0].in[i] != ((void *)0)",
"strlen(musts[0].in[i]) > strlen(result)",
"strcmp(result, musts[0].is) == 0",
"CAT",
"mp < &musts[2]",
"lmp->in == ((void *)0)",
"lmp->right[0] != '\\x00' && rmp->left[0] != '\\x00'",
"tp == ((void *)0)",
"tp == ((void *)0)",
"lmp->in == ((void *)0)",
"lmp->is[0] != '\\x00'",
"lmp->left == ((void *)0)",
"rmp->is[0] == '\\x00'",
"lmp->right == ((void *)0)",
"lmp->is[0] != '\\x00' && rmp->is[0] != '\\x00'",
"lmp->is == ((void *)0)",
"\"default\"",
"t < END",
"t == '\\x00'",
"t >= CSET",
"mp->in == ((void *)0)",
"strlen(result)",
"i <= dfa->tindex",
"!kwset",
"(((&kwset->obstack))->chunk_limit - ((&kwset->obstack))->next_free < ((&kwset->obstack))->temp)",
"((&kwset->obstack))->next_free == ((&kwset->obstack))->object_base",
"(((&kwset->obstack))->next_free - (char *)((&kwset->obstack))->chunk > ((&kwset->obstack))->chunk_limit - (char *)((&kwset->obstack))->chunk)",
"!kwset->trie",
"len--",
"kwset->trans",
"link && label != link->label",
"label < link->label",
"!link",
"(((&kwset->obstack))->chunk_limit - ((&kwset->obstack))->next_free < ((&kwset->obstack))->temp)",
"((&kwset->obstack))->next_free == ((&kwset->obstack))->object_base",
"(((&kwset->obstack))->next_free - (char *)((&kwset->obstack))->chunk > ((&kwset->obstack))->chunk_limit - (char *)((&kwset->obstack))->chunk)",
"!link",
"(((&kwset->obstack))->chunk_limit - ((&kwset->obstack))->next_free < ((&kwset->obstack))->temp)",
"((&kwset->obstack))->next_free == ((&kwset->obstack))->object_base",
"(((&kwset->obstack))->next_free - (char *)((&kwset->obstack))->chunk > ((&kwset->obstack))->chunk_limit - (char *)((&kwset->obstack))->chunk)",
"!link->trie",
"dirs[--depth] == L",
"depth && !links[depth]->balance",
"dirs[depth] == L",
"depth && ((dirs[depth] == L && --links[depth]->balance) || (dirs[depth] == R && ++links[depth]->balance))",
"\"default\"",
"(char)-2",
"\"default\"",
"L",
"R",
"t->balance != 1",
"t->balance != (char)-1",
"2",
"\"default\"",
"R",
"L",
"t->balance != 1",
"t->balance != (char)-1",
"dirs[depth - 1] == L",
"!trie->accepting",
"trie->depth < kwset->mind",
"trie->depth > kwset->maxd",
"!tree",
"!tree",
"fail",
"link && tree->label != link->label",
"tree->label < link->label",
"link",
"!tree",
"depth < delta[tree->label]",
"!b",
"!hasevery(a, b->llink)",
"!hasevery(a, b->rlink)",
"a && b->label != a->label",
"b->label < a->label",
"!tree",
"kwset->mind < 256",
"i < ((127 * 2U + 1U) + 1)",
"i < ((127 * 2U + 1U) + 1)",
"kwset->words == 1 && kwset->trans == 0",
"(((&kwset->obstack))->chunk_limit - ((&kwset->obstack))->next_free < ((&kwset->obstack))->temp)",
"((&kwset->obstack))->next_free == ((&kwset->obstack))->object_base",
"(((&kwset->obstack))->next_free - (char *)((&kwset->obstack))->chunk > ((&kwset->obstack))->chunk_limit - (char *)((&kwset->obstack))->chunk)",
"i >= 0",
"i < kwset->mind",
"i < kwset->mind - 1",
"kwset->target[i] == kwset->target[kwset->mind - 1]",
"curr",
"fail",
"!hasevery(fail->links, curr->links)",
"curr->depth - fail->depth < fail->shift",
"curr->accepting && fail->maxshift > curr->depth - fail->depth",
"curr",
"curr->maxshift > curr->parent->maxshift",
"curr->shift > curr->maxshift",
"i < ((127 * 2U + 1U) + 1)",
"(trans = kwset->trans) != 0",
"i < ((127 * 2U + 1U) + 1)",
"i < ((127 * 2U + 1U) + 1)",
"(trans = kwset->trans) != 0",
"i < ((127 * 2U + 1U) + 1)",
"i < ((127 * 2U + 1U) + 1)",
"len == 0",
"len > size",
"len == 1",
"size > 12 * len",
"",
"tp <= ep",
"d == 0",
"d == 0",
"d == 0",
"((unsigned char)(tp[-2])) == gc",
"i <= len && ((unsigned char)(tp[-i])) == ((unsigned char)(sp[-i]))",
"i > len",
"d <= ep - tp",
"d != 0",
"tp[-2] == gc",
"i <= len && ((unsigned char)(tp[-i])) == ((unsigned char)(sp[-i]))",
"i > len",
"len < kwset->mind",
"(d = kwset->mind) != 0",
"len >= 4 * kwset->mind",
"lim - end >= d",
"qlim && end <= qlim",
"(d = delta[c = *end]) && end < qlim",
"d",
"trie->accepting",
"beg > text",
"trans",
"tree && c != tree->label",
"c < tree->label",
"tree",
"trie->accepting",
"mch",
"lim - mch > kwset->maxd",
"lim - end >= d",
"(d = delta[c = (end += d)[-1]]) != 0",
"!(trie = next[c])",
"trie->accepting && beg <= mch",
"beg > text",
"trans",
"tree && c != tree->label",
"c < tree->label",
"tree",
"trie->accepting && beg <= mch",
"lmch",
"!d",
"kwsmatch",
"kwset->words == 1 && kwset->trans == 0",
"kwsmatch != 0 && ret != 0",
"((&kwset->obstack)->temp > 0 && (&kwset->obstack)->temp < (&kwset->obstack)->chunk_limit - (char *)(&kwset->obstack)->chunk)",
"match_icase",
"i < ((127 * 2U + 1U) + 1)",
"(1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper))",
"!(kwset = kwsalloc(match_icase ? trans : (char *)0))",
"match_icase",
"dfa_1.musts",
"dm",
"!dm->exact",
"(err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0",
"dm",
"dm->exact",
"(err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0",
"(err = kwsprep(kwset)) != 0",
"(err = re_compile_pattern(pattern, size, &regex)) != 0",
"match_words || match_lines",
"match_lines",
"match_words",
"match_words",
"match_lines",
"strcmp(matcher, \"posix-egrep\") == 0",
"(err = re_compile_pattern(pattern, size, &regex)) != 0",
"match_words || match_lines",
"match_lines",
"match_words",
"match_words",
"match_lines",
"end < buflim",
"kwset",
"!beg",
"!end",
"beg > buf && beg[-1] != '\\n'",
"kwsm.strchr < lastexact",
"!dfaexec(&dfa_1, beg, end, 0, (int *)0, &backref)",
"!backref",
"!beg",
"!end",
"beg > buf && beg[-1] != '\\n'",
"!backref",
"(start = re_search(&regex, beg, end - beg, 0, end - beg, &regs)) >= 0",
"!match_lines && !match_words || match_lines && len == end - beg",
"match_words",
"start >= 0",
"(start == 0 || !((1 && ((*__ctype_b_loc())[(int)((beg[start - 1]))] & (unsigned short)_ISalnum)) || (beg[start - 1]) == '_')) && (len == end - beg || !((1 && ((*__ctype_b_loc())[(int)((beg[start + len]))] & (unsigned short)_ISalnum)) || (beg[start + len]) == '_'))",
"len > 0",
"len <= 0",
"start == end - beg",
"end < buflim",
"beg < pattern + size",
"lim < pattern + size && *lim != '\\n'",
"(err = kwsincr(kwset, beg, lim - beg)) != 0",
"lim < pattern + size",
"(err = kwsprep(kwset)) != 0",
"beg <= buf + size",
"!(beg = kwsexec(kwset, beg, buf + size - beg, &kwsmatch))",
"match_lines",
"beg > buf && beg[-1] != '\\n'",
"beg + len < buf + size && beg[len] != '\\n'",
"match_words",
"len && try",
"try > buf && ((1 && ((*__ctype_b_loc())[(int)(((unsigned char)try[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)try[-1]) == '_')",
"try + len < buf + size && ((1 && ((*__ctype_b_loc())[(int)(((unsigned char)try[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)try[len]) == '_')",
"(end = memchr(beg + len, '\\n', (buf + size) - (beg + len))) != 0",
"beg > buf && beg[-1] != '\\n'",
};
static void kcov_init() {
 FILE *f;
 char *buf;
 unsigned int bid = 0;
 unsigned int line, then, els;
 if (f = fopen("grep_pre-cov-measure.txt", "r")) {
  buf = malloc(1024);
  fgets(buf, 1024, f);
  fgets(buf, 1024, f);
  while (fgets(buf, 1024, f)) {
   if (*buf < 0x30 || *buf > 0x39) {
    break;
   }
   sscanf(buf, "%u %u %u", &line, &then, &els);
   kcov_counts[bid] = then + els;
   kcov_thens[bid] = then;
   bid++;
  }
  fclose(f);
  free(buf);
 }
}
static void kcov_save() {
 FILE *f;
 if (f = fopen("grep_pre-cov-measure.txt", "w")) {
  unsigned int i;
  unsigned int taken_branches = 0;
  fputs("Line#\t| # of execution\t| # of execution\t| conditional\n", f);
  fputs("\t| of then branch\t| of else branch\t| expression\n", f);
  for (i = 0; i < KCOV_BIDS; i++) {
   fprintf(f,
    "%u\t  %u\t\t\t  %u\t\t\t  %s\n",
    kcov_lines[i], kcov_thens[i],
    kcov_counts[i] - kcov_thens[i], kcov_exprs[i]);
   if (kcov_thens[i] > 0) {
    taken_branches++;
   }
   if (kcov_counts[i] - kcov_thens[i] > 0) {
    taken_branches++;
   }
  }
  fprintf(f,
   "Covered: %u / Total: %u = %f%%\n",
   taken_branches, kcov_branches,
   100.0 * taken_branches / kcov_branches);
  fclose(f);
 }
}
static int kcov_count(int bid) {
 kcov_counts[bid]++;
 return 0;
}
static int kcov_then(int bid) {
 kcov_thens[bid]++;
 return 1;
}
static void
error(mesg, errnum)

     const

     char *mesg;
     int errnum;
{
  if (kcov_count(0) || (errnum) && kcov_then(0))
    fprintf(stdout, "%s: %s: %s\n", prog, mesg, strerror(errnum));
  else
    fprintf(stdout, "%s: %s\n", prog, mesg);
  errseen = 1;
}


void
fatal(mesg, errnum)

     const

     char *mesg;
     int errnum;
{
  error(mesg, errnum);
  exit(2);
}


char *
xmalloc(size)
     size_t size;
{
  char *result;

  result = malloc(size);
  if (kcov_count(1) || (size && !result) && kcov_then(1))
    fatal("memory exhausted", 0);
  return result;
}


char *
xrealloc(ptr, size)
     char *ptr;
     size_t size;
{
  char *result;

  if (kcov_count(2) || (ptr) && kcov_then(2))
    result = realloc(ptr, size);
  else
    result = malloc(size);
  if (kcov_count(3) || (size && !result) && kcov_then(3))
    fatal("memory exhausted", 0);
  return result;
}





extern void *valloc(size_t);
# 211 "grep.c"
static char *buffer;
static size_t bufsalloc;
static size_t bufalloc;
static int bufdesc;
static char *bufbeg;
static char *buflim;






# 1 "/usr/include/sys/stat.h" 1 3 4
# 39 "/usr/include/sys/stat.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 40 "/usr/include/sys/stat.h" 2 3 4
# 105 "/usr/include/sys/stat.h" 3 4


# 1 "/usr/include/bits/stat.h" 1 3 4
# 43 "/usr/include/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;

    unsigned short int __pad1;


    __ino_t st_ino;




    __mode_t st_mode;
    __nlink_t st_nlink;




    __uid_t st_uid;
    __gid_t st_gid;



    __dev_t st_rdev;

    unsigned short int __pad2;


    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 88 "/usr/include/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 106 "/usr/include/bits/stat.h" 3 4
    unsigned long int __unused4;
    unsigned long int __unused5;




  };
# 108 "/usr/include/sys/stat.h" 2 3 4
# 211 "/usr/include/sys/stat.h" 3 4
extern int stat (const char * __file,
   struct stat * __buf) ;



extern int fstat (int __fd, struct stat *__buf) ;
# 240 "/usr/include/sys/stat.h" 3 4
extern int fstatat (int __fd, const char * __file,
      struct stat * __buf, int __flag)
     ;
# 265 "/usr/include/sys/stat.h" 3 4
extern int lstat (const char * __file,
    struct stat * __buf) ;
# 286 "/usr/include/sys/stat.h" 3 4
extern int chmod (const char *__file, __mode_t __mode)
     ;





extern int lchmod (const char *__file, __mode_t __mode)
     ;




extern int fchmod (int __fd, __mode_t __mode) ;





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     ;






extern __mode_t umask (__mode_t __mask) ;
# 323 "/usr/include/sys/stat.h" 3 4
extern int mkdir (const char *__path, __mode_t __mode)
     ;





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     ;






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     ;





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) ;





extern int mkfifo (const char *__path, __mode_t __mode)
     ;





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     ;





extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     ;




extern int futimens (int __fd, const struct timespec __times[2]) ;
# 401 "/usr/include/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     ;
extern int __xstat (int __ver, const char *__filename,
      struct stat *__stat_buf) ;
extern int __lxstat (int __ver, const char *__filename,
       struct stat *__stat_buf) ;
extern int __fxstatat (int __ver, int __fildes, const char *__filename,
         struct stat *__stat_buf, int __flag)
     ;
# 444 "/usr/include/sys/stat.h" 3 4
extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) ;

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     ;
# 536 "/usr/include/sys/stat.h" 3 4

# 224 "grep.c" 2
# 1 "/usr/include/sys/mman.h" 1 3 4
# 26 "/usr/include/sys/mman.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 27 "/usr/include/sys/mman.h" 2 3 4
# 42 "/usr/include/sys/mman.h" 3 4
# 1 "/usr/include/bits/mman.h" 1 3 4
# 43 "/usr/include/sys/mman.h" 2 3 4





# 58 "/usr/include/sys/mman.h" 3 4
extern void *mmap (void *__addr, size_t __len, int __prot,
     int __flags, int __fd, __off_t __offset) ;
# 77 "/usr/include/sys/mman.h" 3 4
extern int munmap (void *__addr, size_t __len) ;




extern int mprotect (void *__addr, size_t __len, int __prot) ;







extern int msync (void *__addr, size_t __len, int __flags);




extern int madvise (void *__addr, size_t __len, int __advice) ;



extern int posix_madvise (void *__addr, size_t __len, int __advice) ;




extern int mlock (const void *__addr, size_t __len) ;


extern int munlock (const void *__addr, size_t __len) ;




extern int mlockall (int __flags) ;



extern int munlockall (void) ;







extern int mincore (void *__start, size_t __len, unsigned char *__vec)
     ;
# 145 "/usr/include/sys/mman.h" 3 4
extern int shm_open (const char *__name, int __oflag, mode_t __mode);


extern int shm_unlink (const char *__name);


# 225 "grep.c" 2

static int bufmapped;
static struct stat bufstat;
static off_t bufoffset;




void
reset(fd)
     int fd;
{
  static int initialized;

  if (kcov_count(4) || (!initialized) && kcov_then(4))
    {
      initialized = 1;

      bufsalloc = (kcov_count(5) || ((8192) > (getpagesize())) && kcov_then(5) ? (8192) : (getpagesize()));



      bufalloc = 5 * bufsalloc;



      buffer = valloc(bufalloc + 1);
      if (kcov_count(6) || (!buffer) && kcov_then(6))
 fatal("memory exhausted", 0);
      bufbeg = buffer;
      buflim = buffer;
    }
  bufdesc = fd;

  if (kcov_count(7) || (fstat(fd, &bufstat) < 0 || !((((bufstat.st_mode)) & 0170000) == (0100000))) && kcov_then(7))
    bufmapped = 0;
  else
    {
      bufmapped = 1;
      bufoffset = lseek(fd, 0, 1);
    }

}





static int
fillbuf(save)
     size_t save;
{
  char *nbuffer, *dp, *sp;
  int cc;

  caddr_t maddr;

  static int pagesize;

  if (kcov_count(8) || (pagesize == 0 && (pagesize = getpagesize()) == 0) && kcov_then(8))
    abort();

  if (kcov_count(9) || (save > bufsalloc) && kcov_then(9))
    {
      while (kcov_count(10) || (save > bufsalloc) && kcov_then(10))
 bufsalloc *= 2;
      bufalloc = 5 * bufsalloc;
      nbuffer = valloc(bufalloc + 1);
      if (kcov_count(11) || (!nbuffer) && kcov_then(11))
 fatal("memory exhausted", 0);
    }
  else
    nbuffer = buffer;

  sp = buflim - save;
  dp = nbuffer + bufsalloc - save;
  bufbeg = dp;
  while (kcov_count(12) || (save--) && kcov_then(12))
    *dp++ = *sp++;




  buffer = nbuffer;


  if (kcov_count(13) || (bufmapped && bufoffset % pagesize == 0
      && bufstat.st_size - bufoffset >= bufalloc - bufsalloc) && kcov_then(13))
    {
      maddr = buffer + bufsalloc;
      maddr = mmap(maddr, bufalloc - bufsalloc, 0x1 | 0x2,
     0x02 | 0x10, bufdesc, bufoffset);
      if (kcov_count(14) || (maddr == (caddr_t) -1) && kcov_then(14))
 {
   fprintf(stdout, "%s: warning: %s: %s\n", filename,
    strerror((*__errno_location ())));
   goto tryread;
 }






      cc = bufalloc - bufsalloc;
      bufoffset += cc;
    }
  else
    {
    tryread:



      if (kcov_count(15) || (bufmapped) && kcov_then(15))
 {
   bufmapped = 0;
   lseek(bufdesc, bufoffset, 0);
 }
      cc = read(bufdesc, buffer + bufsalloc, bufalloc - bufsalloc);
    }



  if (kcov_count(16) || (cc > 0) && kcov_then(16))
    buflim = buffer + bufsalloc + cc;
  else
    buflim = buffer + bufsalloc;
  return cc;
}


static int out_quiet;
static int out_invert;
static int out_file;
static int out_line;
static int out_byte;
static int out_before;
static int out_after;


static size_t totalcc;
static char *lastnl;
static char *lastout;


static size_t totalnl;
static int pending;

static void
nlscan(lim)
     char *lim;
{
  char *beg;

  for (beg = lastnl; kcov_count(17) || (beg < lim) && kcov_then(17); ++beg)
    if (kcov_count(18) || (*beg == '\n') && kcov_then(18))
      ++totalnl;
  lastnl = beg;
}

static void
prline(beg, lim, sep)
     char *beg;
     char *lim;
     char sep;
{
  if (kcov_count(19) || (out_file) && kcov_then(19))
    printf("%s%c", filename, sep);
  if (kcov_count(20) || (out_line) && kcov_then(20))
    {
      nlscan(beg);
      printf("%d%c", ++totalnl, sep);
      lastnl = lim;
    }
  if (kcov_count(21) || (out_byte) && kcov_then(21))
    printf("%lu%c", totalcc + (beg - bufbeg), sep);
  fwrite(beg, 1, lim - beg, stdout);
  if (kcov_count(22) || (ferror(stdout)) && kcov_then(22))
    error("writing output", (*__errno_location ()));
  lastout = lim;
}


static void
prpending(lim)
     char *lim;
{
  char *nl;

  if (kcov_count(23) || (!lastout) && kcov_then(23))
    lastout = bufbeg;
  while (kcov_count(24) || (pending > 0 && lastout < lim) && kcov_then(24))
    {
      --pending;
      if (kcov_count(25) || ((nl = memchr(lastout, '\n', lim - lastout)) != 0) && kcov_then(25))
 ++nl;
      else
 nl = lim;
      prline(lastout, nl, '-');
    }
}



static void
prtext(beg, lim, nlinesp)
     char *beg;
     char *lim;
     int *nlinesp;
{
  static int used;
  char *bp, *p, *nl;
  int i, n;

  if (kcov_count(26) || (!out_quiet && pending > 0) && kcov_then(26))
    prpending(beg);

  p = beg;

  if (kcov_count(27) || (!out_quiet) && kcov_then(27))
    {


      bp = kcov_count(28) || (lastout) && kcov_then(28) ? lastout : bufbeg;
      for (i = 0; kcov_count(29) || (i < out_before) && kcov_then(29); ++i)
 if (kcov_count(30) || (p > bp) && kcov_then(30))
   do
     --p;
   while (kcov_count(31) || (p > bp && p[-1] != '\n') && kcov_then(31));



      if (kcov_count(32) || ((out_before || out_after) && used && p != lastout) && kcov_then(32))
 puts("--");

      while (kcov_count(33) || (p < beg) && kcov_then(33))
 {
   nl = memchr(p, '\n', beg - p);
   prline(p, nl + 1, '-');
   p = nl + 1;
 }
    }

  if (kcov_count(34) || (nlinesp) && kcov_then(34))
    {

      for (n = 0; kcov_count(35) || (p < lim) && kcov_then(35); ++n)
 {
   if (kcov_count(36) || ((nl = memchr(p, '\n', lim - p)) != 0) && kcov_then(36))
     ++nl;
   else
     nl = lim;
   if (kcov_count(37) || (!out_quiet) && kcov_then(37))
     prline(p, nl, ':');
   p = nl;
 }
      *nlinesp = n;
    }
  else
    if (kcov_count(38) || (!out_quiet) && kcov_then(38))
      prline(beg, lim, ':');

  pending = out_after;
  used = 1;
}




static int
grepbuf(beg, lim)
     char *beg;
     char *lim;
{
  int nlines, n;
  register char *p, *b;
  char *endp;

  nlines = 0;
  p = beg;
  while (kcov_count(39) || ((b = (*execute)(p, lim - p, &endp)) != 0) && kcov_then(39))
    {

      if (kcov_count(40) || (b == lim && ((b > beg && b[-1] == '\n') || b == beg)) && kcov_then(40))
 break;
      if (kcov_count(41) || (!out_invert) && kcov_then(41))
 {
   prtext(b, endp, (int *) 0);
   nlines += 1;
 }
      else if (kcov_count(42) || (p < b) && kcov_then(42))
 {
   prtext(p, b, &n);
   nlines += n;
 }
      p = endp;
    }
  if (kcov_count(43) || (out_invert && p < lim) && kcov_then(43))
    {
      prtext(p, lim, &n);
      nlines += n;
    }
  return nlines;
}


static int
grep(fd)
     int fd;
{
  int nlines, i;
  size_t residue, save;
  char *beg, *lim;

  reset(fd);

  totalcc = 0;
  lastout = 0;
  totalnl = 0;
  pending = 0;

  nlines = 0;
  residue = 0;
  save = 0;

  for (;kcov_count(44) || kcov_then(44);)
    {
      if (kcov_count(45) || (fillbuf(save) < 0) && kcov_then(45))
 {
   error(filename, (*__errno_location ()));
   return nlines;
 }
      lastnl = bufbeg;
      if (kcov_count(46) || (lastout) && kcov_then(46))
 lastout = bufbeg;
      if (kcov_count(47) || (buflim - bufbeg == save) && kcov_then(47))
 break;
      beg = bufbeg + save - residue;
      for (lim = buflim; kcov_count(48) || (lim > beg && lim[-1] != '\n') && kcov_then(48); --lim)
 ;
      residue = buflim - lim;
      if (kcov_count(49) || (beg < lim) && kcov_then(49))
 {
   nlines += grepbuf(beg, lim);
   if (kcov_count(50) || (pending) && kcov_then(50))
     prpending(lim);
 }
      i = 0;
      beg = lim;
      while (kcov_count(51) || (i < out_before && beg > bufbeg && beg != lastout) && kcov_then(51))
 {
   ++i;
   do
     --beg;
   while (kcov_count(52) || (beg > bufbeg && beg[-1] != '\n') && kcov_then(52));
 }
      if (kcov_count(53) || (beg != lastout) && kcov_then(53))
 lastout = 0;
      save = residue + lim - beg;
      totalcc += buflim - bufbeg - save;
      if (kcov_count(54) || (out_line) && kcov_then(54))
 nlscan(beg);
    }
  if (kcov_count(55) || (residue) && kcov_then(55))
    {
      nlines += grepbuf(bufbeg + save - residue, buflim);
      if (kcov_count(56) || (pending) && kcov_then(56))
 prpending(buflim);
    }
  return nlines;
}

static char version[] = "GNU grep version 2.0";




static void
usage()
{
  fprintf(stdout, "usage: %s [-[[AB] ]<num>] [-[CEFGVchilnqsvwx]] [-[ef]] <expr> [<files...>]\n", prog);
  exit(2);
}



int
setmatcher(name)
     char *name;
{
  int i;

  for (i = 0; kcov_count(57) || (matchers[i].name) && kcov_then(57); ++i)
    if (kcov_count(58) || (strcmp(name, matchers[i].name) == 0) && kcov_then(58))
      {
 compile = matchers[i].compile;
 execute = matchers[i].execute;
 return 1;
      }
  return 0;
}

int
main(argc, argv)
     int argc;
     char *argv[];
{
  kcov_init();
atexit(kcov_save);
char *keys;
  size_t keycc, oldcc, keyalloc;
  int keyfound, count_matches, no_filenames, list_files, suppress_errors;
  int opt, cc, desc, count, status;
  FILE *fp;
  extern char *optarg;
  extern int optind;

  argv[0] = "target";

  prog = argv[0];
  if (kcov_count(59) || (prog && strrchr(prog, '/')) && kcov_then(59))
    prog = strrchr(prog, '/') + 1;

  keys = ((void *)0);
  keycc = 0;
  keyfound = 0;
  count_matches = 0;
  no_filenames = 0;
  list_files = 0;
  suppress_errors = 0;
  matcher = ((void *)0);

  while (kcov_count(60) || ((opt = getopt(argc, argv, "0123456789A:B:CEFGVX:bce:f:hiLlnqsvwxy"))
  != (-1)) && kcov_then(60))
    switch (opt)
      {
      case '0':kcov_count(61);
kcov_then(61);

      case '1':kcov_count(62);
kcov_then(62);

      case '2':kcov_count(63);
kcov_then(63);

      case '3':kcov_count(64);
kcov_then(64);

      case '4':kcov_count(65);
kcov_then(65);

      case '5':kcov_count(66);
kcov_then(66);

      case '6':kcov_count(67);
kcov_then(67);

      case '7':kcov_count(68);
kcov_then(68);

      case '8':kcov_count(69);
kcov_then(69);

      case '9':kcov_count(70);
kcov_then(70);

 out_before = 10 * out_before + opt - '0';
 out_after = 10 * out_after + opt - '0';
 break;
      case 'A':kcov_count(71);
kcov_then(71);

 out_after = atoi(optarg);
 if (kcov_count(72) || (out_after < 0) && kcov_then(72))
   usage();
 break;
      case 'B':kcov_count(73);
kcov_then(73);

 out_before = atoi(optarg);
 if (kcov_count(74) || (out_before < 0) && kcov_then(74))
   usage();
 break;
      case 'C':kcov_count(75);
kcov_then(75);

 out_before = out_after = 2;
 break;
      case 'E':kcov_count(76);
kcov_then(76);

 if (kcov_count(77) || (matcher && strcmp(matcher, "egrep") != 0) && kcov_then(77))
   fatal("you may specify only one of -E, -F, or -G", 0);
 matcher = "posix-egrep";
 break;
      case 'F':kcov_count(78);
kcov_then(78);

 if (kcov_count(79) || (matcher && strcmp(matcher, "fgrep") != 0) && kcov_then(79))
   fatal("you may specify only one of -E, -F, or -G", 0);;
 matcher = "fgrep";
 break;
      case 'G':kcov_count(80);
kcov_then(80);

 if (kcov_count(81) || (matcher && strcmp(matcher, "grep") != 0) && kcov_then(81))
   fatal("you may specify only one of -E, -F, or -G", 0);
 matcher = "grep";
 break;
      case 'V':kcov_count(82);
kcov_then(82);

 fprintf(stdout, "%s\n", version);
 break;
      case 'X':kcov_count(83);
kcov_then(83);

 if (kcov_count(84) || (matcher) && kcov_then(84))
   fatal("matcher already specified", 0);
 matcher = optarg;
 break;
      case 'b':kcov_count(85);
kcov_then(85);

 out_byte = 1;
 break;
      case 'c':kcov_count(86);
kcov_then(86);

 out_quiet = 1;
 count_matches = 1;
 break;
      case 'e':kcov_count(87);
kcov_then(87);

 cc = strlen(optarg);
 keys = xrealloc(keys, keycc + cc + 1);
 if (kcov_count(88) || (keyfound) && kcov_then(88))
   keys[keycc++] = '\n';
 strcpy(&keys[keycc], optarg);
 keycc += cc;
 keyfound = 1;
 break;
      case 'f':kcov_count(89);
kcov_then(89);

 fp = kcov_count(90) || (strcmp(optarg, "-") != 0) && kcov_then(90) ? fopen(optarg, "r") : stdin;
 if (kcov_count(91) || (!fp) && kcov_then(91))
   fatal(optarg, (*__errno_location ()));
 for (keyalloc = 1; kcov_count(92) || (keyalloc <= keycc) && kcov_then(92); keyalloc *= 2)
   ;
 keys = xrealloc(keys, keyalloc);
 oldcc = keycc;
 if (kcov_count(93) || (keyfound) && kcov_then(93))
   keys[keycc++] = '\n';
 while (kcov_count(94) || (!feof(fp)
        && (cc = fread(keys + keycc, 1, keyalloc - keycc, fp)) > 0) && kcov_then(94))
   {
     keycc += cc;
     if (kcov_count(95) || (keycc == keyalloc) && kcov_then(95))
       keys = xrealloc(keys, keyalloc *= 2);
   }
 if (kcov_count(96) || (fp != stdin) && kcov_then(96))
   fclose(fp);

 if (kcov_count(97) || (keycc - oldcc > 0 && keys[keycc - 1] == '\n') && kcov_then(97))
   --keycc;
 keyfound = 1;
 break;
      case 'h':kcov_count(98);
kcov_then(98);

 no_filenames = 1;
 break;
      case 'i':kcov_count(99);
kcov_then(99);

      case 'y':kcov_count(100);
kcov_then(100);

 match_icase = 1;
 break;
      case 'L':kcov_count(101);
kcov_then(101);



 out_quiet = 1;
 list_files = -1;
 break;
      case 'l':kcov_count(102);
kcov_then(102);

 out_quiet = 1;
 list_files = 1;
 break;
      case 'n':kcov_count(103);
kcov_then(103);

 out_line = 1;
 break;
      case 'q':kcov_count(104);
kcov_then(104);

 out_quiet = 1;
 break;
      case 's':kcov_count(105);
kcov_then(105);

 suppress_errors = 1;
 break;
      case 'v':kcov_count(106);
kcov_then(106);

 out_invert = 1;
 break;
      case 'w':kcov_count(107);
kcov_then(107);

 match_words = 1;
 break;
      case 'x':kcov_count(108);
kcov_then(108);

 match_lines = 1;
 break;
      default:kcov_count(109);
kcov_then(109);

 usage();
 break;
      }

  if (kcov_count(110) || (!keyfound) && kcov_then(110))
    if (kcov_count(111) || (optind < argc) && kcov_then(111))
      {
 keys = argv[optind++];
 keycc = strlen(keys);
      }
    else
      usage();

  if (kcov_count(112) || (!matcher) && kcov_then(112))
    matcher = prog;

  if (kcov_count(113) || (!setmatcher(matcher) && !setmatcher("default")) && kcov_then(113))
    abort();

  (*compile)(keys, keycc);

  if (kcov_count(114) || (argc - optind > 1 && !no_filenames) && kcov_then(114))
    out_file = 1;

  status = 1;

  if (kcov_count(115) || (optind < argc) && kcov_then(115))
    while (kcov_count(116) || (optind < argc) && kcov_then(116))
      {
 desc = kcov_count(117) || (strcmp(argv[optind], "-")) && kcov_then(117) ? open(argv[optind], 00) : 0;
 if (kcov_count(118) || (desc < 0) && kcov_then(118))
   {
     if (kcov_count(119) || (!suppress_errors) && kcov_then(119))
       error(argv[optind], (*__errno_location ()));
   }
 else
   {
     filename = kcov_count(120) || (desc == 0) && kcov_then(120) ? "(standard input)" : argv[optind];
     count = grep(desc);
     if (kcov_count(121) || (count_matches) && kcov_then(121))
       {
  if (kcov_count(122) || (out_file) && kcov_then(122))
    printf("%s:", filename);
  printf("%d\n", count);
       }
     if (kcov_count(123) || (count) && kcov_then(123))
       {
  status = 0;
  if (kcov_count(124) || (list_files == 1) && kcov_then(124))
    printf("%s\n", filename);
       }
     else if (kcov_count(125) || (list_files == -1) && kcov_then(125))
       printf("%s\n", filename);
   }
 if (kcov_count(126) || (desc != 0) && kcov_then(126))
   close(desc);
 ++optind;
      }
  else
    {
      filename = "(standard input)";
      count = grep(0);
      if (kcov_count(127) || (count_matches) && kcov_then(127))
 printf("%d\n", count);
      if (kcov_count(128) || (count) && kcov_then(128))
 {
   status = 0;
   if (kcov_count(129) || (list_files == 1) && kcov_then(129))
     printf("(standard input)\n");
 }
      else if (kcov_count(130) || (list_files == -1) && kcov_then(130))
 printf("(standard input)\n");
    }

  exit(kcov_count(131) || (errseen) && kcov_then(131) ? 2 : status);
}
# 1704 "grep.c"
static char re_syntax_table[256];

static void
init_syntax_once ()
{
   register int c;
   static int done = 0;

   if (kcov_count(132) || (done) && kcov_then(132))
     return;

   memset ((re_syntax_table), 0, (sizeof re_syntax_table));

   for (c = 'a'; kcov_count(133) || (c <= 'z') && kcov_then(133); c++)
     re_syntax_table[c] = 1;

   for (c = 'A'; kcov_count(134) || (c <= 'Z') && kcov_then(134); c++)
     re_syntax_table[c] = 1;

   for (c = '0'; kcov_count(135) || (c <= '9') && kcov_then(135); c++)
     re_syntax_table[c] = 1;

   re_syntax_table['_'] = 1;

   done = 1;
}
# 1738 "grep.c"
# 1 "regex.h" 1
# 38 "regex.h"
typedef unsigned reg_syntax_t;
# 137 "regex.h"
extern reg_syntax_t re_syntax_options;
# 246 "regex.h"
typedef enum
{
  REG_NOERROR = 0,
  REG_NOMATCH,



  REG_BADPAT,
  REG_ECOLLATE,
  REG_ECTYPE,
  REG_EESCAPE,
  REG_ESUBREG,
  REG_EBRACK,
  REG_EPAREN,
  REG_EBRACE,
  REG_BADBR,
  REG_ERANGE,
  REG_ESPACE,
  REG_BADRPT,


  REG_EEND,
  REG_ESIZE,
  REG_ERPAREN
} reg_errcode_t;







struct re_pattern_buffer
{




  unsigned char *buffer;


  unsigned long allocated;


  unsigned long used;


  reg_syntax_t syntax;




  char *fastmap;





  char *translate;


  size_t re_nsub;






  unsigned can_be_null : 1;
# 323 "regex.h"
  unsigned regs_allocated : 2;



  unsigned fastmap_accurate : 1;



  unsigned no_sub : 1;



  unsigned not_bol : 1;


  unsigned not_eol : 1;


  unsigned newline_anchor : 1;


};

typedef struct re_pattern_buffer regex_t;







typedef int regoff_t;




struct re_registers
{
  unsigned num_regs;
  regoff_t *start;
  regoff_t *end;
};
# 378 "regex.h"
typedef struct
{
  regoff_t rm_so;
  regoff_t rm_eo;
} regmatch_t;
# 404 "regex.h"
extern reg_syntax_t re_set_syntax (reg_syntax_t syntax);




extern const char *re_compile_pattern
  (const char *pattern, int length, struct re_pattern_buffer *buffer);






extern int re_compile_fastmap (struct re_pattern_buffer *buffer);







extern int re_search
  (struct re_pattern_buffer *buffer, const char *string, int length, int start, int range, struct re_registers *regs);





extern int re_search_2
  (struct re_pattern_buffer *buffer, const char *string1, int length1, const char *string2, int length2, int start, int range, struct re_registers *regs, int stop);






extern int re_match
  (struct re_pattern_buffer *buffer, const char *string, int length, int start, struct re_registers *regs);




extern int re_match_2
  (struct re_pattern_buffer *buffer, const char *string1, int length1, const char *string2, int length2, int start, struct re_registers *regs, int stop);
# 464 "regex.h"
extern void re_set_registers
  (struct re_pattern_buffer *buffer, struct re_registers *regs, unsigned num_regs, regoff_t *starts, regoff_t *ends);



extern char *re_comp (const char *);
extern int re_exec (const char *);


extern int regcomp (regex_t *preg, const char *pattern, int cflags);
extern int regexec
  (const regex_t *preg, const char *string, size_t nmatch, regmatch_t pmatch[], int eflags);

extern size_t regerror
  (int errcode, const regex_t *preg, char *errbuf, size_t errbuf_size);

extern void regfree (regex_t *preg);
# 1739 "grep.c" 2


# 1 "/usr/include/ctype.h" 1 3 4
# 30 "/usr/include/ctype.h" 3 4

# 48 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 81 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     ;
extern const __int32_t **__ctype_tolower_loc (void)
     ;
extern const __int32_t **__ctype_toupper_loc (void)
     ;
# 96 "/usr/include/ctype.h" 3 4






extern int isalnum (int) ;
extern int isalpha (int) ;
extern int iscntrl (int) ;
extern int isdigit (int) ;
extern int islower (int) ;
extern int isgraph (int) ;
extern int isprint (int) ;
extern int ispunct (int) ;
extern int isspace (int) ;
extern int isupper (int) ;
extern int isxdigit (int) ;



extern int tolower (int __c) ;


extern int toupper (int __c) ;








extern int isblank (int) ;


# 142 "/usr/include/ctype.h" 3 4
extern int isascii (int __c) ;



extern int toascii (int __c) ;



extern int _toupper (int) ;
extern int _tolower (int) ;
# 247 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) ;
extern int isalpha_l (int, __locale_t) ;
extern int iscntrl_l (int, __locale_t) ;
extern int isdigit_l (int, __locale_t) ;
extern int islower_l (int, __locale_t) ;
extern int isgraph_l (int, __locale_t) ;
extern int isprint_l (int, __locale_t) ;
extern int ispunct_l (int, __locale_t) ;
extern int isspace_l (int, __locale_t) ;
extern int isupper_l (int, __locale_t) ;
extern int isxdigit_l (int, __locale_t) ;

extern int isblank_l (int, __locale_t) ;



extern int __tolower_l (int __c, __locale_t __l) ;
extern int tolower_l (int __c, __locale_t __l) ;


extern int __toupper_l (int __c, __locale_t __l) ;
extern int toupper_l (int __c, __locale_t __l) ;
# 323 "/usr/include/ctype.h" 3 4

# 1742 "grep.c" 2
# 1864 "grep.c"
typedef char boolean;
# 1877 "grep.c"
typedef enum
{
  no_op = 0,


  exactn = 1,


  anychar,







  charset,



  charset_not,
# 1906 "grep.c"
  start_memory,
# 1915 "grep.c"
  stop_memory,



  duplicate,


  begline,


  endline,



  begbuf,


  endbuf,


  jump,


  jump_past_alt,



  on_failure_jump,



  on_failure_keep_string_jump,



  pop_failure_jump,
# 1959 "grep.c"
  maybe_pop_jump,






  dummy_failure_jump,



  push_dummy_failure,



  succeed_n,



  jump_n,




  set_number_at,

  wordchar,
  notwordchar,

  wordbeg,
  wordend,

  wordbound,
  notwordbound
# 2006 "grep.c"
} re_opcode_t;
# 2448 "grep.c"
reg_syntax_t re_syntax_options = 0;
# 2458 "grep.c"
reg_syntax_t
re_set_syntax (syntax)
    reg_syntax_t syntax;
{
  reg_syntax_t ret = re_syntax_options;

  re_syntax_options = syntax;
  return ret;
}




static const char *re_error_msg[] =
  { ((void *)0),
    "No match",
    "Invalid regular expression",
    "Invalid collation character",
    "Invalid character class name",
    "Trailing backslash",
    "Invalid back reference",
    "Unmatched [ or [^",
    "Unmatched ( or \\(",
    "Unmatched \\{",
    "Invalid content of \\{\\}",
    "Invalid range end",
    "Memory exhausted",
    "Invalid preceding regular expression",
    "Premature end of regular expression",
    "Regular expression too big",
    "Unmatched ) or \\)",
  };



static void store_op1 (), store_op2 ();
static void insert_op1 (), insert_op2 ();
static boolean at_begline_loc_p (), at_endline_loc_p ();
static boolean group_in_compile_stack ();
static reg_errcode_t compile_range ();
# 2625 "grep.c"
typedef unsigned regnum_t;






typedef int pattern_offset_t;

typedef struct
{
  pattern_offset_t begalt_offset;
  pattern_offset_t fixup_alt_jump;
  pattern_offset_t inner_group_offset;
  pattern_offset_t laststart_offset;
  regnum_t regnum;
} compile_stack_elt_t;


typedef struct
{
  compile_stack_elt_t *stack;
  unsigned size;
  unsigned avail;
} compile_stack_type;
# 2712 "grep.c"
static reg_errcode_t
regex_compile (pattern, size, syntax, bufp)
     const char *pattern;
     int size;
     reg_syntax_t syntax;
     struct re_pattern_buffer *bufp;
{



  register unsigned char c, c1;


  const char *p1;


  register unsigned char *b;


  compile_stack_type compile_stack;


  const char *p = pattern;
  const char *pend = pattern + size;


  char *translate = bufp->translate;





  unsigned char *pending_exact = 0;




  unsigned char *laststart = 0;


  unsigned char *begalt;



  const char *beg_interval;




  unsigned char *fixup_alt_jump = 0;




  regnum_t regnum = 0;
# 2781 "grep.c"
  compile_stack.stack = ((compile_stack_elt_t *) malloc ((32) * sizeof (compile_stack_elt_t)));
  if (kcov_count(136) || (compile_stack.stack == ((void *)0)) && kcov_then(136))
    return REG_ESPACE;

  compile_stack.size = 32;
  compile_stack.avail = 0;


  bufp->syntax = syntax;
  bufp->fastmap_accurate = 0;
  bufp->not_bol = bufp->not_eol = 0;




  bufp->used = 0;


  bufp->re_nsub = 0;



   init_syntax_once ();


  if (kcov_count(137) || (bufp->allocated == 0) && kcov_then(137))
    {
      if (kcov_count(138) || (bufp->buffer) && kcov_then(138))
 {


          ((bufp->buffer) = (unsigned char *) realloc (bufp->buffer, (32) * sizeof (unsigned char)));
        }
      else
        {
          bufp->buffer = ((unsigned char *) malloc ((32) * sizeof (unsigned char)));
        }
      if (kcov_count(139) || (!bufp->buffer) && kcov_then(139)) return REG_ESPACE;

      bufp->allocated = 32;
    }

  begalt = b = bufp->buffer;


  while (kcov_count(140) || (p != pend) && kcov_then(140))
    {
      do {if (kcov_count(142) || (p == pend) && kcov_then(142)) return REG_EEND; c = (unsigned char) *p++; if (kcov_count(143) || (translate) && kcov_then(143)) c = translate[c]; } while (kcov_count(141) || (0) && kcov_then(141));

      switch (c)
        {
        case '^':kcov_count(144);
kcov_then(144);

          {
            if (
                   kcov_count(145) || (p == pattern + 1

                || syntax & ((((1) << 1) << 1) << 1)

                || at_begline_loc_p (pattern, p, syntax)) && kcov_then(145))
              do { while (kcov_count(147) || (b - bufp->buffer + (1) > bufp->allocated) && kcov_then(147)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(149) || (bufp->allocated == (1L << 16)) && kcov_then(149)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(150) || (bufp->allocated > (1L << 16)) && kcov_then(150)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(151) || (bufp->buffer == ((void *)0)) && kcov_then(151)) return REG_ESPACE; if (kcov_count(152) || (old_buffer != bufp->buffer) && kcov_then(152)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(153) || (fixup_alt_jump) && kcov_then(153)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(154) || (laststart) && kcov_then(154)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(155) || (pending_exact) && kcov_then(155)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(148) || (0) && kcov_then(148)); *b++ = (unsigned char) (begline); } while (kcov_count(146) || (0) && kcov_then(146));
            else
              goto normal_char;
          }
          break;


        case '$':kcov_count(156);
kcov_then(156);

          {
            if (
                   kcov_count(157) || (p == pend

                || syntax & ((((1) << 1) << 1) << 1)

                || at_endline_loc_p (p, pend, syntax)) && kcov_then(157))
               do { while (kcov_count(159) || (b - bufp->buffer + (1) > bufp->allocated) && kcov_then(159)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(161) || (bufp->allocated == (1L << 16)) && kcov_then(161)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(162) || (bufp->allocated > (1L << 16)) && kcov_then(162)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(163) || (bufp->buffer == ((void *)0)) && kcov_then(163)) return REG_ESPACE; if (kcov_count(164) || (old_buffer != bufp->buffer) && kcov_then(164)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(165) || (fixup_alt_jump) && kcov_then(165)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(166) || (laststart) && kcov_then(166)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(167) || (pending_exact) && kcov_then(167)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(160) || (0) && kcov_then(160)); *b++ = (unsigned char) (endline); } while (kcov_count(158) || (0) && kcov_then(158));
             else
               goto normal_char;
           }
           break;


 case '+':kcov_count(168);
kcov_then(168);

        case '?':kcov_count(169);
kcov_then(169);

          if (kcov_count(170) || ((syntax & ((1) << 1))
              || (syntax & (((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) && kcov_then(170))
            goto normal_char;
        handle_plus:
        case '*':kcov_count(171);
kcov_then(171);


          if (kcov_count(172) || (!laststart) && kcov_then(172))
            {
              if (kcov_count(173) || (syntax & ((((((1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(173))
                return REG_BADRPT;
              else if (kcov_count(174) || (!(syntax & (((((1) << 1) << 1) << 1) << 1))) && kcov_then(174))
                goto normal_char;
            }

          {

            boolean keep_string_p = 0;


            char zero_times_ok = 0, many_times_ok = 0;






            for (;kcov_count(175) || kcov_then(175);)
              {
                zero_times_ok |= c != '+';
                many_times_ok |= c != '?';

                if (kcov_count(176) || (p == pend) && kcov_then(176))
                  break;

                do {if (kcov_count(178) || (p == pend) && kcov_then(178)) return REG_EEND; c = (unsigned char) *p++; if (kcov_count(179) || (translate) && kcov_then(179)) c = translate[c]; } while (kcov_count(177) || (0) && kcov_then(177));

                if (kcov_count(180) || (c == '*'
                    || (!(syntax & ((1) << 1)) && (c == '+' || c == '?'))) && kcov_then(180))
                  ;

                else if (kcov_count(181) || (syntax & ((1) << 1) && c == '\\') && kcov_then(181))
                  {
                    if (kcov_count(182) || (p == pend) && kcov_then(182)) return REG_EESCAPE;

                    do {if (kcov_count(184) || (p == pend) && kcov_then(184)) return REG_EEND; c1 = (unsigned char) *p++; if (kcov_count(185) || (translate) && kcov_then(185)) c1 = translate[c1]; } while (kcov_count(183) || (0) && kcov_then(183));
                    if (kcov_count(186) || (!(c1 == '+' || c1 == '?')) && kcov_then(186))
                      {
                        p--;
                        p--;
                        break;
                      }

                    c = c1;
                  }
                else
                  {
                    p--;
                    break;
                  }


               }



            if (kcov_count(187) || (!laststart) && kcov_then(187))
              break;



            if (kcov_count(188) || (many_times_ok) && kcov_then(188))
              {
# 2945 "grep.c"
                ;


                while (kcov_count(189) || (b - bufp->buffer + (3) > bufp->allocated) && kcov_then(189)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(191) || (bufp->allocated == (1L << 16)) && kcov_then(191)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(192) || (bufp->allocated > (1L << 16)) && kcov_then(192)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(193) || (bufp->buffer == ((void *)0)) && kcov_then(193)) return REG_ESPACE; if (kcov_count(194) || (old_buffer != bufp->buffer) && kcov_then(194)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(195) || (fixup_alt_jump) && kcov_then(195)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(196) || (laststart) && kcov_then(196)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(197) || (pending_exact) && kcov_then(197)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(190) || (0) && kcov_then(190));






                if (kcov_count(198) || ((kcov_count(199) || (translate) && kcov_then(199) ? translate[(unsigned char) (*(p - 2))] : (*(p - 2))) == (kcov_count(200) || (translate) && kcov_then(200) ? translate[(unsigned char) ('.')] : ('.'))
      && zero_times_ok
                    && p < pend && (kcov_count(201) || (translate) && kcov_then(201) ? translate[(unsigned char) (*p)] : (*p)) == (kcov_count(202) || (translate) && kcov_then(202) ? translate[(unsigned char) ('\n')] : ('\n'))
                    && !(syntax & (((((((1) << 1) << 1) << 1) << 1) << 1) << 1))) && kcov_then(198))
                  {
                    store_op1 (jump, b, (laststart) - (b) - 3);
                    keep_string_p = 1;
                  }
                else

                  store_op1 (maybe_pop_jump, b, (laststart - 3) - (b) - 3);


                b += 3;
              }



            while (kcov_count(203) || (b - bufp->buffer + (3) > bufp->allocated) && kcov_then(203)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(205) || (bufp->allocated == (1L << 16)) && kcov_then(205)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(206) || (bufp->allocated > (1L << 16)) && kcov_then(206)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(207) || (bufp->buffer == ((void *)0)) && kcov_then(207)) return REG_ESPACE; if (kcov_count(208) || (old_buffer != bufp->buffer) && kcov_then(208)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(209) || (fixup_alt_jump) && kcov_then(209)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(210) || (laststart) && kcov_then(210)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(211) || (pending_exact) && kcov_then(211)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(204) || (0) && kcov_then(204));
            insert_op1 (kcov_count(212) || (keep_string_p) && kcov_then(212) ? on_failure_keep_string_jump : on_failure_jump, laststart, (b + 3) - (laststart) - 3, b);


            pending_exact = 0;
            b += 3;

            if (kcov_count(213) || (!zero_times_ok) && kcov_then(213))
              {





                while (kcov_count(214) || (b - bufp->buffer + (3) > bufp->allocated) && kcov_then(214)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(216) || (bufp->allocated == (1L << 16)) && kcov_then(216)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(217) || (bufp->allocated > (1L << 16)) && kcov_then(217)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(218) || (bufp->buffer == ((void *)0)) && kcov_then(218)) return REG_ESPACE; if (kcov_count(219) || (old_buffer != bufp->buffer) && kcov_then(219)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(220) || (fixup_alt_jump) && kcov_then(220)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(221) || (laststart) && kcov_then(221)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(222) || (pending_exact) && kcov_then(222)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(215) || (0) && kcov_then(215));
                insert_op1 (dummy_failure_jump, laststart, (laststart + 6) - (laststart) - 3, b);
                b += 3;
              }
            }
   break;


 case '.':kcov_count(223);
kcov_then(223);

          laststart = b;
          do { while (kcov_count(225) || (b - bufp->buffer + (1) > bufp->allocated) && kcov_then(225)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(227) || (bufp->allocated == (1L << 16)) && kcov_then(227)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(228) || (bufp->allocated > (1L << 16)) && kcov_then(228)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(229) || (bufp->buffer == ((void *)0)) && kcov_then(229)) return REG_ESPACE; if (kcov_count(230) || (old_buffer != bufp->buffer) && kcov_then(230)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(231) || (fixup_alt_jump) && kcov_then(231)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(232) || (laststart) && kcov_then(232)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(233) || (pending_exact) && kcov_then(233)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(226) || (0) && kcov_then(226)); *b++ = (unsigned char) (anychar); } while (kcov_count(224) || (0) && kcov_then(224));
          break;


        case '[':kcov_count(234);
kcov_then(234);

          {
            boolean had_char_class = 0;

            if (kcov_count(235) || (p == pend) && kcov_then(235)) return REG_EBRACK;



     while (kcov_count(236) || (b - bufp->buffer + (34) > bufp->allocated) && kcov_then(236)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(238) || (bufp->allocated == (1L << 16)) && kcov_then(238)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(239) || (bufp->allocated > (1L << 16)) && kcov_then(239)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(240) || (bufp->buffer == ((void *)0)) && kcov_then(240)) return REG_ESPACE; if (kcov_count(241) || (old_buffer != bufp->buffer) && kcov_then(241)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(242) || (fixup_alt_jump) && kcov_then(242)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(243) || (laststart) && kcov_then(243)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(244) || (pending_exact) && kcov_then(244)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(237) || (0) && kcov_then(237));

            laststart = b;



            do { while (kcov_count(246) || (b - bufp->buffer + (1) > bufp->allocated) && kcov_then(246)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(248) || (bufp->allocated == (1L << 16)) && kcov_then(248)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(249) || (bufp->allocated > (1L << 16)) && kcov_then(249)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(250) || (bufp->buffer == ((void *)0)) && kcov_then(250)) return REG_ESPACE; if (kcov_count(251) || (old_buffer != bufp->buffer) && kcov_then(251)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(252) || (fixup_alt_jump) && kcov_then(252)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(253) || (laststart) && kcov_then(253)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(254) || (pending_exact) && kcov_then(254)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(247) || (0) && kcov_then(247)); *b++ = (unsigned char) (kcov_count(255) || (*p == '^') && kcov_then(255) ? charset_not : charset); } while (kcov_count(245) || (0) && kcov_then(245));
            if (kcov_count(256) || (*p == '^') && kcov_then(256))
              p++;


            p1 = p;


            do { while (kcov_count(258) || (b - bufp->buffer + (1) > bufp->allocated) && kcov_then(258)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(260) || (bufp->allocated == (1L << 16)) && kcov_then(260)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(261) || (bufp->allocated > (1L << 16)) && kcov_then(261)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(262) || (bufp->buffer == ((void *)0)) && kcov_then(262)) return REG_ESPACE; if (kcov_count(263) || (old_buffer != bufp->buffer) && kcov_then(263)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(264) || (fixup_alt_jump) && kcov_then(264)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(265) || (laststart) && kcov_then(265)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(266) || (pending_exact) && kcov_then(266)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(259) || (0) && kcov_then(259)); *b++ = (unsigned char) ((1 << 8) / 8); } while (kcov_count(257) || (0) && kcov_then(257));


            memset ((b), 0, ((1 << 8) / 8));


            if (kcov_count(267) || ((re_opcode_t) b[-2] == charset_not
                && (syntax & (((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) && kcov_then(267))
              (b[((unsigned char) ('\n')) / 8] |= 1 << (((unsigned char) '\n') % 8));


            for (;kcov_count(268) || kcov_then(268);)
              {
                if (kcov_count(269) || (p == pend) && kcov_then(269)) return REG_EBRACK;

                do {if (kcov_count(271) || (p == pend) && kcov_then(271)) return REG_EEND; c = (unsigned char) *p++; if (kcov_count(272) || (translate) && kcov_then(272)) c = translate[c]; } while (kcov_count(270) || (0) && kcov_then(270));


                if (kcov_count(273) || ((syntax & (1)) && c == '\\') && kcov_then(273))
                  {
                    if (kcov_count(274) || (p == pend) && kcov_then(274)) return REG_EESCAPE;

                    do {if (kcov_count(276) || (p == pend) && kcov_then(276)) return REG_EEND; c1 = (unsigned char) *p++; if (kcov_count(277) || (translate) && kcov_then(277)) c1 = translate[c1]; } while (kcov_count(275) || (0) && kcov_then(275));
                    (b[((unsigned char) (c1)) / 8] |= 1 << (((unsigned char) c1) % 8));
                    continue;
                  }




                if (kcov_count(278) || (c == ']' && p != p1 + 1) && kcov_then(278))
                  break;



                if (kcov_count(279) || (had_char_class && c == '-' && *p != ']') && kcov_then(279))
                  return REG_ERANGE;





                if (kcov_count(280) || (c == '-'
                    && !(p - 2 >= pattern && p[-2] == '[')
                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
                    && *p != ']') && kcov_then(280))
                  {
                    reg_errcode_t ret
                      = compile_range (&p, pend, translate, syntax, b);
                    if (kcov_count(281) || (ret != REG_NOERROR) && kcov_then(281)) return ret;
                  }

                else if (kcov_count(282) || (p[0] == '-' && p[1] != ']') && kcov_then(282))
                  {
                    reg_errcode_t ret;


                    do {if (kcov_count(284) || (p == pend) && kcov_then(284)) return REG_EEND; c1 = (unsigned char) *p++; if (kcov_count(285) || (translate) && kcov_then(285)) c1 = translate[c1]; } while (kcov_count(283) || (0) && kcov_then(283));

                    ret = compile_range (&p, pend, translate, syntax, b);
                    if (kcov_count(286) || (ret != REG_NOERROR) && kcov_then(286)) return ret;
                  }




                else if (kcov_count(287) || (syntax & (((1) << 1) << 1) && c == '[' && *p == ':') && kcov_then(287))
                  {
                    char str[6 + 1];

                    do {if (kcov_count(289) || (p == pend) && kcov_then(289)) return REG_EEND; c = (unsigned char) *p++; if (kcov_count(290) || (translate) && kcov_then(290)) c = translate[c]; } while (kcov_count(288) || (0) && kcov_then(288));
                    c1 = 0;


                    if (kcov_count(291) || (p == pend) && kcov_then(291)) return REG_EBRACK;

                    for (;kcov_count(292) || kcov_then(292);)
                      {
                        do {if (kcov_count(294) || (p == pend) && kcov_then(294)) return REG_EEND; c = (unsigned char) *p++; if (kcov_count(295) || (translate) && kcov_then(295)) c = translate[c]; } while (kcov_count(293) || (0) && kcov_then(293));
                        if (kcov_count(296) || (c == ':' || c == ']' || p == pend
                            || c1 == 6) && kcov_then(296))
                          break;
                        str[c1++] = c;
                      }
                    str[c1] = '\0';




                    if (kcov_count(297) || (c == ':' && *p == ']') && kcov_then(297))
                      {
                        int ch;
                        boolean is_alnum = ((strcmp (str, "alnum") == 0));
                        boolean is_alpha = ((strcmp (str, "alpha") == 0));
                        boolean is_blank = ((strcmp (str, "blank") == 0));
                        boolean is_cntrl = ((strcmp (str, "cntrl") == 0));
                        boolean is_digit = ((strcmp (str, "digit") == 0));
                        boolean is_graph = ((strcmp (str, "graph") == 0));
                        boolean is_lower = ((strcmp (str, "lower") == 0));
                        boolean is_print = ((strcmp (str, "print") == 0));
                        boolean is_punct = ((strcmp (str, "punct") == 0));
                        boolean is_space = ((strcmp (str, "space") == 0));
                        boolean is_upper = ((strcmp (str, "upper") == 0));
                        boolean is_xdigit = ((strcmp (str, "xdigit") == 0));

                        if (kcov_count(298) || (!(((strcmp (str, "alpha") == 0)) || ((strcmp (str, "upper") == 0)) || ((strcmp (str, "lower") == 0)) || ((strcmp (str, "digit") == 0)) || ((strcmp (str, "alnum") == 0)) || ((strcmp (str, "xdigit") == 0)) || ((strcmp (str, "space") == 0)) || ((strcmp (str, "print") == 0)) || ((strcmp (str, "punct") == 0)) || ((strcmp (str, "graph") == 0)) || ((strcmp (str, "cntrl") == 0)) || ((strcmp (str, "blank") == 0)))) && kcov_then(298)) return REG_ECTYPE;



                        do {if (kcov_count(300) || (p == pend) && kcov_then(300)) return REG_EEND; c = (unsigned char) *p++; if (kcov_count(301) || (translate) && kcov_then(301)) c = translate[c]; } while (kcov_count(299) || (0) && kcov_then(299));

                        if (kcov_count(302) || (p == pend) && kcov_then(302)) return REG_EBRACK;

                        for (ch = 0; kcov_count(303) || (ch < 1 << 8) && kcov_then(303); ch++)
                          {
                            if ( kcov_count(304) || ((is_alnum && (1 && ((*__ctype_b_loc ())[(int) ((ch))] & (unsigned short int) _ISalnum)))
                                || (is_alpha && (1 && ((*__ctype_b_loc ())[(int) ((ch))] & (unsigned short int) _ISalpha)))
                                || (is_blank && (1 && ((*__ctype_b_loc ())[(int) ((ch))] & (unsigned short int) _ISblank)))
                                || (is_cntrl && (1 && ((*__ctype_b_loc ())[(int) ((ch))] & (unsigned short int) _IScntrl)))
                                || (is_digit && (1 && ((*__ctype_b_loc ())[(int) ((ch))] & (unsigned short int) _ISdigit)))
                                || (is_graph && (1 && ((*__ctype_b_loc ())[(int) ((ch))] & (unsigned short int) _ISgraph)))
                                || (is_lower && (1 && ((*__ctype_b_loc ())[(int) ((ch))] & (unsigned short int) _ISlower)))
                                || (is_print && (1 && ((*__ctype_b_loc ())[(int) ((ch))] & (unsigned short int) _ISprint)))
                                || (is_punct && (1 && ((*__ctype_b_loc ())[(int) ((ch))] & (unsigned short int) _ISpunct)))
                                || (is_space && (1 && ((*__ctype_b_loc ())[(int) ((ch))] & (unsigned short int) _ISspace)))
                                || (is_upper && (1 && ((*__ctype_b_loc ())[(int) ((ch))] & (unsigned short int) _ISupper)))
                                || (is_xdigit && (1 && ((*__ctype_b_loc ())[(int) ((ch))] & (unsigned short int) _ISxdigit)))) && kcov_then(304))
                            (b[((unsigned char) (ch)) / 8] |= 1 << (((unsigned char) ch) % 8));
                          }
                        had_char_class = 1;
                      }
                    else
                      {
                        c1++;
                        while (kcov_count(305) || (c1--) && kcov_then(305))
                          p--;
                        (b[((unsigned char) ('[')) / 8] |= 1 << (((unsigned char) '[') % 8));
                        (b[((unsigned char) (':')) / 8] |= 1 << (((unsigned char) ':') % 8));
                        had_char_class = 0;
                      }
                  }
                else
                  {
                    had_char_class = 0;
                    (b[((unsigned char) (c)) / 8] |= 1 << (((unsigned char) c) % 8));
                  }
              }



            while (kcov_count(306) || ((int) b[-1] > 0 && b[b[-1] - 1] == 0) && kcov_then(306))
              b[-1]--;
            b += b[-1];
          }
          break;


 case '(':kcov_count(307);
kcov_then(307);

          if (kcov_count(308) || (syntax & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(308))
            goto handle_open;
          else
            goto normal_char;


        case ')':kcov_count(309);
kcov_then(309);

          if (kcov_count(310) || (syntax & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(310))
            goto handle_close;
          else
            goto normal_char;


        case '\n':kcov_count(311);
kcov_then(311);

          if (kcov_count(312) || (syntax & ((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(312))
            goto handle_alt;
          else
            goto normal_char;


 case '|':kcov_count(313);
kcov_then(313);

          if (kcov_count(314) || (syntax & ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(314))
            goto handle_alt;
          else
            goto normal_char;


        case '{':kcov_count(315);
kcov_then(315);

           if (kcov_count(316) || (syntax & ((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) && syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(316))
             goto handle_interval;
           else
             goto normal_char;


        case '\\':kcov_count(317);
kcov_then(317);

          if (kcov_count(318) || (p == pend) && kcov_then(318)) return REG_EESCAPE;




          do {if (kcov_count(320) || (p == pend) && kcov_then(320)) return REG_EEND; c = (unsigned char) *p++; } while (kcov_count(319) || (0) && kcov_then(319));

          switch (c)
            {
            case '(':kcov_count(321);
kcov_then(321);

              if (kcov_count(322) || (syntax & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(322))
                goto normal_backslash;

            handle_open:
              bufp->re_nsub++;
              regnum++;

              if (kcov_count(323) || ((compile_stack.avail == compile_stack.size)) && kcov_then(323))
                {
                  ((compile_stack.stack) = (compile_stack_elt_t *) realloc (compile_stack.stack, (compile_stack.size << 1) * sizeof (compile_stack_elt_t)));

                  if (kcov_count(324) || (compile_stack.stack == ((void *)0)) && kcov_then(324)) return REG_ESPACE;

                  compile_stack.size <<= 1;
                }





              (compile_stack.stack[compile_stack.avail]).begalt_offset = begalt - bufp->buffer;
              (compile_stack.stack[compile_stack.avail]).fixup_alt_jump
                = kcov_count(325) || (fixup_alt_jump) && kcov_then(325) ? fixup_alt_jump - bufp->buffer + 1 : 0;
              (compile_stack.stack[compile_stack.avail]).laststart_offset = b - bufp->buffer;
              (compile_stack.stack[compile_stack.avail]).regnum = regnum;





              if (kcov_count(326) || (regnum <= 255) && kcov_then(326))
                {
                  (compile_stack.stack[compile_stack.avail]).inner_group_offset = b - bufp->buffer + 2;
                  do { while (kcov_count(328) || (b - bufp->buffer + (3) > bufp->allocated) && kcov_then(328)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(330) || (bufp->allocated == (1L << 16)) && kcov_then(330)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(331) || (bufp->allocated > (1L << 16)) && kcov_then(331)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(332) || (bufp->buffer == ((void *)0)) && kcov_then(332)) return REG_ESPACE; if (kcov_count(333) || (old_buffer != bufp->buffer) && kcov_then(333)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(334) || (fixup_alt_jump) && kcov_then(334)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(335) || (laststart) && kcov_then(335)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(336) || (pending_exact) && kcov_then(336)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(329) || (0) && kcov_then(329)); *b++ = (unsigned char) (start_memory); *b++ = (unsigned char) (regnum); *b++ = (unsigned char) (0); } while (kcov_count(327) || (0) && kcov_then(327));
                }

              compile_stack.avail++;

              fixup_alt_jump = 0;
              laststart = 0;
              begalt = b;



       pending_exact = 0;
              break;


            case ')':kcov_count(337);
kcov_then(337);

              if (kcov_count(338) || (syntax & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(338)) goto normal_backslash;

              if (kcov_count(339) || ((compile_stack.avail == 0)) && kcov_then(339))
                if (kcov_count(340) || (syntax & ((((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(340))
                  goto normal_backslash;
                else
                  return REG_ERPAREN;

            handle_close:
              if (kcov_count(341) || (fixup_alt_jump) && kcov_then(341))
                {



                  do { while (kcov_count(343) || (b - bufp->buffer + (1) > bufp->allocated) && kcov_then(343)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(345) || (bufp->allocated == (1L << 16)) && kcov_then(345)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(346) || (bufp->allocated > (1L << 16)) && kcov_then(346)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(347) || (bufp->buffer == ((void *)0)) && kcov_then(347)) return REG_ESPACE; if (kcov_count(348) || (old_buffer != bufp->buffer) && kcov_then(348)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(349) || (fixup_alt_jump) && kcov_then(349)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(350) || (laststart) && kcov_then(350)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(351) || (pending_exact) && kcov_then(351)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(344) || (0) && kcov_then(344)); *b++ = (unsigned char) (push_dummy_failure); } while (kcov_count(342) || (0) && kcov_then(342));



                  store_op1 (jump_past_alt, fixup_alt_jump, (b - 1) - (fixup_alt_jump) - 3);
                }


              if (kcov_count(352) || ((compile_stack.avail == 0)) && kcov_then(352))
                if (kcov_count(353) || (syntax & ((((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(353))
                  goto normal_char;
                else
                  return REG_ERPAREN;



              ;
              {



                regnum_t this_group_regnum;

                compile_stack.avail--;
                begalt = bufp->buffer + (compile_stack.stack[compile_stack.avail]).begalt_offset;
                fixup_alt_jump
                  = kcov_count(354) || ((compile_stack.stack[compile_stack.avail]).fixup_alt_jump) && kcov_then(354)
                    ? bufp->buffer + (compile_stack.stack[compile_stack.avail]).fixup_alt_jump - 1
                    : 0;
                laststart = bufp->buffer + (compile_stack.stack[compile_stack.avail]).laststart_offset;
                this_group_regnum = (compile_stack.stack[compile_stack.avail]).regnum;



  pending_exact = 0;



                if (kcov_count(355) || (this_group_regnum <= 255) && kcov_then(355))
                  {
                    unsigned char *inner_group_loc
                      = bufp->buffer + (compile_stack.stack[compile_stack.avail]).inner_group_offset;

                    *inner_group_loc = regnum - this_group_regnum;
                    do { while (kcov_count(357) || (b - bufp->buffer + (3) > bufp->allocated) && kcov_then(357)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(359) || (bufp->allocated == (1L << 16)) && kcov_then(359)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(360) || (bufp->allocated > (1L << 16)) && kcov_then(360)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(361) || (bufp->buffer == ((void *)0)) && kcov_then(361)) return REG_ESPACE; if (kcov_count(362) || (old_buffer != bufp->buffer) && kcov_then(362)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(363) || (fixup_alt_jump) && kcov_then(363)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(364) || (laststart) && kcov_then(364)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(365) || (pending_exact) && kcov_then(365)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(358) || (0) && kcov_then(358)); *b++ = (unsigned char) (stop_memory); *b++ = (unsigned char) (this_group_regnum); *b++ = (unsigned char) (regnum - this_group_regnum); } while (kcov_count(356) || (0) && kcov_then(356));

                  }
              }
              break;


            case '|':kcov_count(366);
kcov_then(366);

              if (kcov_count(367) || (syntax & (((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) || syntax & ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(367))
                goto normal_backslash;
            handle_alt:
              if (kcov_count(368) || (syntax & (((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(368))
                goto normal_char;



              while (kcov_count(369) || (b - bufp->buffer + (3) > bufp->allocated) && kcov_then(369)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(371) || (bufp->allocated == (1L << 16)) && kcov_then(371)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(372) || (bufp->allocated > (1L << 16)) && kcov_then(372)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(373) || (bufp->buffer == ((void *)0)) && kcov_then(373)) return REG_ESPACE; if (kcov_count(374) || (old_buffer != bufp->buffer) && kcov_then(374)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(375) || (fixup_alt_jump) && kcov_then(375)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(376) || (laststart) && kcov_then(376)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(377) || (pending_exact) && kcov_then(377)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(370) || (0) && kcov_then(370));
              insert_op1 (on_failure_jump, begalt, (b + 6) - (begalt) - 3, b);
              pending_exact = 0;
              b += 3;
# 3370 "grep.c"
              if (kcov_count(378) || (fixup_alt_jump) && kcov_then(378))
                store_op1 (jump_past_alt, fixup_alt_jump, (b) - (fixup_alt_jump) - 3);




              fixup_alt_jump = b;
              while (kcov_count(379) || (b - bufp->buffer + (3) > bufp->allocated) && kcov_then(379)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(381) || (bufp->allocated == (1L << 16)) && kcov_then(381)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(382) || (bufp->allocated > (1L << 16)) && kcov_then(382)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(383) || (bufp->buffer == ((void *)0)) && kcov_then(383)) return REG_ESPACE; if (kcov_count(384) || (old_buffer != bufp->buffer) && kcov_then(384)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(385) || (fixup_alt_jump) && kcov_then(385)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(386) || (laststart) && kcov_then(386)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(387) || (pending_exact) && kcov_then(387)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(380) || (0) && kcov_then(380));
              b += 3;

              laststart = 0;
              begalt = b;
              break;


            case '{':kcov_count(388);
kcov_then(388);


              if (kcov_count(389) || (!(syntax & ((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))


                  || ((syntax & ((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && (syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
                  || (p - 2 == pattern && p == pend)) && kcov_then(389))
                goto normal_backslash;

            handle_interval:
              {



                int lower_bound = -1, upper_bound = -1;

                beg_interval = p - 1;

                if (kcov_count(390) || (p == pend) && kcov_then(390))
                  {
                    if (kcov_count(391) || (syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(391))
                      goto unfetch_interval;
                    else
                      return REG_EBRACE;
                  }

                { if (kcov_count(392) || (p != pend) && kcov_then(392)) { do {if (kcov_count(394) || (p == pend) && kcov_then(394)) return REG_EEND; c = (unsigned char) *p++; if (kcov_count(395) || (translate) && kcov_then(395)) c = translate[c]; } while (kcov_count(393) || (0) && kcov_then(393)); while (kcov_count(396) || ((1 && ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISdigit))) && kcov_then(396)) { if (kcov_count(397) || (lower_bound < 0) && kcov_then(397)) lower_bound = 0; lower_bound = lower_bound * 10 + c - '0'; if (kcov_count(398) || (p == pend) && kcov_then(398)) break; do {if (kcov_count(400) || (p == pend) && kcov_then(400)) return REG_EEND; c = (unsigned char) *p++; if (kcov_count(401) || (translate) && kcov_then(401)) c = translate[c]; } while (kcov_count(399) || (0) && kcov_then(399)); } } };

                if (kcov_count(402) || (c == ',') && kcov_then(402))
                  {
                    { if (kcov_count(403) || (p != pend) && kcov_then(403)) { do {if (kcov_count(405) || (p == pend) && kcov_then(405)) return REG_EEND; c = (unsigned char) *p++; if (kcov_count(406) || (translate) && kcov_then(406)) c = translate[c]; } while (kcov_count(404) || (0) && kcov_then(404)); while (kcov_count(407) || ((1 && ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISdigit))) && kcov_then(407)) { if (kcov_count(408) || (upper_bound < 0) && kcov_then(408)) upper_bound = 0; upper_bound = upper_bound * 10 + c - '0'; if (kcov_count(409) || (p == pend) && kcov_then(409)) break; do {if (kcov_count(411) || (p == pend) && kcov_then(411)) return REG_EEND; c = (unsigned char) *p++; if (kcov_count(412) || (translate) && kcov_then(412)) c = translate[c]; } while (kcov_count(410) || (0) && kcov_then(410)); } } };
                    if (kcov_count(413) || (upper_bound < 0) && kcov_then(413)) upper_bound = ((1 << 15) - 1);
                  }
                else

                  upper_bound = lower_bound;

                if (kcov_count(414) || (lower_bound < 0 || upper_bound > ((1 << 15) - 1)
                    || lower_bound > upper_bound) && kcov_then(414))
                  {
                    if (kcov_count(415) || (syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(415))
                      goto unfetch_interval;
                    else
                      return REG_BADBR;
                  }

                if (kcov_count(416) || (!(syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) && kcov_then(416))
                  {
                    if (kcov_count(417) || (c != '\\') && kcov_then(417)) return REG_EBRACE;

                    do {if (kcov_count(419) || (p == pend) && kcov_then(419)) return REG_EEND; c = (unsigned char) *p++; if (kcov_count(420) || (translate) && kcov_then(420)) c = translate[c]; } while (kcov_count(418) || (0) && kcov_then(418));
                  }

                if (kcov_count(421) || (c != '}') && kcov_then(421))
                  {
                    if (kcov_count(422) || (syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(422))
                      goto unfetch_interval;
                    else
                      return REG_BADBR;
                  }




                if (kcov_count(423) || (!laststart) && kcov_then(423))
                  {
                    if (kcov_count(424) || (syntax & ((((((1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(424))
                      return REG_BADRPT;
                    else if (kcov_count(425) || (syntax & (((((1) << 1) << 1) << 1) << 1)) && kcov_then(425))
                      laststart = b;
                    else
                      goto unfetch_interval;
                  }




                 if (kcov_count(426) || (upper_bound == 0) && kcov_then(426))
                   {
                     while (kcov_count(427) || (b - bufp->buffer + (3) > bufp->allocated) && kcov_then(427)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(429) || (bufp->allocated == (1L << 16)) && kcov_then(429)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(430) || (bufp->allocated > (1L << 16)) && kcov_then(430)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(431) || (bufp->buffer == ((void *)0)) && kcov_then(431)) return REG_ESPACE; if (kcov_count(432) || (old_buffer != bufp->buffer) && kcov_then(432)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(433) || (fixup_alt_jump) && kcov_then(433)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(434) || (laststart) && kcov_then(434)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(435) || (pending_exact) && kcov_then(435)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(428) || (0) && kcov_then(428));
                     insert_op1 (jump, laststart, (b + 3) - (laststart) - 3, b);
                     b += 3;
                   }
# 3478 "grep.c"
                 else
                   {

                     unsigned nbytes = 10 + (upper_bound > 1) * 10;

                     while (kcov_count(436) || (b - bufp->buffer + (nbytes) > bufp->allocated) && kcov_then(436)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(438) || (bufp->allocated == (1L << 16)) && kcov_then(438)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(439) || (bufp->allocated > (1L << 16)) && kcov_then(439)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(440) || (bufp->buffer == ((void *)0)) && kcov_then(440)) return REG_ESPACE; if (kcov_count(441) || (old_buffer != bufp->buffer) && kcov_then(441)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(442) || (fixup_alt_jump) && kcov_then(442)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(443) || (laststart) && kcov_then(443)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(444) || (pending_exact) && kcov_then(444)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(437) || (0) && kcov_then(437));






                     insert_op2 (succeed_n, laststart, (b + 5 + (upper_bound > 1) * 5) - (laststart) - 3, lower_bound, b);


                     b += 5;





                     insert_op2 (set_number_at, laststart, 5, lower_bound, b);
                     b += 5;

                     if (kcov_count(445) || (upper_bound > 1) && kcov_then(445))
                       {






                         store_op2 (jump_n, b, (laststart + 5) - (b) - 3, upper_bound - 1);

                         b += 5;
# 3528 "grep.c"
                         insert_op2 (set_number_at, laststart, b - laststart,
                                     upper_bound - 1, b);
                         b += 5;
                       }
                   }
                pending_exact = 0;
                beg_interval = ((void *)0);
              }
              break;

            unfetch_interval:

               ;
               p = beg_interval;
               beg_interval = ((void *)0);


               do {if (kcov_count(447) || (p == pend) && kcov_then(447)) return REG_EEND; c = (unsigned char) *p++; if (kcov_count(448) || (translate) && kcov_then(448)) c = translate[c]; } while (kcov_count(446) || (0) && kcov_then(446));

               if (kcov_count(449) || (!(syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) && kcov_then(449))
                 {
                   if (kcov_count(450) || (p > pattern && p[-1] == '\\') && kcov_then(450))
                     goto normal_backslash;
                 }
               goto normal_char;
# 3575 "grep.c"
            case 'w':kcov_count(451);
kcov_then(451);

              laststart = b;
              do { while (kcov_count(453) || (b - bufp->buffer + (1) > bufp->allocated) && kcov_then(453)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(455) || (bufp->allocated == (1L << 16)) && kcov_then(455)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(456) || (bufp->allocated > (1L << 16)) && kcov_then(456)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(457) || (bufp->buffer == ((void *)0)) && kcov_then(457)) return REG_ESPACE; if (kcov_count(458) || (old_buffer != bufp->buffer) && kcov_then(458)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(459) || (fixup_alt_jump) && kcov_then(459)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(460) || (laststart) && kcov_then(460)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(461) || (pending_exact) && kcov_then(461)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(454) || (0) && kcov_then(454)); *b++ = (unsigned char) (wordchar); } while (kcov_count(452) || (0) && kcov_then(452));
              break;


            case 'W':kcov_count(462);
kcov_then(462);

              laststart = b;
              do { while (kcov_count(464) || (b - bufp->buffer + (1) > bufp->allocated) && kcov_then(464)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(466) || (bufp->allocated == (1L << 16)) && kcov_then(466)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(467) || (bufp->allocated > (1L << 16)) && kcov_then(467)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(468) || (bufp->buffer == ((void *)0)) && kcov_then(468)) return REG_ESPACE; if (kcov_count(469) || (old_buffer != bufp->buffer) && kcov_then(469)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(470) || (fixup_alt_jump) && kcov_then(470)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(471) || (laststart) && kcov_then(471)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(472) || (pending_exact) && kcov_then(472)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(465) || (0) && kcov_then(465)); *b++ = (unsigned char) (notwordchar); } while (kcov_count(463) || (0) && kcov_then(463));
              break;


            case '<':kcov_count(473);
kcov_then(473);

              do { while (kcov_count(475) || (b - bufp->buffer + (1) > bufp->allocated) && kcov_then(475)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(477) || (bufp->allocated == (1L << 16)) && kcov_then(477)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(478) || (bufp->allocated > (1L << 16)) && kcov_then(478)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(479) || (bufp->buffer == ((void *)0)) && kcov_then(479)) return REG_ESPACE; if (kcov_count(480) || (old_buffer != bufp->buffer) && kcov_then(480)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(481) || (fixup_alt_jump) && kcov_then(481)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(482) || (laststart) && kcov_then(482)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(483) || (pending_exact) && kcov_then(483)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(476) || (0) && kcov_then(476)); *b++ = (unsigned char) (wordbeg); } while (kcov_count(474) || (0) && kcov_then(474));
              break;

            case '>':kcov_count(484);
kcov_then(484);

              do { while (kcov_count(486) || (b - bufp->buffer + (1) > bufp->allocated) && kcov_then(486)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(488) || (bufp->allocated == (1L << 16)) && kcov_then(488)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(489) || (bufp->allocated > (1L << 16)) && kcov_then(489)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(490) || (bufp->buffer == ((void *)0)) && kcov_then(490)) return REG_ESPACE; if (kcov_count(491) || (old_buffer != bufp->buffer) && kcov_then(491)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(492) || (fixup_alt_jump) && kcov_then(492)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(493) || (laststart) && kcov_then(493)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(494) || (pending_exact) && kcov_then(494)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(487) || (0) && kcov_then(487)); *b++ = (unsigned char) (wordend); } while (kcov_count(485) || (0) && kcov_then(485));
              break;

            case 'b':kcov_count(495);
kcov_then(495);

              do { while (kcov_count(497) || (b - bufp->buffer + (1) > bufp->allocated) && kcov_then(497)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(499) || (bufp->allocated == (1L << 16)) && kcov_then(499)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(500) || (bufp->allocated > (1L << 16)) && kcov_then(500)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(501) || (bufp->buffer == ((void *)0)) && kcov_then(501)) return REG_ESPACE; if (kcov_count(502) || (old_buffer != bufp->buffer) && kcov_then(502)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(503) || (fixup_alt_jump) && kcov_then(503)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(504) || (laststart) && kcov_then(504)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(505) || (pending_exact) && kcov_then(505)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(498) || (0) && kcov_then(498)); *b++ = (unsigned char) (wordbound); } while (kcov_count(496) || (0) && kcov_then(496));
              break;

            case 'B':kcov_count(506);
kcov_then(506);

              do { while (kcov_count(508) || (b - bufp->buffer + (1) > bufp->allocated) && kcov_then(508)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(510) || (bufp->allocated == (1L << 16)) && kcov_then(510)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(511) || (bufp->allocated > (1L << 16)) && kcov_then(511)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(512) || (bufp->buffer == ((void *)0)) && kcov_then(512)) return REG_ESPACE; if (kcov_count(513) || (old_buffer != bufp->buffer) && kcov_then(513)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(514) || (fixup_alt_jump) && kcov_then(514)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(515) || (laststart) && kcov_then(515)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(516) || (pending_exact) && kcov_then(516)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(509) || (0) && kcov_then(509)); *b++ = (unsigned char) (notwordbound); } while (kcov_count(507) || (0) && kcov_then(507));
              break;

            case '`':kcov_count(517);
kcov_then(517);

              do { while (kcov_count(519) || (b - bufp->buffer + (1) > bufp->allocated) && kcov_then(519)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(521) || (bufp->allocated == (1L << 16)) && kcov_then(521)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(522) || (bufp->allocated > (1L << 16)) && kcov_then(522)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(523) || (bufp->buffer == ((void *)0)) && kcov_then(523)) return REG_ESPACE; if (kcov_count(524) || (old_buffer != bufp->buffer) && kcov_then(524)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(525) || (fixup_alt_jump) && kcov_then(525)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(526) || (laststart) && kcov_then(526)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(527) || (pending_exact) && kcov_then(527)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(520) || (0) && kcov_then(520)); *b++ = (unsigned char) (begbuf); } while (kcov_count(518) || (0) && kcov_then(518));
              break;

            case '\'':kcov_count(528);
kcov_then(528);

              do { while (kcov_count(530) || (b - bufp->buffer + (1) > bufp->allocated) && kcov_then(530)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(532) || (bufp->allocated == (1L << 16)) && kcov_then(532)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(533) || (bufp->allocated > (1L << 16)) && kcov_then(533)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(534) || (bufp->buffer == ((void *)0)) && kcov_then(534)) return REG_ESPACE; if (kcov_count(535) || (old_buffer != bufp->buffer) && kcov_then(535)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(536) || (fixup_alt_jump) && kcov_then(536)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(537) || (laststart) && kcov_then(537)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(538) || (pending_exact) && kcov_then(538)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(531) || (0) && kcov_then(531)); *b++ = (unsigned char) (endbuf); } while (kcov_count(529) || (0) && kcov_then(529));
              break;

            case '1':kcov_count(539);
kcov_then(539);
 case '2':kcov_count(540);
kcov_then(540);
 case '3':kcov_count(541);
kcov_then(541);
 case '4':kcov_count(542);
kcov_then(542);
 case '5':kcov_count(543);
kcov_then(543);

            case '6':kcov_count(544);
kcov_then(544);
 case '7':kcov_count(545);
kcov_then(545);
 case '8':kcov_count(546);
kcov_then(546);
 case '9':kcov_count(547);
kcov_then(547);

              if (kcov_count(548) || (syntax & (((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(548))
                goto normal_char;

              c1 = c - '0';

              if (kcov_count(549) || (c1 > regnum) && kcov_then(549))
                return REG_ESUBREG;


              if (kcov_count(550) || (group_in_compile_stack (compile_stack, c1)) && kcov_then(550))
                goto normal_char;

              laststart = b;
              do { while (kcov_count(552) || (b - bufp->buffer + (2) > bufp->allocated) && kcov_then(552)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(554) || (bufp->allocated == (1L << 16)) && kcov_then(554)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(555) || (bufp->allocated > (1L << 16)) && kcov_then(555)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(556) || (bufp->buffer == ((void *)0)) && kcov_then(556)) return REG_ESPACE; if (kcov_count(557) || (old_buffer != bufp->buffer) && kcov_then(557)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(558) || (fixup_alt_jump) && kcov_then(558)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(559) || (laststart) && kcov_then(559)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(560) || (pending_exact) && kcov_then(560)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(553) || (0) && kcov_then(553)); *b++ = (unsigned char) (duplicate); *b++ = (unsigned char) (c1); } while (kcov_count(551) || (0) && kcov_then(551));
              break;


            case '+':kcov_count(561);
kcov_then(561);

            case '?':kcov_count(562);
kcov_then(562);

              if (kcov_count(563) || (syntax & ((1) << 1)) && kcov_then(563))
                goto handle_plus;
              else
                goto normal_backslash;

            default:kcov_count(564);
kcov_then(564);

            normal_backslash:



              c = (kcov_count(565) || (translate) && kcov_then(565) ? translate[(unsigned char) (c)] : (c));
              goto normal_char;
            }
          break;


 default:kcov_count(566);
kcov_then(566);


 normal_char:

          if (kcov_count(567) || (!pending_exact


              || pending_exact + *pending_exact + 1 != b


       || *pending_exact == (1 << 8) - 1


              || *p == '*' || *p == '^'
       || (kcov_count(568) || ((syntax & ((1) << 1))) && kcov_then(568)
    ? *p == '\\' && (p[1] == '+' || p[1] == '?')
    : (*p == '+' || *p == '?'))
       || ((syntax & ((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
                  && (kcov_count(569) || ((syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) && kcov_then(569)
        ? *p == '{'
                      : (p[0] == '\\' && p[1] == '{')))) && kcov_then(567))
     {


              laststart = b;

       do { while (kcov_count(571) || (b - bufp->buffer + (2) > bufp->allocated) && kcov_then(571)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(573) || (bufp->allocated == (1L << 16)) && kcov_then(573)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(574) || (bufp->allocated > (1L << 16)) && kcov_then(574)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(575) || (bufp->buffer == ((void *)0)) && kcov_then(575)) return REG_ESPACE; if (kcov_count(576) || (old_buffer != bufp->buffer) && kcov_then(576)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(577) || (fixup_alt_jump) && kcov_then(577)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(578) || (laststart) && kcov_then(578)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(579) || (pending_exact) && kcov_then(579)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(572) || (0) && kcov_then(572)); *b++ = (unsigned char) (exactn); *b++ = (unsigned char) (0); } while (kcov_count(570) || (0) && kcov_then(570));
       pending_exact = b - 1;
            }

   do { while (kcov_count(581) || (b - bufp->buffer + (1) > bufp->allocated) && kcov_then(581)) do { unsigned char *old_buffer = bufp->buffer; if (kcov_count(583) || (bufp->allocated == (1L << 16)) && kcov_then(583)) return REG_ESIZE; bufp->allocated <<= 1; if (kcov_count(584) || (bufp->allocated > (1L << 16)) && kcov_then(584)) bufp->allocated = (1L << 16); bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated); if (kcov_count(585) || (bufp->buffer == ((void *)0)) && kcov_then(585)) return REG_ESPACE; if (kcov_count(586) || (old_buffer != bufp->buffer) && kcov_then(586)) { b = (b - old_buffer) + bufp->buffer; begalt = (begalt - old_buffer) + bufp->buffer; if (kcov_count(587) || (fixup_alt_jump) && kcov_then(587)) fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer; if (kcov_count(588) || (laststart) && kcov_then(588)) laststart = (laststart - old_buffer) + bufp->buffer; if (kcov_count(589) || (pending_exact) && kcov_then(589)) pending_exact = (pending_exact - old_buffer) + bufp->buffer; } } while (kcov_count(582) || (0) && kcov_then(582)); *b++ = (unsigned char) (c); } while (kcov_count(580) || (0) && kcov_then(580));
          (*pending_exact)++;
   break;
        }
    }




  if (kcov_count(590) || (fixup_alt_jump) && kcov_then(590))
    store_op1 (jump_past_alt, fixup_alt_jump, (b) - (fixup_alt_jump) - 3);

  if (kcov_count(591) || (!(compile_stack.avail == 0)) && kcov_then(591))
    return REG_EPAREN;

  free (compile_stack.stack);


  bufp->used = b - bufp->buffer;
# 3706 "grep.c"
  return REG_NOERROR;
}





static void
store_op1 (op, loc, arg)
    re_opcode_t op;
    unsigned char *loc;
    int arg;
{
  *loc = (unsigned char) op;
  do { (loc + 1)[0] = (arg) & 0377; (loc + 1)[1] = (arg) >> 8; } while (kcov_count(592) || (0) && kcov_then(592));
}




static void
store_op2 (op, loc, arg1, arg2)
    re_opcode_t op;
    unsigned char *loc;
    int arg1, arg2;
{
  *loc = (unsigned char) op;
  do { (loc + 1)[0] = (arg1) & 0377; (loc + 1)[1] = (arg1) >> 8; } while (kcov_count(593) || (0) && kcov_then(593));
  do { (loc + 3)[0] = (arg2) & 0377; (loc + 3)[1] = (arg2) >> 8; } while (kcov_count(594) || (0) && kcov_then(594));
}





static void
insert_op1 (op, loc, arg, end)
    re_opcode_t op;
    unsigned char *loc;
    int arg;
    unsigned char *end;
{
  register unsigned char *pfrom = end;
  register unsigned char *pto = end + 3;

  while (kcov_count(595) || (pfrom != loc) && kcov_then(595))
    *--pto = *--pfrom;

  store_op1 (op, loc, arg);
}




static void
insert_op2 (op, loc, arg1, arg2, end)
    re_opcode_t op;
    unsigned char *loc;
    int arg1, arg2;
    unsigned char *end;
{
  register unsigned char *pfrom = end;
  register unsigned char *pto = end + 5;

  while (kcov_count(596) || (pfrom != loc) && kcov_then(596))
    *--pto = *--pfrom;

  store_op2 (op, loc, arg1, arg2);
}






static boolean
at_begline_loc_p (pattern, p, syntax)
    const char *pattern, *p;
    reg_syntax_t syntax;
{
  const char *prev = p - 2;
  boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\';

  return

       (*prev == '(' && (syntax & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) || prev_prev_backslash))

    || (*prev == '|' && (syntax & ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) || prev_prev_backslash));
}





static boolean
at_endline_loc_p (p, pend, syntax)
    const char *p, *pend;
    int syntax;
{
  const char *next = p;
  boolean next_backslash = *next == '\\';
  const char *next_next = kcov_count(597) || (p + 1 < pend) && kcov_then(597) ? p + 1 : ((void *)0);

  return

       (kcov_count(598) || (syntax & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(598) ? *next == ')'
        : next_backslash && next_next && *next_next == ')')

    || (kcov_count(599) || (syntax & ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(599) ? *next == '|'
        : next_backslash && next_next && *next_next == '|');
}





static boolean
group_in_compile_stack (compile_stack, regnum)
    compile_stack_type compile_stack;
    regnum_t regnum;
{
  int this_element;

  for (this_element = compile_stack.avail - 1;
       kcov_count(600) || (this_element >= 0) && kcov_then(600);
       this_element--)
    if (kcov_count(601) || (compile_stack.stack[this_element].regnum == regnum) && kcov_then(601))
      return 1;

  return 0;
}
# 3850 "grep.c"
static reg_errcode_t
compile_range (p_ptr, pend, translate, syntax, b)
    const char **p_ptr, *pend;
    char *translate;
    reg_syntax_t syntax;
    unsigned char *b;
{
  unsigned this_char;

  const char *p = *p_ptr;
  int range_start, range_end;

  if (kcov_count(602) || (p == pend) && kcov_then(602))
    return REG_ERANGE;
# 3872 "grep.c"
  range_start = ((unsigned char *) p)[-2];
  range_end = ((unsigned char *) p)[0];



  (*p_ptr)++;


  if (kcov_count(603) || (range_start > range_end) && kcov_then(603))
    return kcov_count(604) || (syntax & (((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(604) ? REG_ERANGE : REG_NOERROR;





  for (this_char = range_start; kcov_count(605) || (this_char <= range_end) && kcov_then(605); this_char++)
    {
      (b[((unsigned char) ((kcov_count(606) || (translate) && kcov_then(606) ? translate[(unsigned char) (this_char)] : (this_char)))) / 8] |= 1 << (((unsigned char) (kcov_count(607) || (translate) && kcov_then(607) ? translate[(unsigned char) (this_char)] : (this_char))) % 8));
    }

  return REG_NOERROR;
}
# 3911 "grep.c"
int re_max_failures = 2000;

typedef const unsigned char *fail_stack_elt_t;

typedef struct
{
  fail_stack_elt_t *stack;
  unsigned size;
  unsigned avail;
} fail_stack_type;
# 4182 "grep.c"
int
re_compile_fastmap (bufp)
     struct re_pattern_buffer *bufp;
{
  int j, k;
  fail_stack_type fail_stack;

  char *destination;


  unsigned num_regs = 0;

  register char *fastmap = bufp->fastmap;
  unsigned char *pattern = bufp->buffer;
  unsigned long size = bufp->used;
  const unsigned char *p = pattern;
  register unsigned char *pend = pattern + size;





  boolean path_can_be_null = 1;


  boolean succeed_n_p = 0;

  ;

  do { fail_stack.stack = (fail_stack_elt_t *) alloca (5 * sizeof (fail_stack_elt_t)); if (kcov_count(609) || (fail_stack.stack == ((void *)0)) && kcov_then(609)) return -2; fail_stack.size = 5; fail_stack.avail = 0; } while (kcov_count(608) || (0) && kcov_then(608));
  memset ((fastmap), 0, (1 << 8));
  bufp->fastmap_accurate = 1;
  bufp->can_be_null = 0;

  while (kcov_count(610) || (p != pend || !(fail_stack.avail == 0)) && kcov_then(610))
    {
      if (kcov_count(611) || (p == pend) && kcov_then(611))
        {
          bufp->can_be_null |= path_can_be_null;


          path_can_be_null = 1;

          p = fail_stack.stack[--fail_stack.avail];
 }


      ;




      switch ((re_opcode_t) *p++)

 {






 case duplicate:kcov_count(612);
kcov_then(612);

   bufp->can_be_null = 1;
          return 0;





 case exactn:kcov_count(613);
kcov_then(613);

          fastmap[p[1]] = 1;
   break;


        case charset:kcov_count(614);
kcov_then(614);

          for (j = *p++ * 8 - 1; kcov_count(615) || (j >= 0) && kcov_then(615); j--)
     if (kcov_count(616) || (p[j / 8] & (1 << (j % 8))) && kcov_then(616))
              fastmap[j] = 1;
   break;


 case charset_not:kcov_count(617);
kcov_then(617);


   for (j = *p * 8; kcov_count(618) || (j < (1 << 8)) && kcov_then(618); j++)
            fastmap[j] = 1;

   for (j = *p++ * 8 - 1; kcov_count(619) || (j >= 0) && kcov_then(619); j--)
     if (kcov_count(620) || (!(p[j / 8] & (1 << (j % 8)))) && kcov_then(620))
              fastmap[j] = 1;
          break;


 case wordchar:kcov_count(621);
kcov_then(621);

   for (j = 0; kcov_count(622) || (j < (1 << 8)) && kcov_then(622); j++)
     if (kcov_count(623) || (re_syntax_table[j] == 1) && kcov_then(623))
       fastmap[j] = 1;
   break;


 case notwordchar:kcov_count(624);
kcov_then(624);

   for (j = 0; kcov_count(625) || (j < (1 << 8)) && kcov_then(625); j++)
     if (kcov_count(626) || (re_syntax_table[j] != 1) && kcov_then(626))
       fastmap[j] = 1;
   break;


        case anychar:kcov_count(627);
kcov_then(627);


   for (j = 0; kcov_count(628) || (j < (1 << 8)) && kcov_then(628); j++)
            fastmap[j] = 1;


          if (kcov_count(629) || (!(bufp->syntax & (((((((1) << 1) << 1) << 1) << 1) << 1) << 1))) && kcov_then(629))
            fastmap['\n'] = 0;



   else if (kcov_count(630) || (bufp->can_be_null) && kcov_then(630))
     return 0;


   break;
# 4334 "grep.c"
        case no_op:kcov_count(631);
kcov_then(631);

        case begline:kcov_count(632);
kcov_then(632);

        case endline:kcov_count(633);
kcov_then(633);

 case begbuf:kcov_count(634);
kcov_then(634);

 case endbuf:kcov_count(635);
kcov_then(635);

 case wordbound:kcov_count(636);
kcov_then(636);

 case notwordbound:kcov_count(637);
kcov_then(637);

 case wordbeg:kcov_count(638);
kcov_then(638);

 case wordend:kcov_count(639);
kcov_then(639);

        case push_dummy_failure:kcov_count(640);
kcov_then(640);

          continue;


 case jump_n:kcov_count(641);
kcov_then(641);

        case pop_failure_jump:kcov_count(642);
kcov_then(642);

 case maybe_pop_jump:kcov_count(643);
kcov_then(643);

 case jump:kcov_count(644);
kcov_then(644);

        case jump_past_alt:kcov_count(645);
kcov_then(645);

 case dummy_failure_jump:kcov_count(646);
kcov_then(646);

          do { do { (j) = *(p) & 0377; (j) += ((signed char) (*((p) + 1))) << 8; } while (kcov_count(648) || (0) && kcov_then(648)); (p) += 2; } while (kcov_count(647) || (0) && kcov_then(647));
   p += j;
   if (kcov_count(649) || (j > 0) && kcov_then(649))
     continue;






          if (kcov_count(650) || ((re_opcode_t) *p != on_failure_jump
       && (re_opcode_t) *p != succeed_n) && kcov_then(650))
     continue;

          p++;
          do { do { (j) = *(p) & 0377; (j) += ((signed char) (*((p) + 1))) << 8; } while (kcov_count(652) || (0) && kcov_then(652)); (p) += 2; } while (kcov_count(651) || (0) && kcov_then(651));
          p += j;


          if (kcov_count(653) || (!(fail_stack.avail == 0)
       && fail_stack.stack[fail_stack.avail - 1] == p) && kcov_then(653))
            fail_stack.avail--;

          continue;


        case on_failure_jump:kcov_count(654);
kcov_then(654);

        case on_failure_keep_string_jump:kcov_count(655);
kcov_then(655);

 handle_on_failure_jump:
          do { do { (j) = *(p) & 0377; (j) += ((signed char) (*((p) + 1))) << 8; } while (kcov_count(657) || (0) && kcov_then(657)); (p) += 2; } while (kcov_count(656) || (0) && kcov_then(656));
# 4391 "grep.c"
          if (kcov_count(658) || (p + j < pend) && kcov_then(658))
            {
              if (kcov_count(659) || (!(kcov_count(660) || (((fail_stack.avail == fail_stack.size) && !(kcov_count(661) || ((fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4)) && kcov_then(661) ? 0 : ((fail_stack).stack = (fail_stack_elt_t *) (destination = (char *) alloca (((fail_stack).size << 1) * sizeof (fail_stack_elt_t)), memcpy ((destination), ((fail_stack).stack), ((fail_stack).size * sizeof (fail_stack_elt_t))), destination), kcov_count(662) || ((fail_stack).stack == ((void *)0)) && kcov_then(662) ? 0 : ((fail_stack).size <<= 1, 1))))) && kcov_then(660) ? 0 : ((fail_stack).stack[(fail_stack).avail++] = p + j, 1))) && kcov_then(659))
                return -2;
            }
          else
            bufp->can_be_null = 1;

          if (kcov_count(663) || (succeed_n_p) && kcov_then(663))
            {
              do { do { (k) = *(p) & 0377; (k) += ((signed char) (*((p) + 1))) << 8; } while (kcov_count(665) || (0) && kcov_then(665)); (p) += 2; } while (kcov_count(664) || (0) && kcov_then(664));
              succeed_n_p = 0;
     }

          continue;


 case succeed_n:kcov_count(666);
kcov_then(666);


          p += 2;


          do { do { (k) = *(p) & 0377; (k) += ((signed char) (*((p) + 1))) << 8; } while (kcov_count(668) || (0) && kcov_then(668)); (p) += 2; } while (kcov_count(667) || (0) && kcov_then(667));
          if (kcov_count(669) || (k == 0) && kcov_then(669))
     {
              p -= 4;
         succeed_n_p = 1;
              goto handle_on_failure_jump;
            }
          continue;


 case set_number_at:kcov_count(670);
kcov_then(670);

          p += 4;
          continue;


 case start_memory:kcov_count(671);
kcov_then(671);

        case stop_memory:kcov_count(672);
kcov_then(672);

   p += 2;
   continue;


 default:kcov_count(673);
kcov_then(673);

          abort ();
        }







      path_can_be_null = 0;
      p = pend;
    }



  bufp->can_be_null |= path_can_be_null;
  return 0;
}
# 4467 "grep.c"
void
re_set_registers (bufp, regs, num_regs, starts, ends)
    struct re_pattern_buffer *bufp;
    struct re_registers *regs;
    unsigned num_regs;
    regoff_t *starts, *ends;
{
  if (kcov_count(674) || (num_regs) && kcov_then(674))
    {
      bufp->regs_allocated = 1;
      regs->num_regs = num_regs;
      regs->start = starts;
      regs->end = ends;
    }
  else
    {
      bufp->regs_allocated = 0;
      regs->num_regs = 0;
      regs->start = regs->end = (regoff_t) 0;
    }
}






int
re_search (bufp, string, size, startpos, range, regs)
     struct re_pattern_buffer *bufp;
     const char *string;
     int size, startpos, range;
     struct re_registers *regs;
{
  return re_search_2 (bufp, ((void *)0), 0, string, size, startpos, range,
        regs, size);
}
# 4527 "grep.c"
int
re_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs, stop)
     struct re_pattern_buffer *bufp;
     const char *string1, *string2;
     int size1, size2;
     int startpos;
     int range;
     struct re_registers *regs;
     int stop;
{
  int val;
  register char *fastmap = bufp->fastmap;
  register char *translate = bufp->translate;
  int total_size = size1 + size2;
  int endpos = startpos + range;


  if (kcov_count(675) || (startpos < 0 || startpos > total_size) && kcov_then(675))
    return -1;



  if (kcov_count(676) || (endpos < -1) && kcov_then(676))
    range = -1 - startpos;
  else if (kcov_count(677) || (endpos > total_size) && kcov_then(677))
    range = total_size - startpos;



  if (kcov_count(678) || (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == begbuf && range > 0) && kcov_then(678))
    {
      if (kcov_count(679) || (startpos > 0) && kcov_then(679))
 return -1;
      else
 range = 1;
    }


  if (kcov_count(680) || (fastmap && !bufp->fastmap_accurate) && kcov_then(680))
    if (kcov_count(681) || (re_compile_fastmap (bufp) == -2) && kcov_then(681))
      return -2;


  for (;kcov_count(682) || kcov_then(682);)
    {




      if (kcov_count(683) || (fastmap && startpos < total_size && !bufp->can_be_null) && kcov_then(683))
 {
   if (kcov_count(684) || (range > 0) && kcov_then(684))
     {
       register const char *d;
       register int lim = 0;
       int irange = range;

              if (kcov_count(685) || (startpos < size1 && startpos + range >= size1) && kcov_then(685))
                lim = range - (size1 - startpos);

       d = (kcov_count(686) || (startpos >= size1) && kcov_then(686) ? string2 - size1 : string1) + startpos;



       if (kcov_count(687) || (translate) && kcov_then(687))
                while (kcov_count(688) || (range > lim
                       && !fastmap[(unsigned char)
       translate[(unsigned char) *d++]]) && kcov_then(688))
                  range--;
       else
                while (kcov_count(689) || (range > lim && !fastmap[(unsigned char) *d++]) && kcov_then(689))
                  range--;

       startpos += irange - range;
     }
   else
     {
       register char c = (kcov_count(690) || (size1 == 0 || startpos >= size1) && kcov_then(690)
                                 ? string2[startpos - size1]
                                 : string1[startpos]);

       if (kcov_count(691) || (!fastmap[(unsigned char) (kcov_count(692) || (translate) && kcov_then(692) ? translate[(unsigned char) (c)] : (c))]) && kcov_then(691))
  goto advance;
     }
 }


      if (kcov_count(693) || (range >= 0 && startpos == total_size && fastmap
          && !bufp->can_be_null) && kcov_then(693))
 return -1;

      val = re_match_2 (bufp, string1, size1, string2, size2,
                 startpos, regs, stop);
      if (kcov_count(694) || (val >= 0) && kcov_then(694))
 return startpos;

      if (kcov_count(695) || (val == -2) && kcov_then(695))
 return -2;

    advance:
      if (kcov_count(696) || (!range) && kcov_then(696))
        break;
      else if (kcov_count(697) || (range > 0) && kcov_then(697))
        {
          range--;
          startpos++;
        }
      else
        {
          range++;
          startpos--;
        }
    }
  return -1;
}



static int bcmp_translate ();
static boolean alt_match_null_string_p (),
               common_op_match_null_string_p (),
               group_match_null_string_p ();
# 4661 "grep.c"
typedef union
{
  fail_stack_elt_t word;
  struct
  {



    unsigned match_null_string_p : 2;
    unsigned is_active : 1;
    unsigned matched_something : 1;
    unsigned ever_matched_something : 1;
  } bits;
} register_info_type;
# 4786 "grep.c"
int
re_match (bufp, string, size, pos, regs)
     struct re_pattern_buffer *bufp;
     const char *string;
     int size, pos;
     struct re_registers *regs;
 {
  return re_match_2 (bufp, ((void *)0), 0, string, size, pos, regs, size);
}
# 4811 "grep.c"
int
re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
     struct re_pattern_buffer *bufp;
     const char *string1, *string2;
     int size1, size2;
     int pos;
     struct re_registers *regs;
     int stop;
{

  int mcnt;
  unsigned char *p1;


  const char *end1, *end2;



  const char *end_match_1, *end_match_2;


  const char *d, *dend;


  unsigned char *p = bufp->buffer;
  register unsigned char *pend = p + bufp->used;


  char *translate = bufp->translate;
# 4850 "grep.c"
  fail_stack_type fail_stack;
# 4859 "grep.c"
  unsigned num_regs = bufp->re_nsub + 1;


  unsigned lowest_active_reg = ((1 << 8) + 1);
  unsigned highest_active_reg = (1 << 8);
# 4872 "grep.c"
  const char **regstart, **regend;






  const char **old_regstart, **old_regend;







  register_info_type *reg_info;





  unsigned best_regs_set = 0;
  const char **best_regstart, **best_regend;
# 4904 "grep.c"
  const char *match_end = ((void *)0);


  const char **reg_dummy;
  register_info_type *reg_info_dummy;






  ;

  do { fail_stack.stack = (fail_stack_elt_t *) alloca (5 * sizeof (fail_stack_elt_t)); if (kcov_count(699) || (fail_stack.stack == ((void *)0)) && kcov_then(699)) return -2; fail_stack.size = 5; fail_stack.avail = 0; } while (kcov_count(698) || (0) && kcov_then(698));






  if (kcov_count(700) || (bufp->re_nsub) && kcov_then(700))
    {
      regstart = ((const char * *) alloca ((num_regs) * sizeof (const char *)));
      regend = ((const char * *) alloca ((num_regs) * sizeof (const char *)));
      old_regstart = ((const char * *) alloca ((num_regs) * sizeof (const char *)));
      old_regend = ((const char * *) alloca ((num_regs) * sizeof (const char *)));
      best_regstart = ((const char * *) alloca ((num_regs) * sizeof (const char *)));
      best_regend = ((const char * *) alloca ((num_regs) * sizeof (const char *)));
      reg_info = ((register_info_type *) alloca ((num_regs) * sizeof (register_info_type)));
      reg_dummy = ((const char * *) alloca ((num_regs) * sizeof (const char *)));
      reg_info_dummy = ((register_info_type *) alloca ((num_regs) * sizeof (register_info_type)));

      if (kcov_count(701) || (!(regstart && regend && old_regstart && old_regend && reg_info
            && best_regstart && best_regend && reg_dummy && reg_info_dummy)) && kcov_then(701))
        {
          alloca (0);
          return -2;
        }
    }
# 4955 "grep.c"
  if (kcov_count(702) || (pos < 0 || pos > size1 + size2) && kcov_then(702))
    {
      alloca (0);
      return -1;
    }




  for (mcnt = 1; kcov_count(703) || (mcnt < num_regs) && kcov_then(703); mcnt++)
    {
      regstart[mcnt] = regend[mcnt]
        = old_regstart[mcnt] = old_regend[mcnt] = ((char *) -1);

      ((reg_info[mcnt]).bits.match_null_string_p) = 3;
      ((reg_info[mcnt]).bits.is_active) = 0;
      ((reg_info[mcnt]).bits.matched_something) = 0;
      ((reg_info[mcnt]).bits.ever_matched_something) = 0;
    }



  if (kcov_count(704) || (size2 == 0 && string1 != ((void *)0)) && kcov_then(704))
    {
      string2 = string1;
      size2 = size1;
      string1 = 0;
      size1 = 0;
    }
  end1 = string1 + size1;
  end2 = string2 + size2;


  if (kcov_count(705) || (stop <= size1) && kcov_then(705))
    {
      end_match_1 = string1 + stop;
      end_match_2 = string2;
    }
  else
    {
      end_match_1 = end1;
      end_match_2 = string2 + stop - size1;
    }







  if (kcov_count(706) || (size1 > 0 && pos <= size1) && kcov_then(706))
    {
      d = string1 + pos;
      dend = end_match_1;
    }
  else
    {
      d = string2 + pos - size1;
      dend = end_match_2;
    }

  ;
  ;
  ;
  ;
  ;




  for (;kcov_count(707) || kcov_then(707);)
    {
      ;

      if (kcov_count(708) || (p == pend) && kcov_then(708))
 {
          ;



          if (kcov_count(709) || (d != end_match_2) && kcov_then(709))
     {
              ;

              if (kcov_count(710) || (!(fail_stack.avail == 0)) && kcov_then(710))
                {
                  boolean same_str_p = ((size1 && string1 <= (match_end) && (match_end) <= string1 + size1)
                          == (dend == end_match_1));


                  if (kcov_count(711) || (!best_regs_set
                      || (same_str_p && d > match_end)
                      || (!same_str_p && !(dend == end_match_1))) && kcov_then(711))
                    {
                      best_regs_set = 1;
                      match_end = d;

                      ;

                      for (mcnt = 1; kcov_count(712) || (mcnt < num_regs) && kcov_then(712); mcnt++)
                        {
                          best_regstart[mcnt] = regstart[mcnt];
                          best_regend[mcnt] = regend[mcnt];
                        }
                    }
                  goto fail;
                }


              else if (kcov_count(713) || (best_regs_set) && kcov_then(713))
                {
           restore_best_regs:





                  ;

                  d = match_end;
                  dend = (kcov_count(714) || ((d >= string1 && d <= end1)) && kcov_then(714)
             ? end_match_1 : end_match_2);

    for (mcnt = 1; kcov_count(715) || (mcnt < num_regs) && kcov_then(715); mcnt++)
      {
        regstart[mcnt] = best_regstart[mcnt];
        regend[mcnt] = best_regend[mcnt];
      }
                }
            }

          ;


          if (kcov_count(716) || (regs && !bufp->no_sub) && kcov_then(716))
     {

              if (kcov_count(717) || (bufp->regs_allocated == 0) && kcov_then(717))
                {


                  regs->num_regs = (kcov_count(718) || ((30) > (num_regs + 1)) && kcov_then(718) ? (30) : (num_regs + 1));
                  regs->start = ((regoff_t *) malloc ((regs->num_regs) * sizeof (regoff_t)));
                  regs->end = ((regoff_t *) malloc ((regs->num_regs) * sizeof (regoff_t)));
                  if (kcov_count(719) || (regs->start == ((void *)0) || regs->end == ((void *)0)) && kcov_then(719))
                    return -2;
                  bufp->regs_allocated = 1;
                }
              else if (kcov_count(720) || (bufp->regs_allocated == 1) && kcov_then(720))
                {


                  if (kcov_count(721) || (regs->num_regs < num_regs + 1) && kcov_then(721))
                    {
                      regs->num_regs = num_regs + 1;
                      ((regs->start) = (regoff_t *) realloc (regs->start, (regs->num_regs) * sizeof (regoff_t)));
                      ((regs->end) = (regoff_t *) realloc (regs->end, (regs->num_regs) * sizeof (regoff_t)));
                      if (kcov_count(722) || (regs->start == ((void *)0) || regs->end == ((void *)0)) && kcov_then(722))
                        return -2;
                    }
                }
              else
  {


    ;
  }




              if (kcov_count(723) || (regs->num_regs > 0) && kcov_then(723))
                {
                  regs->start[0] = pos;
                  regs->end[0] = (kcov_count(724) || ((dend == end_match_1)) && kcov_then(724) ? d - string1
             : d - string2 + size1);
                }



       for (mcnt = 1; kcov_count(725) || (mcnt < (kcov_count(726) || ((num_regs) < (regs->num_regs)) && kcov_then(726) ? (num_regs) : (regs->num_regs))) && kcov_then(725); mcnt++)
  {
                  if (kcov_count(727) || (((regstart[mcnt]) == ((char *) -1)) || ((regend[mcnt]) == ((char *) -1))) && kcov_then(727))
                    regs->start[mcnt] = regs->end[mcnt] = -1;
                  else
                    {
        regs->start[mcnt] = (kcov_count(728) || ((size1 && string1 <= (regstart[mcnt]) && (regstart[mcnt]) <= string1 + size1)) && kcov_then(728) ? (regstart[mcnt]) - string1 : (regstart[mcnt]) - string2 + size1);
                      regs->end[mcnt] = (kcov_count(729) || ((size1 && string1 <= (regend[mcnt]) && (regend[mcnt]) <= string1 + size1)) && kcov_then(729) ? (regend[mcnt]) - string1 : (regend[mcnt]) - string2 + size1);
                    }
  }






              for (mcnt = num_regs; kcov_count(730) || (mcnt < regs->num_regs) && kcov_then(730); mcnt++)
                regs->start[mcnt] = regs->end[mcnt] = -1;
     }

          alloca (0);
          ;


          ;

          mcnt = d - pos - (kcov_count(731) || ((dend == end_match_1)) && kcov_then(731)
       ? string1
       : string2 - size1);

          ;

          return mcnt;
        }





      switch ((re_opcode_t) *p++)

 {


        case no_op:kcov_count(732);
kcov_then(732);

          ;
          break;





 case exactn:kcov_count(733);
kcov_then(733);

   mcnt = *p++;
          ;



          if (kcov_count(734) || (translate) && kcov_then(734))
     {
       do
  {
    while (kcov_count(736) || (d == dend) && kcov_then(736)) { if (kcov_count(737) || (dend == end_match_2) && kcov_then(737)) goto fail; d = string2; dend = end_match_2; };
    if (kcov_count(738) || (translate[(unsigned char) *d++] != (char) *p++) && kcov_then(738))
                    goto fail;
  }
       while (kcov_count(735) || (--mcnt) && kcov_then(735));
     }
   else
     {
       do
  {
    while (kcov_count(740) || (d == dend) && kcov_then(740)) { if (kcov_count(741) || (dend == end_match_2) && kcov_then(741)) goto fail; d = string2; dend = end_match_2; };
    if (kcov_count(742) || (*d++ != (char) *p++) && kcov_then(742)) goto fail;
  }
       while (kcov_count(739) || (--mcnt) && kcov_then(739));
     }
   do { unsigned r; for (r = lowest_active_reg; kcov_count(744) || (r <= highest_active_reg) && kcov_then(744); r++) { ((reg_info[r]).bits.matched_something) = ((reg_info[r]).bits.ever_matched_something) = 1; } } while (kcov_count(743) || (0) && kcov_then(743));
          break;



 case anychar:kcov_count(745);
kcov_then(745);

          ;

          while (kcov_count(746) || (d == dend) && kcov_then(746)) { if (kcov_count(747) || (dend == end_match_2) && kcov_then(747)) goto fail; d = string2; dend = end_match_2; };

          if (kcov_count(748) || ((!(bufp->syntax & (((((((1) << 1) << 1) << 1) << 1) << 1) << 1)) && (kcov_count(749) || (translate) && kcov_then(749) ? translate[(unsigned char) (*d)] : (*d)) == '\n')
              || (bufp->syntax & ((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) && (kcov_count(750) || (translate) && kcov_then(750) ? translate[(unsigned char) (*d)] : (*d)) == '\000')) && kcov_then(748))
     goto fail;

          do { unsigned r; for (r = lowest_active_reg; kcov_count(752) || (r <= highest_active_reg) && kcov_then(752); r++) { ((reg_info[r]).bits.matched_something) = ((reg_info[r]).bits.ever_matched_something) = 1; } } while (kcov_count(751) || (0) && kcov_then(751));
          ;
          d++;
   break;


 case charset:kcov_count(753);
kcov_then(753);

 case charset_not:kcov_count(754);
kcov_then(754);

   {
     register unsigned char c;
     boolean not = (re_opcode_t) *(p - 1) == charset_not;

            ;

     while (kcov_count(755) || (d == dend) && kcov_then(755)) { if (kcov_count(756) || (dend == end_match_2) && kcov_then(756)) goto fail; d = string2; dend = end_match_2; };
     c = (kcov_count(757) || (translate) && kcov_then(757) ? translate[(unsigned char) (*d)] : (*d));



     if (kcov_count(758) || (c < (unsigned) (*p * 8)
  && p[1 + c / 8] & (1 << (c % 8))) && kcov_then(758))
       not = !not;

     p += 1 + *p;

     if (kcov_count(759) || (!not) && kcov_then(759)) goto fail;

     do { unsigned r; for (r = lowest_active_reg; kcov_count(761) || (r <= highest_active_reg) && kcov_then(761); r++) { ((reg_info[r]).bits.matched_something) = ((reg_info[r]).bits.ever_matched_something) = 1; } } while (kcov_count(760) || (0) && kcov_then(760));
            d++;
     break;
   }







        case start_memory:kcov_count(762);
kcov_then(762);

   ;


   p1 = p;

          if (kcov_count(763) || (((reg_info[*p]).bits.match_null_string_p) == 3) && kcov_then(763))
            ((reg_info[*p]).bits.match_null_string_p)
              = group_match_null_string_p (&p1, pend, reg_info);






          old_regstart[*p] = kcov_count(764) || (((reg_info[*p]).bits.match_null_string_p)) && kcov_then(764)
                             ? kcov_count(765) || (((regstart[*p]) == ((char *) -1))) && kcov_then(765) ? d : regstart[*p]
                             : regstart[*p];
   ;


          regstart[*p] = d;
   ;

          ((reg_info[*p]).bits.is_active) = 1;
          ((reg_info[*p]).bits.matched_something) = 0;


          highest_active_reg = *p;



          if (kcov_count(766) || (lowest_active_reg == ((1 << 8) + 1)) && kcov_then(766))
            lowest_active_reg = *p;


          p += 2;
          break;





 case stop_memory:kcov_count(767);
kcov_then(767);

   ;






          old_regend[*p] = kcov_count(768) || (((reg_info[*p]).bits.match_null_string_p)) && kcov_then(768)
                           ? kcov_count(769) || (((regend[*p]) == ((char *) -1))) && kcov_then(769) ? d : regend[*p]
      : regend[*p];
   ;


          regend[*p] = d;
   ;


          ((reg_info[*p]).bits.is_active) = 0;



          if (kcov_count(770) || (lowest_active_reg == highest_active_reg) && kcov_then(770))
            {
              lowest_active_reg = ((1 << 8) + 1);
              highest_active_reg = (1 << 8);
            }
          else
            {



              unsigned char r = *p - 1;
              while (kcov_count(771) || (r > 0 && !((reg_info[r]).bits.is_active)) && kcov_then(771))
                r--;
# 5350 "grep.c"
       if (kcov_count(772) || (r == 0) && kcov_then(772))
                {
                  lowest_active_reg = ((1 << 8) + 1);
                  highest_active_reg = (1 << 8);
                }
              else
                highest_active_reg = r;
            }






          if (kcov_count(773) || ((!((reg_info[*p]).bits.matched_something)
               || (re_opcode_t) p[-3] == start_memory)
       && (p + 2) < pend) && kcov_then(773))
            {
              boolean is_a_jump_n = 0;

              p1 = p + 2;
              mcnt = 0;
              switch ((re_opcode_t) *p1++)
                {
                  case jump_n:kcov_count(774);
kcov_then(774);

      is_a_jump_n = 1;
                  case pop_failure_jump:kcov_count(775);
kcov_then(775);

    case maybe_pop_jump:kcov_count(776);
kcov_then(776);

    case jump:kcov_count(777);
kcov_then(777);

    case dummy_failure_jump:kcov_count(778);
kcov_then(778);

                    do { do { (mcnt) = *(p1) & 0377; (mcnt) += ((signed char) (*((p1) + 1))) << 8; } while (kcov_count(780) || (0) && kcov_then(780)); (p1) += 2; } while (kcov_count(779) || (0) && kcov_then(779));
      if (kcov_count(781) || (is_a_jump_n) && kcov_then(781))
        p1 += 2;
                    break;

                  default:kcov_count(782);
kcov_then(782);

                                     ;
                }
       p1 += mcnt;






              if (kcov_count(783) || (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump
                  && (re_opcode_t) p1[3] == start_memory && p1[4] == *p) && kcov_then(783))
  {
# 5408 "grep.c"
                  if (kcov_count(784) || (((reg_info[*p]).bits.ever_matched_something)) && kcov_then(784))
      {
        unsigned r;

                      ((reg_info[*p]).bits.ever_matched_something) = 0;


                      for (r = *p; kcov_count(785) || (r < *p + *(p + 1)) && kcov_then(785); r++)
                        {
                          regstart[r] = old_regstart[r];


                          if (kcov_count(786) || ((int) old_regend[r] >= (int) regstart[r]) && kcov_then(786))
                            regend[r] = old_regend[r];
                        }
                    }
    p1++;
                  do { do { (mcnt) = *(p1) & 0377; (mcnt) += ((signed char) (*((p1) + 1))) << 8; } while (kcov_count(788) || (0) && kcov_then(788)); (p1) += 2; } while (kcov_count(787) || (0) && kcov_then(787));
                  do { char *destination; int this_reg; ; ; ; ; ; ; ; while (kcov_count(790) || (((fail_stack).size - (fail_stack).avail) < ((highest_active_reg - lowest_active_reg + 1) * 3 + 4)) && kcov_then(790)) { if (kcov_count(791) || (!(kcov_count(792) || ((fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4)) && kcov_then(792) ? 0 : ((fail_stack).stack = (fail_stack_elt_t *) (destination = (char *) alloca (((fail_stack).size << 1) * sizeof (fail_stack_elt_t)), memcpy ((destination), ((fail_stack).stack), ((fail_stack).size * sizeof (fail_stack_elt_t))), destination), kcov_count(793) || ((fail_stack).stack == ((void *)0)) && kcov_then(793) ? 0 : ((fail_stack).size <<= 1, 1)))) && kcov_then(791)) return -2; ; ; } ; for (this_reg = lowest_active_reg; kcov_count(794) || (this_reg <= highest_active_reg) && kcov_then(794); this_reg++) { ; ; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) regstart[this_reg]; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) regend[this_reg]; ; ; ; ; ; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) reg_info[this_reg].word; } ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) lowest_active_reg; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) highest_active_reg; ; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) p1 + mcnt; ; ; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) d; ; ; } while (kcov_count(789) || (0) && kcov_then(789));

                  goto fail;
                }
            }


          p += 2;
          break;




        case duplicate:kcov_count(795);
kcov_then(795);

   {
     register const char *d2, *dend2;
     int regno = *p++;
     ;


            if (kcov_count(796) || (((regstart[regno]) == ((char *) -1)) || ((regend[regno]) == ((char *) -1))) && kcov_then(796))
              goto fail;


            d2 = regstart[regno];






            dend2 = (kcov_count(797) || (((size1 && string1 <= (regstart[regno]) && (regstart[regno]) <= string1 + size1)
        == (size1 && string1 <= (regend[regno]) && (regend[regno]) <= string1 + size1))) && kcov_then(797)
       ? regend[regno] : end_match_1);
     for (;kcov_count(798) || kcov_then(798);)
       {


  while (kcov_count(799) || (d2 == dend2) && kcov_then(799))
    {
      if (kcov_count(800) || (dend2 == end_match_2) && kcov_then(800)) break;
      if (kcov_count(801) || (dend2 == regend[regno]) && kcov_then(801)) break;


                    d2 = string2;
                    dend2 = regend[regno];
    }

  if (kcov_count(802) || (d2 == dend2) && kcov_then(802)) break;


  while (kcov_count(803) || (d == dend) && kcov_then(803)) { if (kcov_count(804) || (dend == end_match_2) && kcov_then(804)) goto fail; d = string2; dend = end_match_2; };


  mcnt = dend - d;



                if (kcov_count(805) || (mcnt > dend2 - d2) && kcov_then(805))
    mcnt = dend2 - d2;



  if (kcov_count(806) || (kcov_count(807) || (translate) && kcov_then(807)
                    ? bcmp_translate (d, d2, mcnt, translate)
                    : memcmp ((d), (d2), (mcnt))) && kcov_then(806))
    goto fail;
  d += mcnt, d2 += mcnt;
       }
   }
   break;





 case begline:kcov_count(808);
kcov_then(808);

          ;

          if (kcov_count(809) || (((d) == (kcov_count(810) || (size1) && kcov_then(810) ? string1 : string2) || !size2)) && kcov_then(809))
            {
              if (kcov_count(811) || (!bufp->not_bol) && kcov_then(811)) break;
            }
          else if (kcov_count(812) || (d[-1] == '\n' && bufp->newline_anchor) && kcov_then(812))
            {
              break;
            }

          goto fail;



 case endline:kcov_count(813);
kcov_then(813);

          ;

          if (kcov_count(814) || (((d) == end2)) && kcov_then(814))
            {
              if (kcov_count(815) || (!bufp->not_eol) && kcov_then(815)) break;
            }


          else if (kcov_count(816) || ((kcov_count(817) || (d == end1) && kcov_then(817) ? *string2 : *d) == '\n'
                   && bufp->newline_anchor) && kcov_then(816))
            {
              break;
            }
          goto fail;



        case begbuf:kcov_count(818);
kcov_then(818);

          ;
          if (kcov_count(819) || (((d) == (kcov_count(820) || (size1) && kcov_then(820) ? string1 : string2) || !size2)) && kcov_then(819))
            break;
          goto fail;



        case endbuf:kcov_count(821);
kcov_then(821);

          ;
   if (kcov_count(822) || (((d) == end2)) && kcov_then(822))
     break;
          goto fail;
# 5567 "grep.c"
        case on_failure_keep_string_jump:kcov_count(823);
kcov_then(823);

          ;

          do { do { (mcnt) = *(p) & 0377; (mcnt) += ((signed char) (*((p) + 1))) << 8; } while (kcov_count(825) || (0) && kcov_then(825)); (p) += 2; } while (kcov_count(824) || (0) && kcov_then(824));
          ;

          do { char *destination; int this_reg; ; ; ; ; ; ; ; while (kcov_count(827) || (((fail_stack).size - (fail_stack).avail) < ((highest_active_reg - lowest_active_reg + 1) * 3 + 4)) && kcov_then(827)) { if (kcov_count(828) || (!(kcov_count(829) || ((fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4)) && kcov_then(829) ? 0 : ((fail_stack).stack = (fail_stack_elt_t *) (destination = (char *) alloca (((fail_stack).size << 1) * sizeof (fail_stack_elt_t)), memcpy ((destination), ((fail_stack).stack), ((fail_stack).size * sizeof (fail_stack_elt_t))), destination), kcov_count(830) || ((fail_stack).stack == ((void *)0)) && kcov_then(830) ? 0 : ((fail_stack).size <<= 1, 1)))) && kcov_then(828)) return -2; ; ; } ; for (this_reg = lowest_active_reg; kcov_count(831) || (this_reg <= highest_active_reg) && kcov_then(831); this_reg++) { ; ; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) regstart[this_reg]; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) regend[this_reg]; ; ; ; ; ; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) reg_info[this_reg].word; } ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) lowest_active_reg; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) highest_active_reg; ; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) p + mcnt; ; ; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) ((void *)0); ; ; } while (kcov_count(826) || (0) && kcov_then(826));
          break;
# 5589 "grep.c"
 case on_failure_jump:kcov_count(832);
kcov_then(832);

        on_failure:
          ;

          do { do { (mcnt) = *(p) & 0377; (mcnt) += ((signed char) (*((p) + 1))) << 8; } while (kcov_count(834) || (0) && kcov_then(834)); (p) += 2; } while (kcov_count(833) || (0) && kcov_then(833));
          ;
# 5605 "grep.c"
          p1 = p;





          while (kcov_count(835) || (p1 < pend && (re_opcode_t) *p1 == no_op) && kcov_then(835))
            p1++;

          if (kcov_count(836) || (p1 < pend && (re_opcode_t) *p1 == start_memory) && kcov_then(836))
            {




              highest_active_reg = *(p1 + 1) + *(p1 + 2);
              if (kcov_count(837) || (lowest_active_reg == ((1 << 8) + 1)) && kcov_then(837))
                lowest_active_reg = *(p1 + 1);
            }

          ;
          do { char *destination; int this_reg; ; ; ; ; ; ; ; while (kcov_count(839) || (((fail_stack).size - (fail_stack).avail) < ((highest_active_reg - lowest_active_reg + 1) * 3 + 4)) && kcov_then(839)) { if (kcov_count(840) || (!(kcov_count(841) || ((fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4)) && kcov_then(841) ? 0 : ((fail_stack).stack = (fail_stack_elt_t *) (destination = (char *) alloca (((fail_stack).size << 1) * sizeof (fail_stack_elt_t)), memcpy ((destination), ((fail_stack).stack), ((fail_stack).size * sizeof (fail_stack_elt_t))), destination), kcov_count(842) || ((fail_stack).stack == ((void *)0)) && kcov_then(842) ? 0 : ((fail_stack).size <<= 1, 1)))) && kcov_then(840)) return -2; ; ; } ; for (this_reg = lowest_active_reg; kcov_count(843) || (this_reg <= highest_active_reg) && kcov_then(843); this_reg++) { ; ; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) regstart[this_reg]; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) regend[this_reg]; ; ; ; ; ; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) reg_info[this_reg].word; } ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) lowest_active_reg; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) highest_active_reg; ; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) p + mcnt; ; ; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) d; ; ; } while (kcov_count(838) || (0) && kcov_then(838));
          break;




        case maybe_pop_jump:kcov_count(844);
kcov_then(844);

          do { do { (mcnt) = *(p) & 0377; (mcnt) += ((signed char) (*((p) + 1))) << 8; } while (kcov_count(846) || (0) && kcov_then(846)); (p) += 2; } while (kcov_count(845) || (0) && kcov_then(845));
          ;
          {
     register unsigned char *p2 = p;
# 5652 "grep.c"
     while (kcov_count(847) || (p2 + 2 < pend
     && ((re_opcode_t) *p2 == stop_memory
         || (re_opcode_t) *p2 == start_memory)) && kcov_then(847))
       p2 += 3;


            if (kcov_count(848) || (p2 == pend) && kcov_then(848))
       {



           p[-3] = (unsigned char) pop_failure_jump;
                ;

              }

            else if (kcov_count(849) || ((re_opcode_t) *p2 == exactn
       || (bufp->newline_anchor && (re_opcode_t) *p2 == endline)) && kcov_then(849))
       {
  register unsigned char c
                  = kcov_count(850) || (*p2 == (unsigned char) endline) && kcov_then(850) ? '\n' : p2[2];
  p1 = p + mcnt;




                if (kcov_count(851) || ((re_opcode_t) p1[3] == exactn && p1[5] != c) && kcov_then(851))
                  {
        p[-3] = (unsigned char) pop_failure_jump;
                    ;

                  }

  else if (kcov_count(852) || ((re_opcode_t) p1[3] == charset
    || (re_opcode_t) p1[3] == charset_not) && kcov_then(852))
    {
      int not = (re_opcode_t) p1[3] == charset_not;

      if (kcov_count(853) || (c < (unsigned char) (p1[4] * 8)
   && p1[5 + c / 8] & (1 << (c % 8))) && kcov_then(853))
        not = !not;



      if (kcov_count(854) || (!not) && kcov_then(854))
                      {
            p[-3] = (unsigned char) pop_failure_jump;
                        ;
                      }
    }
       }
   }
   p -= 2;
   if (kcov_count(855) || ((re_opcode_t) p[-1] != pop_failure_jump) && kcov_then(855))
     {
       p[-1] = (unsigned char) jump;
              ;
       goto unconditional_jump;
     }
# 5720 "grep.c"
        case pop_failure_jump:kcov_count(856);
kcov_then(856);

          {





            unsigned dummy_low_reg, dummy_high_reg;
            unsigned char *pdummy;
            const char *sdummy;

            ;
            { int this_reg; const unsigned char *string_temp; ; ; ; ; ; ; ; string_temp = fail_stack.stack[--fail_stack.avail]; if (kcov_count(857) || (string_temp != ((void *)0)) && kcov_then(857)) sdummy = (const char *) string_temp; ; ; ; pdummy = (unsigned char *) fail_stack.stack[--fail_stack.avail]; ; ; dummy_high_reg = (unsigned) fail_stack.stack[--fail_stack.avail]; ; dummy_low_reg = (unsigned) fail_stack.stack[--fail_stack.avail]; ; for (this_reg = dummy_high_reg; kcov_count(858) || (this_reg >= dummy_low_reg) && kcov_then(858); this_reg--) { ; reg_info_dummy[this_reg].word = fail_stack.stack[--fail_stack.avail]; ; reg_dummy[this_reg] = (const char *) fail_stack.stack[--fail_stack.avail]; ; reg_dummy[this_reg] = (const char *) fail_stack.stack[--fail_stack.avail]; ; } ; };


          }




        case jump:kcov_count(859);
kcov_then(859);

 unconditional_jump:
   do { do { (mcnt) = *(p) & 0377; (mcnt) += ((signed char) (*((p) + 1))) << 8; } while (kcov_count(861) || (0) && kcov_then(861)); (p) += 2; } while (kcov_count(860) || (0) && kcov_then(860));
          ;
   p += mcnt;
          ;
   break;




        case jump_past_alt:kcov_count(862);
kcov_then(862);

          ;
          goto unconditional_jump;







        case dummy_failure_jump:kcov_count(863);
kcov_then(863);

          ;


          do { char *destination; int this_reg; ; ; ; ; ; ; ; while (kcov_count(865) || (((fail_stack).size - (fail_stack).avail) < ((highest_active_reg - lowest_active_reg + 1) * 3 + 4)) && kcov_then(865)) { if (kcov_count(866) || (!(kcov_count(867) || ((fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4)) && kcov_then(867) ? 0 : ((fail_stack).stack = (fail_stack_elt_t *) (destination = (char *) alloca (((fail_stack).size << 1) * sizeof (fail_stack_elt_t)), memcpy ((destination), ((fail_stack).stack), ((fail_stack).size * sizeof (fail_stack_elt_t))), destination), kcov_count(868) || ((fail_stack).stack == ((void *)0)) && kcov_then(868) ? 0 : ((fail_stack).size <<= 1, 1)))) && kcov_then(866)) return -2; ; ; } ; for (this_reg = lowest_active_reg; kcov_count(869) || (this_reg <= highest_active_reg) && kcov_then(869); this_reg++) { ; ; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) regstart[this_reg]; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) regend[this_reg]; ; ; ; ; ; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) reg_info[this_reg].word; } ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) lowest_active_reg; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) highest_active_reg; ; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) 0; ; ; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) 0; ; ; } while (kcov_count(864) || (0) && kcov_then(864));
          goto unconditional_jump;







        case push_dummy_failure:kcov_count(870);
kcov_then(870);

          ;


          do { char *destination; int this_reg; ; ; ; ; ; ; ; while (kcov_count(872) || (((fail_stack).size - (fail_stack).avail) < ((highest_active_reg - lowest_active_reg + 1) * 3 + 4)) && kcov_then(872)) { if (kcov_count(873) || (!(kcov_count(874) || ((fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4)) && kcov_then(874) ? 0 : ((fail_stack).stack = (fail_stack_elt_t *) (destination = (char *) alloca (((fail_stack).size << 1) * sizeof (fail_stack_elt_t)), memcpy ((destination), ((fail_stack).stack), ((fail_stack).size * sizeof (fail_stack_elt_t))), destination), kcov_count(875) || ((fail_stack).stack == ((void *)0)) && kcov_then(875) ? 0 : ((fail_stack).size <<= 1, 1)))) && kcov_then(873)) return -2; ; ; } ; for (this_reg = lowest_active_reg; kcov_count(876) || (this_reg <= highest_active_reg) && kcov_then(876); this_reg++) { ; ; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) regstart[this_reg]; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) regend[this_reg]; ; ; ; ; ; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) reg_info[this_reg].word; } ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) lowest_active_reg; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) highest_active_reg; ; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) 0; ; ; ; fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) 0; ; ; } while (kcov_count(871) || (0) && kcov_then(871));
          break;



        case succeed_n:kcov_count(877);
kcov_then(877);

          do { (mcnt) = *(p + 2) & 0377; (mcnt) += ((signed char) (*((p + 2) + 1))) << 8; } while (kcov_count(878) || (0) && kcov_then(878));
          ;

          ;

          if (kcov_count(879) || (mcnt > 0) && kcov_then(879))
            {
               mcnt--;
        p += 2;
               do { do { (p)[0] = (mcnt) & 0377; (p)[1] = (mcnt) >> 8; } while (kcov_count(881) || (0) && kcov_then(881)); (p) += 2; } while (kcov_count(880) || (0) && kcov_then(880));
               ;
            }
   else if (kcov_count(882) || (mcnt == 0) && kcov_then(882))
            {
              ;
       p[2] = (unsigned char) no_op;
              p[3] = (unsigned char) no_op;
              goto on_failure;
            }
          break;

        case jump_n:kcov_count(883);
kcov_then(883);

          do { (mcnt) = *(p + 2) & 0377; (mcnt) += ((signed char) (*((p + 2) + 1))) << 8; } while (kcov_count(884) || (0) && kcov_then(884));
          ;


          if (kcov_count(885) || (mcnt) && kcov_then(885))
            {
               mcnt--;
               do { (p + 2)[0] = (mcnt) & 0377; (p + 2)[1] = (mcnt) >> 8; } while (kcov_count(886) || (0) && kcov_then(886));
        goto unconditional_jump;
            }

   else
     p += 4;
          break;

 case set_number_at:kcov_count(887);
kcov_then(887);

   {
            ;

            do { do { (mcnt) = *(p) & 0377; (mcnt) += ((signed char) (*((p) + 1))) << 8; } while (kcov_count(889) || (0) && kcov_then(889)); (p) += 2; } while (kcov_count(888) || (0) && kcov_then(888));
            p1 = p + mcnt;
            do { do { (mcnt) = *(p) & 0377; (mcnt) += ((signed char) (*((p) + 1))) << 8; } while (kcov_count(891) || (0) && kcov_then(891)); (p) += 2; } while (kcov_count(890) || (0) && kcov_then(890));
            ;
     do { (p1)[0] = (mcnt) & 0377; (p1)[1] = (mcnt) >> 8; } while (kcov_count(892) || (0) && kcov_then(892));
            break;
          }

        case wordbound:kcov_count(893);
kcov_then(893);

          ;
          if (kcov_count(894) || ((((d) == (kcov_count(895) || (size1) && kcov_then(895) ? string1 : string2) || !size2) || ((d) == end2) || (re_syntax_table[kcov_count(896) || ((d - 1) == end1) && kcov_then(896) ? *string2 : kcov_count(897) || ((d - 1) == string2 - 1) && kcov_then(897) ? *(end1 - 1) : *(d - 1)] == 1) != (re_syntax_table[kcov_count(898) || ((d) == end1) && kcov_then(898) ? *string2 : kcov_count(899) || ((d) == string2 - 1) && kcov_then(899) ? *(end1 - 1) : *(d)] == 1))) && kcov_then(894))
     break;
          goto fail;

 case notwordbound:kcov_count(900);
kcov_then(900);

          ;
   if (kcov_count(901) || ((((d) == (kcov_count(902) || (size1) && kcov_then(902) ? string1 : string2) || !size2) || ((d) == end2) || (re_syntax_table[kcov_count(903) || ((d - 1) == end1) && kcov_then(903) ? *string2 : kcov_count(904) || ((d - 1) == string2 - 1) && kcov_then(904) ? *(end1 - 1) : *(d - 1)] == 1) != (re_syntax_table[kcov_count(905) || ((d) == end1) && kcov_then(905) ? *string2 : kcov_count(906) || ((d) == string2 - 1) && kcov_then(906) ? *(end1 - 1) : *(d)] == 1))) && kcov_then(901))
     goto fail;
          break;

 case wordbeg:kcov_count(907);
kcov_then(907);

          ;
   if (kcov_count(908) || ((re_syntax_table[kcov_count(909) || ((d) == end1) && kcov_then(909) ? *string2 : kcov_count(910) || ((d) == string2 - 1) && kcov_then(910) ? *(end1 - 1) : *(d)] == 1) && (((d) == (kcov_count(911) || (size1) && kcov_then(911) ? string1 : string2) || !size2) || !(re_syntax_table[kcov_count(912) || ((d - 1) == end1) && kcov_then(912) ? *string2 : kcov_count(913) || ((d - 1) == string2 - 1) && kcov_then(913) ? *(end1 - 1) : *(d - 1)] == 1))) && kcov_then(908))
     break;
          goto fail;

 case wordend:kcov_count(914);
kcov_then(914);

          ;
   if (kcov_count(915) || (!((d) == (kcov_count(916) || (size1) && kcov_then(916) ? string1 : string2) || !size2) && (re_syntax_table[kcov_count(917) || ((d - 1) == end1) && kcov_then(917) ? *string2 : kcov_count(918) || ((d - 1) == string2 - 1) && kcov_then(918) ? *(end1 - 1) : *(d - 1)] == 1)
              && (!(re_syntax_table[kcov_count(919) || ((d) == end1) && kcov_then(919) ? *string2 : kcov_count(920) || ((d) == string2 - 1) && kcov_then(920) ? *(end1 - 1) : *(d)] == 1) || ((d) == end2))) && kcov_then(915))
     break;
          goto fail;
# 5916 "grep.c"
 case wordchar:kcov_count(921);
kcov_then(921);

          ;
   while (kcov_count(922) || (d == dend) && kcov_then(922)) { if (kcov_count(923) || (dend == end_match_2) && kcov_then(923)) goto fail; d = string2; dend = end_match_2; };
          if (kcov_count(924) || (!(re_syntax_table[kcov_count(925) || ((d) == end1) && kcov_then(925) ? *string2 : kcov_count(926) || ((d) == string2 - 1) && kcov_then(926) ? *(end1 - 1) : *(d)] == 1)) && kcov_then(924))
            goto fail;
   do { unsigned r; for (r = lowest_active_reg; kcov_count(928) || (r <= highest_active_reg) && kcov_then(928); r++) { ((reg_info[r]).bits.matched_something) = ((reg_info[r]).bits.ever_matched_something) = 1; } } while (kcov_count(927) || (0) && kcov_then(927));
          d++;
   break;

 case notwordchar:kcov_count(929);
kcov_then(929);

          ;
   while (kcov_count(930) || (d == dend) && kcov_then(930)) { if (kcov_count(931) || (dend == end_match_2) && kcov_then(931)) goto fail; d = string2; dend = end_match_2; };
   if (kcov_count(932) || ((re_syntax_table[kcov_count(933) || ((d) == end1) && kcov_then(933) ? *string2 : kcov_count(934) || ((d) == string2 - 1) && kcov_then(934) ? *(end1 - 1) : *(d)] == 1)) && kcov_then(932))
            goto fail;
          do { unsigned r; for (r = lowest_active_reg; kcov_count(936) || (r <= highest_active_reg) && kcov_then(936); r++) { ((reg_info[r]).bits.matched_something) = ((reg_info[r]).bits.ever_matched_something) = 1; } } while (kcov_count(935) || (0) && kcov_then(935));
          d++;
   break;


        default:kcov_count(937);
kcov_then(937);

          abort ();
 }
      continue;



    fail:
      if (kcov_count(938) || (!(fail_stack.avail == 0)) && kcov_then(938))
 {
          ;
          { int this_reg; const unsigned char *string_temp; ; ; ; ; ; ; ; string_temp = fail_stack.stack[--fail_stack.avail]; if (kcov_count(939) || (string_temp != ((void *)0)) && kcov_then(939)) d = (const char *) string_temp; ; ; ; p = (unsigned char *) fail_stack.stack[--fail_stack.avail]; ; ; highest_active_reg = (unsigned) fail_stack.stack[--fail_stack.avail]; ; lowest_active_reg = (unsigned) fail_stack.stack[--fail_stack.avail]; ; for (this_reg = highest_active_reg; kcov_count(940) || (this_reg >= lowest_active_reg) && kcov_then(940); this_reg--) { ; reg_info[this_reg].word = fail_stack.stack[--fail_stack.avail]; ; regend[this_reg] = (const char *) fail_stack.stack[--fail_stack.avail]; ; regstart[this_reg] = (const char *) fail_stack.stack[--fail_stack.avail]; ; } ; };




          if (kcov_count(941) || (!p) && kcov_then(941))
     goto fail;


   ;
          if (kcov_count(942) || (p < pend) && kcov_then(942))
            {
              boolean is_a_jump_n = 0;



              switch ((re_opcode_t) *p)
                {
                case jump_n:kcov_count(943);
kcov_then(943);

                  is_a_jump_n = 1;
                case maybe_pop_jump:kcov_count(944);
kcov_then(944);

                case pop_failure_jump:kcov_count(945);
kcov_then(945);

                case jump:kcov_count(946);
kcov_then(946);

                  p1 = p + 1;
                  do { do { (mcnt) = *(p1) & 0377; (mcnt) += ((signed char) (*((p1) + 1))) << 8; } while (kcov_count(948) || (0) && kcov_then(948)); (p1) += 2; } while (kcov_count(947) || (0) && kcov_then(947));
                  p1 += mcnt;

                  if (kcov_count(949) || ((is_a_jump_n && (re_opcode_t) *p1 == succeed_n)
                      || (!is_a_jump_n
                          && (re_opcode_t) *p1 == on_failure_jump)) && kcov_then(949))
                    goto fail;
                  break;
                default:kcov_count(950);
kcov_then(950);

                                   ;
                }
            }

          if (kcov_count(951) || (d >= string1 && d <= end1) && kcov_then(951))
     dend = end_match_1;
        }
      else
        break;
    }

  if (kcov_count(952) || (best_regs_set) && kcov_then(952))
    goto restore_best_regs;

  alloca (0);

  return -1;
}
# 6011 "grep.c"
static boolean
group_match_null_string_p (p, end, reg_info)
    unsigned char **p, *end;
    register_info_type *reg_info;
{
  int mcnt;

  unsigned char *p1 = *p + 2;

  while (kcov_count(953) || (p1 < end) && kcov_then(953))
    {




      switch ((re_opcode_t) *p1)
        {

        case on_failure_jump:kcov_count(954);
kcov_then(954);

          p1++;
          do { do { (mcnt) = *(p1) & 0377; (mcnt) += ((signed char) (*((p1) + 1))) << 8; } while (kcov_count(956) || (0) && kcov_then(956)); (p1) += 2; } while (kcov_count(955) || (0) && kcov_then(955));




   if (kcov_count(957) || (mcnt >= 0) && kcov_then(957))
     {
# 6056 "grep.c"
              while (kcov_count(958) || ((re_opcode_t) p1[mcnt-3] == jump_past_alt) && kcov_then(958))
                {




                  if (kcov_count(959) || (!alt_match_null_string_p (p1, p1 + mcnt - 3,
                          reg_info)) && kcov_then(959))
                    return 0;



                  p1 += mcnt;



                  if (kcov_count(960) || ((re_opcode_t) *p1 != on_failure_jump) && kcov_then(960))
                    break;



    p1++;
                  do { do { (mcnt) = *(p1) & 0377; (mcnt) += ((signed char) (*((p1) + 1))) << 8; } while (kcov_count(962) || (0) && kcov_then(962)); (p1) += 2; } while (kcov_count(961) || (0) && kcov_then(961));
                  if (kcov_count(963) || ((re_opcode_t) p1[mcnt-3] != jump_past_alt) && kcov_then(963))
                    {

                      p1 -= 3;
                      break;
                    }
                }




              do { (mcnt) = *(p1 - 2) & 0377; (mcnt) += ((signed char) (*((p1 - 2) + 1))) << 8; } while (kcov_count(964) || (0) && kcov_then(964));

              if (kcov_count(965) || (!alt_match_null_string_p (p1, p1 + mcnt, reg_info)) && kcov_then(965))
                return 0;

              p1 += mcnt;
            }
          break;


        case stop_memory:kcov_count(966);
kcov_then(966);

   ;
          *p = p1 + 2;
          return 1;


        default:kcov_count(967);
kcov_then(967);

          if (kcov_count(968) || (!common_op_match_null_string_p (&p1, end, reg_info)) && kcov_then(968))
            return 0;
        }
    }

  return 0;
}






static boolean
alt_match_null_string_p (p, end, reg_info)
    unsigned char *p, *end;
    register_info_type *reg_info;
{
  int mcnt;
  unsigned char *p1 = p;

  while (kcov_count(969) || (p1 < end) && kcov_then(969))
    {



      switch ((re_opcode_t) *p1)
        {

        case on_failure_jump:kcov_count(970);
kcov_then(970);

          p1++;
          do { do { (mcnt) = *(p1) & 0377; (mcnt) += ((signed char) (*((p1) + 1))) << 8; } while (kcov_count(972) || (0) && kcov_then(972)); (p1) += 2; } while (kcov_count(971) || (0) && kcov_then(971));
          p1 += mcnt;
          break;

 default:kcov_count(973);
kcov_then(973);

          if (kcov_count(974) || (!common_op_match_null_string_p (&p1, end, reg_info)) && kcov_then(974))
            return 0;
        }
    }

  return 1;
}







static boolean
common_op_match_null_string_p (p, end, reg_info)
    unsigned char **p, *end;
    register_info_type *reg_info;
{
  int mcnt;
  boolean ret;
  int reg_no;
  unsigned char *p1 = *p;

  switch ((re_opcode_t) *p1++)
    {
    case no_op:kcov_count(975);
kcov_then(975);

    case begline:kcov_count(976);
kcov_then(976);

    case endline:kcov_count(977);
kcov_then(977);

    case begbuf:kcov_count(978);
kcov_then(978);

    case endbuf:kcov_count(979);
kcov_then(979);

    case wordbeg:kcov_count(980);
kcov_then(980);

    case wordend:kcov_count(981);
kcov_then(981);

    case wordbound:kcov_count(982);
kcov_then(982);

    case notwordbound:kcov_count(983);
kcov_then(983);






      break;

    case start_memory:kcov_count(984);
kcov_then(984);

      reg_no = *p1;
      ;
      ret = group_match_null_string_p (&p1, end, reg_info);




      if (kcov_count(985) || (((reg_info[reg_no]).bits.match_null_string_p) == 3) && kcov_then(985))
        ((reg_info[reg_no]).bits.match_null_string_p) = ret;

      if (kcov_count(986) || (!ret) && kcov_then(986))
        return 0;
      break;


    case jump:kcov_count(987);
kcov_then(987);

      do { do { (mcnt) = *(p1) & 0377; (mcnt) += ((signed char) (*((p1) + 1))) << 8; } while (kcov_count(989) || (0) && kcov_then(989)); (p1) += 2; } while (kcov_count(988) || (0) && kcov_then(988));
      if (kcov_count(990) || (mcnt >= 0) && kcov_then(990))
        p1 += mcnt;
      else
        return 0;
      break;

    case succeed_n:kcov_count(991);
kcov_then(991);


      p1 += 2;
      do { do { (mcnt) = *(p1) & 0377; (mcnt) += ((signed char) (*((p1) + 1))) << 8; } while (kcov_count(993) || (0) && kcov_then(993)); (p1) += 2; } while (kcov_count(992) || (0) && kcov_then(992));

      if (kcov_count(994) || (mcnt == 0) && kcov_then(994))
        {
          p1 -= 4;
          do { do { (mcnt) = *(p1) & 0377; (mcnt) += ((signed char) (*((p1) + 1))) << 8; } while (kcov_count(996) || (0) && kcov_then(996)); (p1) += 2; } while (kcov_count(995) || (0) && kcov_then(995));
          p1 += mcnt;
        }
      else
        return 0;
      break;

    case duplicate:kcov_count(997);
kcov_then(997);

      if (kcov_count(998) || (!((reg_info[*p1]).bits.match_null_string_p)) && kcov_then(998))
        return 0;
      break;

    case set_number_at:kcov_count(999);
kcov_then(999);

      p1 += 4;

    default:kcov_count(1000);
kcov_then(1000);


      return 0;
  }

  *p = p1;
  return 1;
}





static int
bcmp_translate (s1, s2, len, translate)
     unsigned char *s1, *s2;
     register int len;
     char *translate;
{
  register unsigned char *p1 = s1, *p2 = s2;
  while (kcov_count(1001) || (len) && kcov_then(1001))
    {
      if (kcov_count(1002) || (translate[*p1++] != translate[*p2++]) && kcov_then(1002)) return 1;
      len--;
    }
  return 0;
}
# 6271 "grep.c"
const char *
re_compile_pattern (pattern, length, bufp)
     const char *pattern;
     int length;
     struct re_pattern_buffer *bufp;
{
  reg_errcode_t ret;



  bufp->regs_allocated = 0;




  bufp->no_sub = 0;


  bufp->newline_anchor = 1;

  ret = regex_compile (pattern, length, re_syntax_options, bufp);

  return re_error_msg[(int) ret];
}
# 6390 "grep.c"
int
regcomp (preg, pattern, cflags)
    regex_t *preg;
    const char *pattern;
    int cflags;
{
  reg_errcode_t ret;
  unsigned syntax
    = kcov_count(1003) || ((cflags & 1)) && kcov_then(1003) ?
      (((((1) << 1) << 1) | (((((((1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((1) << 1) << 1) << 1) | (((((1) << 1) << 1) << 1) << 1) | (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) : (((((1) << 1) << 1) | (((((((1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((1) << 1));


  preg->buffer = 0;
  preg->allocated = 0;
  preg->used = 0;





  preg->fastmap = 0;

  if (kcov_count(1004) || (cflags & (1 << 1)) && kcov_then(1004))
    {
      unsigned i;

      preg->translate = (char *) malloc (256);
      if (kcov_count(1005) || (preg->translate == ((void *)0)) && kcov_then(1005))
        return (int) REG_ESPACE;


      for (i = 0; kcov_count(1006) || (i < 256) && kcov_then(1006); i++)
        preg->translate[i] = kcov_count(1007) || ((1 && ((*__ctype_b_loc ())[(int) ((i))] & (unsigned short int) _ISupper))) && kcov_then(1007) ? tolower (i) : i;
    }
  else
    preg->translate = ((void *)0);


  if (kcov_count(1008) || (cflags & ((1 << 1) << 1)) && kcov_then(1008))
    {
      syntax &= ~(((((((1) << 1) << 1) << 1) << 1) << 1) << 1);
      syntax |= (((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);

      preg->newline_anchor = 1;
    }
  else
    preg->newline_anchor = 0;

  preg->no_sub = !!(cflags & (((1 << 1) << 1) << 1));



  ret = regex_compile (pattern, strlen (pattern), syntax, preg);



  if (kcov_count(1009) || (ret == REG_ERPAREN) && kcov_then(1009)) ret = REG_EPAREN;

  return (int) ret;
}
# 6466 "grep.c"
int
regexec (preg, string, nmatch, pmatch, eflags)
    const regex_t *preg;
    const char *string;
    size_t nmatch;
    regmatch_t pmatch[];
    int eflags;
{
  int ret;
  struct re_registers regs;
  regex_t private_preg;
  int len = strlen (string);
  boolean want_reg_info = !preg->no_sub && nmatch > 0;

  private_preg = *preg;

  private_preg.not_bol = !!(eflags & 1);
  private_preg.not_eol = !!(eflags & (1 << 1));




  private_preg.regs_allocated = 2;

  if (kcov_count(1010) || (want_reg_info) && kcov_then(1010))
    {
      regs.num_regs = nmatch;
      regs.start = ((regoff_t *) malloc ((nmatch) * sizeof (regoff_t)));
      regs.end = ((regoff_t *) malloc ((nmatch) * sizeof (regoff_t)));
      if (kcov_count(1011) || (regs.start == ((void *)0) || regs.end == ((void *)0)) && kcov_then(1011))
        return (int) REG_NOMATCH;
    }


  ret = re_search (&private_preg, string, len,
                                0, len,
                   kcov_count(1012) || (want_reg_info) && kcov_then(1012) ? &regs : (struct re_registers *) 0);


  if (kcov_count(1013) || (want_reg_info) && kcov_then(1013))
    {
      if (kcov_count(1014) || (ret >= 0) && kcov_then(1014))
        {
          unsigned r;

          for (r = 0; kcov_count(1015) || (r < nmatch) && kcov_then(1015); r++)
            {
              pmatch[r].rm_so = regs.start[r];
              pmatch[r].rm_eo = regs.end[r];
            }
        }


      free (regs.start);
      free (regs.end);
    }


  return kcov_count(1016) || (ret >= 0) && kcov_then(1016) ? (int) REG_NOERROR : (int) REG_NOMATCH;
}





size_t
regerror (errcode, preg, errbuf, errbuf_size)
    int errcode;
    const regex_t *preg;
    char *errbuf;
    size_t errbuf_size;
{
  const char *msg;
  size_t msg_size;

  if (kcov_count(1017) || (errcode < 0
      || errcode >= (sizeof (re_error_msg) / sizeof (re_error_msg[0]))) && kcov_then(1017))




    abort ();

  msg = re_error_msg[errcode];



  if (kcov_count(1018) || (! msg) && kcov_then(1018))
    msg = "Success";

  msg_size = strlen (msg) + 1;

  if (kcov_count(1019) || (errbuf_size != 0) && kcov_then(1019))
    {
      if (kcov_count(1020) || (msg_size > errbuf_size) && kcov_then(1020))
        {
          strncpy (errbuf, msg, errbuf_size - 1);
          errbuf[errbuf_size - 1] = 0;
        }
      else
        strcpy (errbuf, msg);
    }

  return msg_size;
}




void
regfree (preg)
    regex_t *preg;
{
  if (kcov_count(1021) || (preg->buffer != ((void *)0)) && kcov_then(1021))
    free (preg->buffer);
  preg->buffer = ((void *)0);

  preg->allocated = 0;
  preg->used = 0;

  if (kcov_count(1022) || (preg->fastmap != ((void *)0)) && kcov_then(1022))
    free (preg->fastmap);
  preg->fastmap = ((void *)0);
  preg->fastmap_accurate = 0;

  if (kcov_count(1023) || (preg->translate != ((void *)0)) && kcov_then(1023))
    free (preg->translate);
  preg->translate = ((void *)0);
}
# 6700 "grep.c"
# 1 "dfa.h" 1
# 38 "dfa.h"
typedef int charclass[(((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int)))];





typedef enum
{
  END = -1,







  EMPTY = (1 << 8),


  BACKREF,






  BEGLINE,



  ENDLINE,



  BEGWORD,



  ENDWORD,



  LIMWORD,



  NOTLIMWORD,



  QMARK,



  STAR,



  PLUS,



  REPMN,



  CAT,




  OR,


  ORTOP,


  LPAREN,


  RPAREN,

  CSET


} token;
# 182 "dfa.h"
typedef struct
{
  unsigned strchr;
  unsigned constraint;
} position;


typedef struct
{
  position *elems;
  int nelem;
} position_set;




typedef struct
{
  int hash;
  position_set elems;
  char newline;
  char letter;
  char backref;
  unsigned char constraint;
  int first_end;
} dfa_state;



struct dfamust
{
  int exact;
  char *must;
  struct dfamust *next;
};


struct dfa
{

  charclass *charclasses;
  int cindex;
  int calloc;


  token *tokens;
  int tindex;
  int talloc;
  int depth;


  int nleaves;
  int nregexps;



  dfa_state *states;
  int sindex;
  int salloc;


  position_set *follows;






  int searchflag;
# 259 "dfa.h"
  int tralloc;

  int trcount;

  int **trans;




  int **realtrans;

  int **fails;

  int *success;

  int *newlines;






  struct dfamust *musts;


};
# 308 "dfa.h"
extern void dfasyntax(int, int);




extern void dfacomp(char *, size_t, struct dfa *, int);
# 327 "dfa.h"
extern char *dfaexec(struct dfa *, char *, char *, int, int *, int *);


extern void dfafree(struct dfa *);




extern void dfainit(struct dfa *);


extern void dfaparse(char *, size_t, struct dfa *);



extern void dfaanalyze(struct dfa *, int);



extern void dfastate(int, struct dfa *, int []);







extern void dfaerror(char *);
# 6701 "grep.c" 2



typedef void *ptr_t;




static void dfamust();

static ptr_t
xcalloc(n, s)
     int n;
     size_t s;
{
  ptr_t r = calloc(n, s);

  if (kcov_count(1024) || (!r) && kcov_then(1024))
    dfaerror("Memory exhausted");
  return r;
}

static ptr_t
xmalloc_1(n)
     size_t n;
{
  ptr_t r = malloc(n);

  ;
  if (kcov_count(1025) || (!r) && kcov_then(1025))
    dfaerror("Memory exhausted");
  return r;
}

static ptr_t
xrealloc_1(p, n)
     ptr_t p;
     size_t n;
{
  ptr_t r = realloc(p, n);

  ;
  if (kcov_count(1026) || (!r) && kcov_then(1026))
    dfaerror("Memory exhausted");
  return r;
}
# 6802 "grep.c"
static int
tstbit(b, c)
     int b;
     charclass c;
{
  return c[b / (8 * sizeof (int))] & 1 << b % (8 * sizeof (int));
}

static void
setbit(b, c)
     int b;
     charclass c;
{
  c[b / (8 * sizeof (int))] |= 1 << b % (8 * sizeof (int));
}

static void
clrbit(b, c)
     int b;
     charclass c;
{
  c[b / (8 * sizeof (int))] &= ~(1 << b % (8 * sizeof (int)));
}

static void
copyset(src, dst)
     charclass src;
     charclass dst;
{
  int i;

  for (i = 0; kcov_count(1027) || (i < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int)))) && kcov_then(1027); ++i)
    dst[i] = src[i];
}

static void
zeroset(s)
     charclass s;
{
  int i;

  for (i = 0; kcov_count(1028) || (i < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int)))) && kcov_then(1028); ++i)
    s[i] = 0;
}

static void
notset(s)
     charclass s;
{
  int i;

  for (i = 0; kcov_count(1029) || (i < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int)))) && kcov_then(1029); ++i)
    s[i] = ~s[i];
}

static int
equal(s1, s2)
     charclass s1;
     charclass s2;
{
  int i;

  for (i = 0; kcov_count(1030) || (i < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int)))) && kcov_then(1030); ++i)
    if (kcov_count(1031) || (s1[i] != s2[i]) && kcov_then(1031))
      return 0;
  return 1;
}


static struct dfa *dfa;


static int
charclass_index(s)
     charclass s;
{
  int i;

  for (i = 0; kcov_count(1032) || (i < dfa->cindex) && kcov_then(1032); ++i)
    if (kcov_count(1033) || (equal(s, dfa->charclasses[i])) && kcov_then(1033))
      return i;
  if (kcov_count(1034) || ((dfa->cindex) >= (dfa->calloc)) && kcov_then(1034)) { while (kcov_count(1035) || ((dfa->cindex) >= (dfa->calloc)) && kcov_then(1035)) (dfa->calloc) *= 2; ((dfa->charclasses) = (charclass *) xrealloc_1((ptr_t) (dfa->charclasses), (dfa->calloc) * sizeof (charclass))); };
  ++dfa->cindex;
  copyset(s, dfa->charclasses[i]);
  return i;
}


static int syntax_bits, syntax_bits_set;


static int case_fold;


void
dfasyntax(bits, fold)
     int bits;
     int fold;
{
  syntax_bits_set = 1;
  syntax_bits = bits;
  case_fold = fold;
}






static char *lexstart;
static char *lexptr;
static lexleft;
static token lasttok;
static int laststart;

static int parens;
static int minrep, maxrep;
# 6934 "grep.c"
static int is_alpha(c) int c; { return (1 && ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISalpha)); }
static int is_upper(c) int c; { return (1 && ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISupper)); }
static int is_lower(c) int c; { return (1 && ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISlower)); }
static int is_digit(c) int c; { return (1 && ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISdigit)); }
static int is_xdigit(c) int c; { return (1 && ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISxdigit)); }
static int is_space(c) int c; { return (1 && ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISspace)); }
static int is_punct(c) int c; { return (1 && ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISpunct)); }
static int is_alnum(c) int c; { return (1 && ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISalnum)); }
static int is_print(c) int c; { return (1 && ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISprint)); }
static int is_graph(c) int c; { return (1 && ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISgraph)); }
static int is_cntrl(c) int c; { return (1 && ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _IScntrl)); }




static struct {
  char *name;
  int (*pred)();
} prednames[] = {
  ":alpha:]", is_alpha,
  ":upper:]", is_upper,
  ":lower:]", is_lower,
  ":digit:]", is_digit,
  ":xdigit:]", is_xdigit,
  ":space:]", is_space,
  ":punct:]", is_punct,
  ":alnum:]", is_alnum,
  ":print:]", is_print,
  ":graph:]", is_graph,
  ":cntrl:]", is_cntrl,
  0
};

static int
looking_at(s)
     char *s;
{
  int len;

  len = strlen(s);
  if (kcov_count(1036) || (lexleft < len) && kcov_then(1036))
    return 0;
  return strncmp(s, lexptr, len) == 0;
}

static token
lex()
{
  token c, c1, c2;
  int backslash = 0, invert;
  charclass ccl;
  int i;







  for (i = 0; kcov_count(1037) || (i < 2) && kcov_then(1037); ++i)
    {
      { if (kcov_count(1038) || (! lexleft) && kcov_then(1038)) if (kcov_count(1039) || (0 != 0) && kcov_then(1039)) dfaerror(0); else return END; (c) = (unsigned char) *lexptr++; --lexleft; };
      switch (c)
 {
 case '\\':kcov_count(1040);
kcov_then(1040);

   if (kcov_count(1041) || (backslash) && kcov_then(1041))
     goto normal_char;
   if (kcov_count(1042) || (lexleft == 0) && kcov_then(1042))
     dfaerror("Unfinished \\ escape");
   backslash = 1;
   break;

 case '^':kcov_count(1043);
kcov_then(1043);

   if (kcov_count(1044) || (backslash) && kcov_then(1044))
     goto normal_char;
   if (kcov_count(1045) || (syntax_bits & ((((1) << 1) << 1) << 1)
       || lasttok == END
       || lasttok == LPAREN
       || lasttok == OR) && kcov_then(1045))
     return lasttok = BEGLINE;
   goto normal_char;

 case '$':kcov_count(1046);
kcov_then(1046);

   if (kcov_count(1047) || (backslash) && kcov_then(1047))
     goto normal_char;
   if (kcov_count(1048) || (syntax_bits & ((((1) << 1) << 1) << 1)
       || lexleft == 0
       || (kcov_count(1049) || (syntax_bits & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(1049)
    ? lexleft > 0 && *lexptr == ')'
    : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == ')')
       || (kcov_count(1050) || (syntax_bits & ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(1050)
    ? lexleft > 0 && *lexptr == '|'
    : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == '|')
       || ((syntax_bits & ((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
           && lexleft > 0 && *lexptr == '\n')) && kcov_then(1048))
     return lasttok = ENDLINE;
   goto normal_char;

 case '1':kcov_count(1051);
kcov_then(1051);

 case '2':kcov_count(1052);
kcov_then(1052);

 case '3':kcov_count(1053);
kcov_then(1053);

 case '4':kcov_count(1054);
kcov_then(1054);

 case '5':kcov_count(1055);
kcov_then(1055);

 case '6':kcov_count(1056);
kcov_then(1056);

 case '7':kcov_count(1057);
kcov_then(1057);

 case '8':kcov_count(1058);
kcov_then(1058);

 case '9':kcov_count(1059);
kcov_then(1059);

   if (kcov_count(1060) || (backslash && !(syntax_bits & (((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) && kcov_then(1060))
     {
       laststart = 0;
       return lasttok = BACKREF;
     }
   goto normal_char;

 case '<':kcov_count(1061);
kcov_then(1061);

   if (kcov_count(1062) || (backslash) && kcov_then(1062))
     return lasttok = BEGWORD;
   goto normal_char;

 case '>':kcov_count(1063);
kcov_then(1063);

   if (kcov_count(1064) || (backslash) && kcov_then(1064))
     return lasttok = ENDWORD;
   goto normal_char;

 case 'b':kcov_count(1065);
kcov_then(1065);

   if (kcov_count(1066) || (backslash) && kcov_then(1066))
     return lasttok = LIMWORD;
   goto normal_char;

 case 'B':kcov_count(1067);
kcov_then(1067);

   if (kcov_count(1068) || (backslash) && kcov_then(1068))
     return lasttok = NOTLIMWORD;
   goto normal_char;

 case '?':kcov_count(1069);
kcov_then(1069);

   if (kcov_count(1070) || (syntax_bits & (((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(1070))
     goto normal_char;
   if (kcov_count(1071) || (backslash != ((syntax_bits & ((1) << 1)) != 0)) && kcov_then(1071))
     goto normal_char;
   if (kcov_count(1072) || (!(syntax_bits & (((((1) << 1) << 1) << 1) << 1)) && laststart) && kcov_then(1072))
     goto normal_char;
   return lasttok = QMARK;

 case '*':kcov_count(1073);
kcov_then(1073);

   if (kcov_count(1074) || (backslash) && kcov_then(1074))
     goto normal_char;
   if (kcov_count(1075) || (!(syntax_bits & (((((1) << 1) << 1) << 1) << 1)) && laststart) && kcov_then(1075))
     goto normal_char;
   return lasttok = STAR;

 case '+':kcov_count(1076);
kcov_then(1076);

   if (kcov_count(1077) || (syntax_bits & (((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(1077))
     goto normal_char;
   if (kcov_count(1078) || (backslash != ((syntax_bits & ((1) << 1)) != 0)) && kcov_then(1078))
     goto normal_char;
   if (kcov_count(1079) || (!(syntax_bits & (((((1) << 1) << 1) << 1) << 1)) && laststart) && kcov_then(1079))
     goto normal_char;
   return lasttok = PLUS;

 case '{':kcov_count(1080);
kcov_then(1080);

   if (kcov_count(1081) || (!(syntax_bits & ((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) && kcov_then(1081))
     goto normal_char;
   if (kcov_count(1082) || (backslash != ((syntax_bits & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0)) && kcov_then(1082))
     goto normal_char;
   minrep = maxrep = 0;





   { if (kcov_count(1083) || (! lexleft) && kcov_then(1083)) if (kcov_count(1084) || ("unfinished repeat count" != 0) && kcov_then(1084)) dfaerror("unfinished repeat count"); else return END; (c) = (unsigned char) *lexptr++; --lexleft; };
   if (kcov_count(1085) || ((1 && ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISdigit))) && kcov_then(1085))
     {
       minrep = c - '0';
       for (;kcov_count(1086) || kcov_then(1086);)
  {
    { if (kcov_count(1087) || (! lexleft) && kcov_then(1087)) if (kcov_count(1088) || ("unfinished repeat count" != 0) && kcov_then(1088)) dfaerror("unfinished repeat count"); else return END; (c) = (unsigned char) *lexptr++; --lexleft; };
    if (kcov_count(1089) || (!(1 && ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISdigit))) && kcov_then(1089))
      break;
    minrep = 10 * minrep + c - '0';
  }
     }
   else if (kcov_count(1090) || (c != ',') && kcov_then(1090))
     dfaerror("malformed repeat count");
   if (kcov_count(1091) || (c == ',') && kcov_then(1091))
     for (;kcov_count(1092) || kcov_then(1092);)
       {
  { if (kcov_count(1093) || (! lexleft) && kcov_then(1093)) if (kcov_count(1094) || ("unfinished repeat count" != 0) && kcov_then(1094)) dfaerror("unfinished repeat count"); else return END; (c) = (unsigned char) *lexptr++; --lexleft; };
  if (kcov_count(1095) || (!(1 && ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISdigit))) && kcov_then(1095))
    break;
  maxrep = 10 * maxrep + c - '0';
       }
   else
     maxrep = minrep;
   if (kcov_count(1096) || (!(syntax_bits & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) && kcov_then(1096))
     {
       if (kcov_count(1097) || (c != '\\') && kcov_then(1097))
  dfaerror("malformed repeat count");
       { if (kcov_count(1098) || (! lexleft) && kcov_then(1098)) if (kcov_count(1099) || ("unfinished repeat count" != 0) && kcov_then(1099)) dfaerror("unfinished repeat count"); else return END; (c) = (unsigned char) *lexptr++; --lexleft; };
     }
   if (kcov_count(1100) || (c != '}') && kcov_then(1100))
     dfaerror("malformed repeat count");
   laststart = 0;
   return lasttok = REPMN;

 case '|':kcov_count(1101);
kcov_then(1101);

   if (kcov_count(1102) || (syntax_bits & (((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(1102))
     goto normal_char;
   if (kcov_count(1103) || (backslash != ((syntax_bits & ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0)) && kcov_then(1103))
     goto normal_char;
   laststart = 1;
   return lasttok = OR;

 case '\n':kcov_count(1104);
kcov_then(1104);

   if (kcov_count(1105) || (syntax_bits & (((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)
       || backslash
       || !(syntax_bits & ((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) && kcov_then(1105))
     goto normal_char;
   laststart = 1;
   return lasttok = OR;

 case '(':kcov_count(1106);
kcov_then(1106);

   if (kcov_count(1107) || (backslash != ((syntax_bits & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0)) && kcov_then(1107))
     goto normal_char;
   ++parens;
   laststart = 1;
   return lasttok = LPAREN;

 case ')':kcov_count(1108);
kcov_then(1108);

   if (kcov_count(1109) || (backslash != ((syntax_bits & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0)) && kcov_then(1109))
     goto normal_char;
   if (kcov_count(1110) || (parens == 0 && syntax_bits & ((((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(1110))
     goto normal_char;
   --parens;
   laststart = 0;
   return lasttok = RPAREN;

 case '.':kcov_count(1111);
kcov_then(1111);

   if (kcov_count(1112) || (backslash) && kcov_then(1112))
     goto normal_char;
   zeroset(ccl);
   notset(ccl);
   if (kcov_count(1113) || (!(syntax_bits & (((((((1) << 1) << 1) << 1) << 1) << 1) << 1))) && kcov_then(1113))
     clrbit('\n', ccl);
   if (kcov_count(1114) || (syntax_bits & ((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(1114))
     clrbit('\0', ccl);
   laststart = 0;
   return lasttok = CSET + charclass_index(ccl);

 case 'w':kcov_count(1115);
kcov_then(1115);

 case 'W':kcov_count(1116);
kcov_then(1116);

   if (kcov_count(1117) || (!backslash) && kcov_then(1117))
     goto normal_char;
   zeroset(ccl);
   for (c2 = 0; kcov_count(1118) || (c2 < (1 << 8)) && kcov_then(1118); ++c2)
     if (kcov_count(1119) || ((1 && ((*__ctype_b_loc ())[(int) ((c2))] & (unsigned short int) _ISalnum))) && kcov_then(1119))
       setbit(c2, ccl);
   if (kcov_count(1120) || (c == 'W') && kcov_then(1120))
     notset(ccl);
   laststart = 0;
   return lasttok = CSET + charclass_index(ccl);

 case '[':kcov_count(1121);
kcov_then(1121);

   if (kcov_count(1122) || (backslash) && kcov_then(1122))
     goto normal_char;
   zeroset(ccl);
   { if (kcov_count(1123) || (! lexleft) && kcov_then(1123)) if (kcov_count(1124) || ("Unbalanced [" != 0) && kcov_then(1124)) dfaerror("Unbalanced ["); else return END; (c) = (unsigned char) *lexptr++; --lexleft; };
   if (kcov_count(1125) || (c == '^') && kcov_then(1125))
     {
       { if (kcov_count(1126) || (! lexleft) && kcov_then(1126)) if (kcov_count(1127) || ("Unbalanced [" != 0) && kcov_then(1127)) dfaerror("Unbalanced ["); else return END; (c) = (unsigned char) *lexptr++; --lexleft; };
       invert = 1;
     }
   else
     invert = 0;
   do
     {






       if (kcov_count(1129) || (c == '[' && (syntax_bits & (((1) << 1) << 1))) && kcov_then(1129))
  for (c1 = 0; kcov_count(1130) || (prednames[c1].name) && kcov_then(1130); ++c1)
    if (kcov_count(1131) || (looking_at(prednames[c1].name)) && kcov_then(1131))
      {
        for (c2 = 0; kcov_count(1132) || (c2 < (1 << 8)) && kcov_then(1132); ++c2)
   if (kcov_count(1133) || ((*prednames[c1].pred)(c2)) && kcov_then(1133))
     setbit(c2, ccl);
        lexptr += strlen(prednames[c1].name);
        lexleft -= strlen(prednames[c1].name);
        { if (kcov_count(1134) || (! lexleft) && kcov_then(1134)) if (kcov_count(1135) || ("Unbalanced [" != 0) && kcov_then(1135)) dfaerror("Unbalanced ["); else return END; (c1) = (unsigned char) *lexptr++; --lexleft; };
        goto skip;
      }
       if (kcov_count(1136) || (c == '\\' && (syntax_bits & (1))) && kcov_then(1136))
  { if (kcov_count(1137) || (! lexleft) && kcov_then(1137)) if (kcov_count(1138) || ("Unbalanced [" != 0) && kcov_then(1138)) dfaerror("Unbalanced ["); else return END; (c) = (unsigned char) *lexptr++; --lexleft; };
       { if (kcov_count(1139) || (! lexleft) && kcov_then(1139)) if (kcov_count(1140) || ("Unbalanced [" != 0) && kcov_then(1140)) dfaerror("Unbalanced ["); else return END; (c1) = (unsigned char) *lexptr++; --lexleft; };
       if (kcov_count(1141) || (c1 == '-') && kcov_then(1141))
  {
    { if (kcov_count(1142) || (! lexleft) && kcov_then(1142)) if (kcov_count(1143) || ("Unbalanced [" != 0) && kcov_then(1143)) dfaerror("Unbalanced ["); else return END; (c2) = (unsigned char) *lexptr++; --lexleft; };
    if (kcov_count(1144) || (c2 == ']') && kcov_then(1144))
      {


        --lexptr;
        ++lexleft;
        c2 = c;
      }
    else
      {
        if (kcov_count(1145) || (c2 == '\\'
     && (syntax_bits & (1))) && kcov_then(1145))
   { if (kcov_count(1146) || (! lexleft) && kcov_then(1146)) if (kcov_count(1147) || ("Unbalanced [" != 0) && kcov_then(1147)) dfaerror("Unbalanced ["); else return END; (c2) = (unsigned char) *lexptr++; --lexleft; };
        { if (kcov_count(1148) || (! lexleft) && kcov_then(1148)) if (kcov_count(1149) || ("Unbalanced [" != 0) && kcov_then(1149)) dfaerror("Unbalanced ["); else return END; (c1) = (unsigned char) *lexptr++; --lexleft; };
      }
  }
       else
  c2 = c;
       while (kcov_count(1150) || (c <= c2) && kcov_then(1150))
  {
    setbit(c, ccl);
    if (kcov_count(1151) || (case_fold) && kcov_then(1151))
      if (kcov_count(1152) || ((1 && ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISupper))) && kcov_then(1152))
        setbit(tolower(c), ccl);
      else if (kcov_count(1153) || ((1 && ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISlower))) && kcov_then(1153))
        setbit(toupper(c), ccl);
    ++c;
  }
     skip:
       ;
     }
   while (kcov_count(1128) || ((c = c1) != ']') && kcov_then(1128));
   if (kcov_count(1154) || (invert) && kcov_then(1154))
     {
       notset(ccl);
       if (kcov_count(1155) || (syntax_bits & (((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && kcov_then(1155))
  clrbit('\n', ccl);
     }
   laststart = 0;
   return lasttok = CSET + charclass_index(ccl);

 default:kcov_count(1156);
kcov_then(1156);

 normal_char:
   laststart = 0;
   if (kcov_count(1157) || (case_fold && (1 && ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISalpha))) && kcov_then(1157))
     {
       zeroset(ccl);
       setbit(c, ccl);
       if (kcov_count(1158) || (((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISupper)) && kcov_then(1158))
  setbit(tolower(c), ccl);
       else
  setbit(toupper(c), ccl);
       return lasttok = CSET + charclass_index(ccl);
     }
   return c;
 }
    }



  abort();
}



static token tok;
static depth;







static void
addtok(t)
     token t;
{
  if (kcov_count(1159) || ((dfa->tindex) >= (dfa->talloc)) && kcov_then(1159)) { while (kcov_count(1160) || ((dfa->tindex) >= (dfa->talloc)) && kcov_then(1160)) (dfa->talloc) *= 2; ((dfa->tokens) = (token *) xrealloc_1((ptr_t) (dfa->tokens), (dfa->talloc) * sizeof (token))); };
  dfa->tokens[dfa->tindex++] = t;

  switch (t)
    {
    case QMARK:kcov_count(1161);
kcov_then(1161);

    case STAR:kcov_count(1162);
kcov_then(1162);

    case PLUS:kcov_count(1163);
kcov_then(1163);

      break;

    case CAT:kcov_count(1164);
kcov_then(1164);

    case OR:kcov_count(1165);
kcov_then(1165);

    case ORTOP:kcov_count(1166);
kcov_then(1166);

      --depth;
      break;

    default:kcov_count(1167);
kcov_then(1167);

      ++dfa->nleaves;
    case EMPTY:kcov_count(1168);
kcov_then(1168);

      ++depth;
      break;
    }
  if (kcov_count(1169) || (depth > dfa->depth) && kcov_then(1169))
    dfa->depth = depth;
}
# 7369 "grep.c"
static void regexp(int);




static void
atom()
{
  if (kcov_count(1170) || ((tok >= 0 && tok < (1 << 8)) || tok >= CSET || tok == BACKREF
      || tok == BEGLINE || tok == ENDLINE || tok == BEGWORD
      || tok == ENDWORD || tok == LIMWORD || tok == NOTLIMWORD) && kcov_then(1170))
    {
      addtok(tok);
      tok = lex();
    }
  else if (kcov_count(1171) || (tok == LPAREN) && kcov_then(1171))
    {
      tok = lex();
      regexp(0);
      if (kcov_count(1172) || (tok != RPAREN) && kcov_then(1172))
 dfaerror("Unbalanced (");
      tok = lex();
    }
  else
    addtok(EMPTY);
}


static int
nsubtoks(tindex)
{
  int ntoks1;

  switch (dfa->tokens[tindex - 1])
    {
    default:kcov_count(1173);
kcov_then(1173);

      return 1;
    case QMARK:kcov_count(1174);
kcov_then(1174);

    case STAR:kcov_count(1175);
kcov_then(1175);

    case PLUS:kcov_count(1176);
kcov_then(1176);

      return 1 + nsubtoks(tindex - 1);
    case CAT:kcov_count(1177);
kcov_then(1177);

    case OR:kcov_count(1178);
kcov_then(1178);

    case ORTOP:kcov_count(1179);
kcov_then(1179);

      ntoks1 = nsubtoks(tindex - 1);
      return 1 + ntoks1 + nsubtoks(tindex - 1 - ntoks1);
    }
}


static void
copytoks(tindex, ntokens)
     int tindex, ntokens;
{
  int i;

  for (i = 0; kcov_count(1180) || (i < ntokens) && kcov_then(1180); ++i)
    addtok(dfa->tokens[tindex + i]);
}

static void
closure()
{
  int tindex, ntokens, i;

  atom();
  while (kcov_count(1181) || (tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN) && kcov_then(1181))
    if (kcov_count(1182) || (tok == REPMN) && kcov_then(1182))
      {
 ntokens = nsubtoks(dfa->tindex);
 tindex = dfa->tindex - ntokens;
 if (kcov_count(1183) || (maxrep == 0) && kcov_then(1183))
   addtok(PLUS);
 if (kcov_count(1184) || (minrep == 0) && kcov_then(1184))
   addtok(QMARK);
 for (i = 1; kcov_count(1185) || (i < minrep) && kcov_then(1185); ++i)
   {
     copytoks(tindex, ntokens);
     addtok(CAT);
   }
 for (; kcov_count(1186) || (i < maxrep) && kcov_then(1186); ++i)
   {
     copytoks(tindex, ntokens);
     addtok(QMARK);
     addtok(CAT);
   }
 tok = lex();
      }
    else
      {
 addtok(tok);
 tok = lex();
      }
}

static void
branch()
{
  closure();
  while (kcov_count(1187) || (tok != RPAREN && tok != OR && tok >= 0) && kcov_then(1187))
    {
      closure();
      addtok(CAT);
    }
}

static void
regexp(toplevel)
     int toplevel;
{
  branch();
  while (kcov_count(1188) || (tok == OR) && kcov_then(1188))
    {
      tok = lex();
      branch();
      if (kcov_count(1189) || (toplevel) && kcov_then(1189))
 addtok(ORTOP);
      else
 addtok(OR);
    }
}




void
dfaparse(s, len, d)
     char *s;
     size_t len;
     struct dfa *d;

{
  dfa = d;
  lexstart = lexptr = s;
  lexleft = len;
  lasttok = END;
  laststart = 1;
  parens = 0;

  if (kcov_count(1190) || (! syntax_bits_set) && kcov_then(1190))
    dfaerror("No syntax specified");

  tok = lex();
  depth = d->depth;

  regexp(1);

  if (kcov_count(1191) || (tok != END) && kcov_then(1191))
    dfaerror("Unbalanced )");

  addtok(END - d->nregexps);
  addtok(CAT);

  if (kcov_count(1192) || (d->nregexps) && kcov_then(1192))
    addtok(ORTOP);

  ++d->nregexps;
}




static void
copy(src, dst)
     position_set *src;
     position_set *dst;
{
  int i;

  for (i = 0; kcov_count(1193) || (i < src->nelem) && kcov_then(1193); ++i)
    dst->elems[i] = src->elems[i];
  dst->nelem = src->nelem;
}





static void
insert(p, s)
     position p;
     position_set *s;
{
  int i;
  position t1, t2;

  for (i = 0; kcov_count(1194) || (i < s->nelem && p.strchr < s->elems[i].strchr) && kcov_then(1194); ++i)
    ;
  if (kcov_count(1195) || (i < s->nelem && p.strchr == s->elems[i].strchr) && kcov_then(1195))
    s->elems[i].constraint |= p.constraint;
  else
    {
      t1 = p;
      ++s->nelem;
      while (kcov_count(1196) || (i < s->nelem) && kcov_then(1196))
 {
   t2 = s->elems[i];
   s->elems[i++] = t1;
   t1 = t2;
 }
    }
}



static void
merge(s1, s2, m)
     position_set *s1;
     position_set *s2;
     position_set *m;
{
  int i = 0, j = 0;

  m->nelem = 0;
  while (kcov_count(1197) || (i < s1->nelem && j < s2->nelem) && kcov_then(1197))
    if (kcov_count(1198) || (s1->elems[i].strchr > s2->elems[j].strchr) && kcov_then(1198))
      m->elems[m->nelem++] = s1->elems[i++];
    else if (kcov_count(1199) || (s1->elems[i].strchr < s2->elems[j].strchr) && kcov_then(1199))
      m->elems[m->nelem++] = s2->elems[j++];
    else
      {
 m->elems[m->nelem] = s1->elems[i++];
 m->elems[m->nelem++].constraint |= s2->elems[j++].constraint;
      }
  while (kcov_count(1200) || (i < s1->nelem) && kcov_then(1200))
    m->elems[m->nelem++] = s1->elems[i++];
  while (kcov_count(1201) || (j < s2->nelem) && kcov_then(1201))
    m->elems[m->nelem++] = s2->elems[j++];
}


static void
delete(p, s)
     position p;
     position_set *s;
{
  int i;

  for (i = 0; kcov_count(1202) || (i < s->nelem) && kcov_then(1202); ++i)
    if (kcov_count(1203) || (p.strchr == s->elems[i].strchr) && kcov_then(1203))
      break;
  if (kcov_count(1204) || (i < s->nelem) && kcov_then(1204))
    for (--s->nelem; kcov_count(1205) || (i < s->nelem) && kcov_then(1205); ++i)
      s->elems[i] = s->elems[i + 1];
}





static int
state_index(d, s, newline, letter)
     struct dfa *d;
     position_set *s;
     int newline;
     int letter;
{
  int hash = 0;
  int constraint;
  int i, j;

  newline = kcov_count(1206) || (newline) && kcov_then(1206) ? 1 : 0;
  letter = kcov_count(1207) || (letter) && kcov_then(1207) ? 1 : 0;

  for (i = 0; kcov_count(1208) || (i < s->nelem) && kcov_then(1208); ++i)
    hash ^= s->elems[i].strchr + s->elems[i].constraint;


  for (i = 0; kcov_count(1209) || (i < d->sindex) && kcov_then(1209); ++i)
    {
      if (kcov_count(1210) || (hash != d->states[i].hash || s->nelem != d->states[i].elems.nelem
   || newline != d->states[i].newline || letter != d->states[i].letter) && kcov_then(1210))
 continue;
      for (j = 0; kcov_count(1211) || (j < s->nelem) && kcov_then(1211); ++j)
 if (kcov_count(1212) || (s->elems[j].constraint
     != d->states[i].elems.elems[j].constraint
     || s->elems[j].strchr != d->states[i].elems.elems[j].strchr) && kcov_then(1212))
   break;
      if (kcov_count(1213) || (j == s->nelem) && kcov_then(1213))
 return i;
    }


  if (kcov_count(1214) || ((d->sindex) >= (d->salloc)) && kcov_then(1214)) { while (kcov_count(1215) || ((d->sindex) >= (d->salloc)) && kcov_then(1215)) (d->salloc) *= 2; ((d->states) = (dfa_state *) xrealloc_1((ptr_t) (d->states), (d->salloc) * sizeof (dfa_state))); };
  d->states[i].hash = hash;
  ((d->states[i].elems.elems) = (position *) xmalloc_1((s->nelem) * sizeof (position)));
  copy(s, &d->states[i].elems);
  d->states[i].newline = newline;
  d->states[i].letter = letter;
  d->states[i].backref = 0;
  d->states[i].constraint = 0;
  d->states[i].first_end = 0;
  for (j = 0; kcov_count(1216) || (j < s->nelem) && kcov_then(1216); ++j)
    if (kcov_count(1217) || (d->tokens[s->elems[j].strchr] < 0) && kcov_then(1217))
      {
 constraint = s->elems[j].constraint;
 if (kcov_count(1218) || ((((constraint) & 1 << ((kcov_count(1219) || ((newline)) && kcov_then(1219) ? 2 : 0) + (kcov_count(1220) || ((0)) && kcov_then(1220) ? 1 : 0) + 4)) && ((constraint) & 1 << ((kcov_count(1221) || ((letter)) && kcov_then(1221) ? 2 : 0) + (kcov_count(1222) || ((0)) && kcov_then(1222) ? 1 : 0))))
     || (((constraint) & 1 << ((kcov_count(1223) || ((newline)) && kcov_then(1223) ? 2 : 0) + (kcov_count(1224) || ((0)) && kcov_then(1224) ? 1 : 0) + 4)) && ((constraint) & 1 << ((kcov_count(1225) || ((letter)) && kcov_then(1225) ? 2 : 0) + (kcov_count(1226) || ((1)) && kcov_then(1226) ? 1 : 0))))
     || (((constraint) & 1 << ((kcov_count(1227) || ((newline)) && kcov_then(1227) ? 2 : 0) + (kcov_count(1228) || ((1)) && kcov_then(1228) ? 1 : 0) + 4)) && ((constraint) & 1 << ((kcov_count(1229) || ((letter)) && kcov_then(1229) ? 2 : 0) + (kcov_count(1230) || ((0)) && kcov_then(1230) ? 1 : 0))))
     || (((constraint) & 1 << ((kcov_count(1231) || ((newline)) && kcov_then(1231) ? 2 : 0) + (kcov_count(1232) || ((1)) && kcov_then(1232) ? 1 : 0) + 4)) && ((constraint) & 1 << ((kcov_count(1233) || ((letter)) && kcov_then(1233) ? 2 : 0) + (kcov_count(1234) || ((1)) && kcov_then(1234) ? 1 : 0))))) && kcov_then(1218))
   d->states[i].constraint |= constraint;
 if (kcov_count(1235) || (! d->states[i].first_end) && kcov_then(1235))
   d->states[i].first_end = d->tokens[s->elems[j].strchr];
      }
    else if (kcov_count(1236) || (d->tokens[s->elems[j].strchr] == BACKREF) && kcov_then(1236))
      {
 d->states[i].constraint = 0xff;
 d->states[i].backref = 1;
      }

  ++d->sindex;

  return i;
}






void
epsclosure(s, d)
     position_set *s;
     struct dfa *d;
{
  int i, j;
  int *visited;
  position p, old;

  ((visited) = (int *) xmalloc_1((d->tindex) * sizeof (int)));
  for (i = 0; kcov_count(1237) || (i < d->tindex) && kcov_then(1237); ++i)
    visited[i] = 0;

  for (i = 0; kcov_count(1238) || (i < s->nelem) && kcov_then(1238); ++i)
    if (kcov_count(1239) || (d->tokens[s->elems[i].strchr] >= (1 << 8)
 && d->tokens[s->elems[i].strchr] != BACKREF
 && d->tokens[s->elems[i].strchr] < CSET) && kcov_then(1239))
      {
 old = s->elems[i];
 p.constraint = old.constraint;
 delete(s->elems[i], s);
 if (kcov_count(1240) || (visited[old.strchr]) && kcov_then(1240))
   {
     --i;
     continue;
   }
 visited[old.strchr] = 1;
 switch (d->tokens[old.strchr])
   {
   case BEGLINE:kcov_count(1241);
kcov_then(1241);

     p.constraint &= 0xcf;
     break;
   case ENDLINE:kcov_count(1242);
kcov_then(1242);

     p.constraint &= 0xaf;
     break;
   case BEGWORD:kcov_count(1243);
kcov_then(1243);

     p.constraint &= 0xf2;
     break;
   case ENDWORD:kcov_count(1244);
kcov_then(1244);

     p.constraint &= 0xf4;
     break;
   case LIMWORD:kcov_count(1245);
kcov_then(1245);

     p.constraint &= 0xf6;
     break;
   case NOTLIMWORD:kcov_count(1246);
kcov_then(1246);

     p.constraint &= 0xf9;
     break;
   default:kcov_count(1247);
kcov_then(1247);

     break;
   }
 for (j = 0; kcov_count(1248) || (j < d->follows[old.strchr].nelem) && kcov_then(1248); ++j)
   {
     p.strchr = d->follows[old.strchr].elems[j].strchr;
     insert(p, s);
   }

 i = -1;
      }

  free(visited);
}
# 7803 "grep.c"
void
dfaanalyze(d, searchflag)
     struct dfa *d;
     int searchflag;
{
  int *nullable;
  int *nfirstpos;
  position *firstpos;
  int *nlastpos;
  position *lastpos;
  int *nalloc;
  position_set tmp;
  position_set merged;
  int wants_newline;
  int *o_nullable;
  int *o_nfirst, *o_nlast;
  position *o_firstpos, *o_lastpos;
  int i, j;
  position *pos;
# 7833 "grep.c"
  d->searchflag = searchflag;

  ((nullable) = (int *) xmalloc_1((d->depth) * sizeof (int)));
  o_nullable = nullable;
  ((nfirstpos) = (int *) xmalloc_1((d->depth) * sizeof (int)));
  o_nfirst = nfirstpos;
  ((firstpos) = (position *) xmalloc_1((d->nleaves) * sizeof (position)));
  o_firstpos = firstpos, firstpos += d->nleaves;
  ((nlastpos) = (int *) xmalloc_1((d->depth) * sizeof (int)));
  o_nlast = nlastpos;
  ((lastpos) = (position *) xmalloc_1((d->nleaves) * sizeof (position)));
  o_lastpos = lastpos, lastpos += d->nleaves;
  ((nalloc) = (int *) xmalloc_1((d->tindex) * sizeof (int)));
  for (i = 0; kcov_count(1249) || (i < d->tindex) && kcov_then(1249); ++i)
    nalloc[i] = 0;
  ((merged.elems) = (position *) xmalloc_1((d->nleaves) * sizeof (position)));

  ((d->follows) = (position_set *) xcalloc((d->tindex), sizeof (position_set)));

  for (i = 0; kcov_count(1250) || (i < d->tindex) && kcov_then(1250); ++i)



    switch (d->tokens[i])
      {
      case EMPTY:kcov_count(1251);
kcov_then(1251);


 *nullable++ = 1;


 *nfirstpos++ = *nlastpos++ = 0;
 break;

      case STAR:kcov_count(1252);
kcov_then(1252);

      case PLUS:kcov_count(1253);
kcov_then(1253);



 tmp.nelem = nfirstpos[-1];
 tmp.elems = firstpos;
 pos = lastpos;
 for (j = 0; kcov_count(1254) || (j < nlastpos[-1]) && kcov_then(1254); ++j)
   {
     merge(&tmp, &d->follows[pos[j].strchr], &merged);
     if (kcov_count(1255) || ((merged.nelem - 1) >= (nalloc[pos[j].strchr])) && kcov_then(1255)) { while (kcov_count(1256) || ((merged.nelem - 1) >= (nalloc[pos[j].strchr])) && kcov_then(1256)) (nalloc[pos[j].strchr]) *= 2; ((d->follows[pos[j].strchr].elems) = (position *) xrealloc_1((ptr_t) (d->follows[pos[j].strchr].elems), (nalloc[pos[j].strchr]) * sizeof (position))); };

     copy(&merged, &d->follows[pos[j].strchr]);
   }

      case QMARK:kcov_count(1257);
kcov_then(1257);


 if (kcov_count(1258) || (d->tokens[i] != PLUS) && kcov_then(1258))
   nullable[-1] = 1;
 break;

      case CAT:kcov_count(1259);
kcov_then(1259);



 tmp.nelem = nfirstpos[-1];
 tmp.elems = firstpos;
 pos = lastpos + nlastpos[-1];
 for (j = 0; kcov_count(1260) || (j < nlastpos[-2]) && kcov_then(1260); ++j)
   {
     merge(&tmp, &d->follows[pos[j].strchr], &merged);
     if (kcov_count(1261) || ((merged.nelem - 1) >= (nalloc[pos[j].strchr])) && kcov_then(1261)) { while (kcov_count(1262) || ((merged.nelem - 1) >= (nalloc[pos[j].strchr])) && kcov_then(1262)) (nalloc[pos[j].strchr]) *= 2; ((d->follows[pos[j].strchr].elems) = (position *) xrealloc_1((ptr_t) (d->follows[pos[j].strchr].elems), (nalloc[pos[j].strchr]) * sizeof (position))); };

     copy(&merged, &d->follows[pos[j].strchr]);
   }



 if (kcov_count(1263) || (nullable[-2]) && kcov_then(1263))
   nfirstpos[-2] += nfirstpos[-1];
 else
   firstpos += nfirstpos[-1];
 --nfirstpos;



 if (kcov_count(1264) || (nullable[-1]) && kcov_then(1264))
   nlastpos[-2] += nlastpos[-1];
 else
   {
     pos = lastpos + nlastpos[-2];
     for (j = nlastpos[-1] - 1; kcov_count(1265) || (j >= 0) && kcov_then(1265); --j)
       pos[j] = lastpos[j];
     lastpos += nlastpos[-2];
     nlastpos[-2] = nlastpos[-1];
   }
 --nlastpos;


 nullable[-2] = nullable[-1] && nullable[-2];
 --nullable;
 break;

      case OR:kcov_count(1266);
kcov_then(1266);

      case ORTOP:kcov_count(1267);
kcov_then(1267);


 nfirstpos[-2] += nfirstpos[-1];
 --nfirstpos;


 nlastpos[-2] += nlastpos[-1];
 --nlastpos;


 nullable[-2] = nullable[-1] || nullable[-2];
 --nullable;
 break;

      default:kcov_count(1268);
kcov_then(1268);






 *nullable++ = d->tokens[i] == BACKREF;


 *nfirstpos++ = *nlastpos++ = 1;
 --firstpos, --lastpos;
 firstpos->strchr = lastpos->strchr = i;
 firstpos->constraint = lastpos->constraint = 0xff;


 nalloc[i] = 1;
 ((d->follows[i].elems) = (position *) xmalloc_1((nalloc[i]) * sizeof (position)));
 break;
      }
# 7986 "grep.c"
  for (i = 0; kcov_count(1269) || (i < d->tindex) && kcov_then(1269); ++i)
    if (kcov_count(1270) || (d->tokens[i] < (1 << 8) || d->tokens[i] == BACKREF
 || d->tokens[i] >= CSET) && kcov_then(1270))
      {
# 8001 "grep.c"
 copy(&d->follows[i], &merged);
 epsclosure(&merged, d);
 if (kcov_count(1271) || (d->follows[i].nelem < merged.nelem) && kcov_then(1271))
   ((d->follows[i].elems) = (position *) xrealloc_1((ptr_t) (d->follows[i].elems), (merged.nelem) * sizeof (position)));
 copy(&merged, &d->follows[i]);
      }



  merged.nelem = 0;
  for (i = 0; kcov_count(1272) || (i < nfirstpos[-1]) && kcov_then(1272); ++i)
    insert(firstpos[i], &merged);
  epsclosure(&merged, d);


  wants_newline = 0;
  for (i = 0; kcov_count(1273) || (i < merged.nelem) && kcov_then(1273); ++i)
    if (kcov_count(1274) || ((((merged.elems[i].constraint) & 0xc0) >> 2 != ((merged.elems[i].constraint) & 0x30))) && kcov_then(1274))
      wants_newline = 1;


  d->salloc = 1;
  d->sindex = 0;
  ((d->states) = (dfa_state *) xmalloc_1((d->salloc) * sizeof (dfa_state)));
  state_index(d, &merged, wants_newline, 0);

  free(o_nullable);
  free(o_nfirst);
  free(o_firstpos);
  free(o_nlast);
  free(o_lastpos);
  free(nalloc);
  free(merged.elems);
}
# 8066 "grep.c"
void
dfastate(s, d, trans)
     int s;
     struct dfa *d;
     int trans[];
{
  position_set grps[(1 << 8)];
  charclass labels[(1 << 8)];
  int ngrps = 0;
  position pos;
  charclass matches;
  int matchesf;
  charclass intersect;
  int intersectf;
  charclass leftovers;
  int leftoversf;
  static charclass letters;
  static charclass newline;
  position_set follows;
  position_set tmp;
  int state;
  int wants_newline;
  int state_newline;
  int wants_letter;
  int state_letter;
  static initialized;
  int i, j, k;


  if (kcov_count(1275) || (! initialized) && kcov_then(1275))
    {
      initialized = 1;
      for (i = 0; kcov_count(1276) || (i < (1 << 8)) && kcov_then(1276); ++i)
 if (kcov_count(1277) || ((1 && ((*__ctype_b_loc ())[(int) ((i))] & (unsigned short int) _ISalnum))) && kcov_then(1277))
   setbit(i, letters);
      setbit('\n', newline);
    }

  zeroset(matches);

  for (i = 0; kcov_count(1278) || (i < d->states[s].elems.nelem) && kcov_then(1278); ++i)
    {
      pos = d->states[s].elems.elems[i];
      if (kcov_count(1279) || (d->tokens[pos.strchr] >= 0 && d->tokens[pos.strchr] < (1 << 8)) && kcov_then(1279))
 setbit(d->tokens[pos.strchr], matches);
      else if (kcov_count(1280) || (d->tokens[pos.strchr] >= CSET) && kcov_then(1280))
 copyset(d->charclasses[d->tokens[pos.strchr] - CSET], matches);
      else
 continue;



      if (kcov_count(1281) || (pos.constraint != 0xFF) && kcov_then(1281))
 {
   if (kcov_count(1282) || (! ((pos.constraint) & 1 << ((kcov_count(1283) || ((d->states[s].newline)) && kcov_then(1283) ? 2 : 0) + (kcov_count(1284) || ((1)) && kcov_then(1284) ? 1 : 0) + 4))) && kcov_then(1282))

     clrbit('\n', matches);
   if (kcov_count(1285) || (! ((pos.constraint) & 1 << ((kcov_count(1286) || ((d->states[s].newline)) && kcov_then(1286) ? 2 : 0) + (kcov_count(1287) || ((0)) && kcov_then(1287) ? 1 : 0) + 4))) && kcov_then(1285))

     for (j = 0; kcov_count(1288) || (j < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int)))) && kcov_then(1288); ++j)
       matches[j] &= newline[j];
   if (kcov_count(1289) || (! ((pos.constraint) & 1 << ((kcov_count(1290) || ((d->states[s].letter)) && kcov_then(1290) ? 2 : 0) + (kcov_count(1291) || ((1)) && kcov_then(1291) ? 1 : 0)))) && kcov_then(1289))

     for (j = 0; kcov_count(1292) || (j < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int)))) && kcov_then(1292); ++j)
       matches[j] &= ~letters[j];
   if (kcov_count(1293) || (! ((pos.constraint) & 1 << ((kcov_count(1294) || ((d->states[s].letter)) && kcov_then(1294) ? 2 : 0) + (kcov_count(1295) || ((0)) && kcov_then(1295) ? 1 : 0)))) && kcov_then(1293))

     for (j = 0; kcov_count(1296) || (j < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int)))) && kcov_then(1296); ++j)
       matches[j] &= letters[j];


   for (j = 0; kcov_count(1297) || (j < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))) && !matches[j]) && kcov_then(1297); ++j)
     ;
   if (kcov_count(1298) || (j == (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int)))) && kcov_then(1298))
     continue;
 }

      for (j = 0; kcov_count(1299) || (j < ngrps) && kcov_then(1299); ++j)
 {



   if (kcov_count(1300) || (d->tokens[pos.strchr] >= 0 && d->tokens[pos.strchr] < (1 << 8)
       && !tstbit(d->tokens[pos.strchr], labels[j])) && kcov_then(1300))
     continue;



   intersectf = 0;
   for (k = 0; kcov_count(1301) || (k < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int)))) && kcov_then(1301); ++k)
     kcov_count(1302) || ((intersect[k] = matches[k] & labels[j][k])) && kcov_then(1302) ? intersectf = 1 : 0;
   if (kcov_count(1303) || (! intersectf) && kcov_then(1303))
     continue;


   leftoversf = matchesf = 0;
   for (k = 0; kcov_count(1304) || (k < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int)))) && kcov_then(1304); ++k)
     {

       int match = matches[k], label = labels[j][k];

       kcov_count(1305) || ((leftovers[k] = ~match & label)) && kcov_then(1305) ? leftoversf = 1 : 0;
       kcov_count(1306) || ((matches[k] = match & ~label)) && kcov_then(1306) ? matchesf = 1 : 0;
     }


   if (kcov_count(1307) || (leftoversf) && kcov_then(1307))
     {
       copyset(leftovers, labels[ngrps]);
       copyset(intersect, labels[j]);
       ((grps[ngrps].elems) = (position *) xmalloc_1((d->nleaves) * sizeof (position)));
       copy(&grps[j], &grps[ngrps]);
       ++ngrps;
     }



   grps[j].elems[grps[j].nelem++] = pos;



   if (kcov_count(1308) || (! matchesf) && kcov_then(1308))
     break;
 }



      if (kcov_count(1309) || (j == ngrps) && kcov_then(1309))
 {
   copyset(matches, labels[ngrps]);
   zeroset(matches);
   ((grps[ngrps].elems) = (position *) xmalloc_1((d->nleaves) * sizeof (position)));
   grps[ngrps].nelem = 1;
   grps[ngrps].elems[0] = pos;
   ++ngrps;
 }
    }

  ((follows.elems) = (position *) xmalloc_1((d->nleaves) * sizeof (position)));
  ((tmp.elems) = (position *) xmalloc_1((d->nleaves) * sizeof (position)));




  if (kcov_count(1310) || (d->searchflag) && kcov_then(1310))
    {
      wants_newline = 0;
      wants_letter = 0;
      for (i = 0; kcov_count(1311) || (i < d->states[0].elems.nelem) && kcov_then(1311); ++i)
 {
   if (kcov_count(1312) || ((((d->states[0].elems.elems[i].constraint) & 0xc0) >> 2 != ((d->states[0].elems.elems[i].constraint) & 0x30))) && kcov_then(1312))
     wants_newline = 1;
   if (kcov_count(1313) || ((((d->states[0].elems.elems[i].constraint) & 0x0c) >> 2 != ((d->states[0].elems.elems[i].constraint) & 0x03))) && kcov_then(1313))
     wants_letter = 1;
 }
      copy(&d->states[0].elems, &follows);
      state = state_index(d, &follows, 0, 0);
      if (kcov_count(1314) || (wants_newline) && kcov_then(1314))
 state_newline = state_index(d, &follows, 1, 0);
      else
 state_newline = state;
      if (kcov_count(1315) || (wants_letter) && kcov_then(1315))
 state_letter = state_index(d, &follows, 0, 1);
      else
 state_letter = state;
      for (i = 0; kcov_count(1316) || (i < (1 << 8)) && kcov_then(1316); ++i)
 if (kcov_count(1317) || (i == '\n') && kcov_then(1317))
   trans[i] = state_newline;
 else if (kcov_count(1318) || ((1 && ((*__ctype_b_loc ())[(int) ((i))] & (unsigned short int) _ISalnum))) && kcov_then(1318))
   trans[i] = state_letter;
 else
   trans[i] = state;
    }
  else
    for (i = 0; kcov_count(1319) || (i < (1 << 8)) && kcov_then(1319); ++i)
      trans[i] = -1;

  for (i = 0; kcov_count(1320) || (i < ngrps) && kcov_then(1320); ++i)
    {
      follows.nelem = 0;



      for (j = 0; kcov_count(1321) || (j < grps[i].nelem) && kcov_then(1321); ++j)
 for (k = 0; kcov_count(1322) || (k < d->follows[grps[i].elems[j].strchr].nelem) && kcov_then(1322); ++k)
   insert(d->follows[grps[i].elems[j].strchr].elems[k], &follows);



      if (kcov_count(1323) || (d->searchflag) && kcov_then(1323))
 for (j = 0; kcov_count(1324) || (j < d->states[0].elems.nelem) && kcov_then(1324); ++j)
   insert(d->states[0].elems.elems[j], &follows);


      wants_newline = 0;
      if (kcov_count(1325) || (tstbit('\n', labels[i])) && kcov_then(1325))
 for (j = 0; kcov_count(1326) || (j < follows.nelem) && kcov_then(1326); ++j)
   if (kcov_count(1327) || ((((follows.elems[j].constraint) & 0xc0) >> 2 != ((follows.elems[j].constraint) & 0x30))) && kcov_then(1327))
     wants_newline = 1;

      wants_letter = 0;
      for (j = 0; kcov_count(1328) || (j < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int)))) && kcov_then(1328); ++j)
 if (kcov_count(1329) || (labels[i][j] & letters[j]) && kcov_then(1329))
   break;
      if (kcov_count(1330) || (j < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int)))) && kcov_then(1330))
 for (j = 0; kcov_count(1331) || (j < follows.nelem) && kcov_then(1331); ++j)
   if (kcov_count(1332) || ((((follows.elems[j].constraint) & 0x0c) >> 2 != ((follows.elems[j].constraint) & 0x03))) && kcov_then(1332))
     wants_letter = 1;


      state = state_index(d, &follows, 0, 0);
      if (kcov_count(1333) || (wants_newline) && kcov_then(1333))
 state_newline = state_index(d, &follows, 1, 0);
      else
 state_newline = state;
      if (kcov_count(1334) || (wants_letter) && kcov_then(1334))
 state_letter = state_index(d, &follows, 0, 1);
      else
 state_letter = state;


      for (j = 0; kcov_count(1335) || (j < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int)))) && kcov_then(1335); ++j)
 for (k = 0; kcov_count(1336) || (k < (8 * sizeof (int))) && kcov_then(1336); ++k)
   if (kcov_count(1337) || (labels[i][j] & 1 << k) && kcov_then(1337))
     {
       int c = j * (8 * sizeof (int)) + k;

       if (kcov_count(1338) || (c == '\n') && kcov_then(1338))
  trans[c] = state_newline;
       else if (kcov_count(1339) || ((1 && ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISalnum))) && kcov_then(1339))
  trans[c] = state_letter;
       else if (kcov_count(1340) || (c < (1 << 8)) && kcov_then(1340))
  trans[c] = state;
     }
    }

  for (i = 0; kcov_count(1341) || (i < ngrps) && kcov_then(1341); ++i)
    free(grps[i].elems);
  free(follows.elems);
  free(tmp.elems);
}
# 8315 "grep.c"
static void
build_state(s, d)
     int s;
     struct dfa *d;
{
  int *trans;
  int i;





  if (kcov_count(1342) || (d->trcount >= 1024) && kcov_then(1342))
    {
      for (i = 0; kcov_count(1343) || (i < d->tralloc) && kcov_then(1343); ++i)
 if (kcov_count(1344) || (d->trans[i]) && kcov_then(1344))
   {
     free((ptr_t) d->trans[i]);
     d->trans[i] = ((void *)0);
   }
 else if (kcov_count(1345) || (d->fails[i]) && kcov_then(1345))
   {
     free((ptr_t) d->fails[i]);
     d->fails[i] = ((void *)0);
   }
      d->trcount = 0;
    }

  ++d->trcount;


  d->success[s] = 0;
  if (kcov_count(1346) || (((((*d).states[s].constraint) & 1 << ((kcov_count(1347) || ((d->states[s].newline)) && kcov_then(1347) ? 2 : 0) + (kcov_count(1348) || ((1)) && kcov_then(1348) ? 1 : 0) + 4)) && (((*d).states[s].constraint) & 1 << ((kcov_count(1349) || ((d->states[s].letter)) && kcov_then(1349) ? 2 : 0) + (kcov_count(1350) || ((0)) && kcov_then(1350) ? 1 : 0))))) && kcov_then(1346))

    d->success[s] |= 4;
  if (kcov_count(1351) || (((((*d).states[s].constraint) & 1 << ((kcov_count(1352) || ((d->states[s].newline)) && kcov_then(1352) ? 2 : 0) + (kcov_count(1353) || ((0)) && kcov_then(1353) ? 1 : 0) + 4)) && (((*d).states[s].constraint) & 1 << ((kcov_count(1354) || ((d->states[s].letter)) && kcov_then(1354) ? 2 : 0) + (kcov_count(1355) || ((1)) && kcov_then(1355) ? 1 : 0))))) && kcov_then(1351))

    d->success[s] |= 2;
  if (kcov_count(1356) || (((((*d).states[s].constraint) & 1 << ((kcov_count(1357) || ((d->states[s].newline)) && kcov_then(1357) ? 2 : 0) + (kcov_count(1358) || ((0)) && kcov_then(1358) ? 1 : 0) + 4)) && (((*d).states[s].constraint) & 1 << ((kcov_count(1359) || ((d->states[s].letter)) && kcov_then(1359) ? 2 : 0) + (kcov_count(1360) || ((0)) && kcov_then(1360) ? 1 : 0))))) && kcov_then(1356))

    d->success[s] |= 1;

  ((trans) = (int *) xmalloc_1(((1 << 8)) * sizeof (int)));
  dfastate(s, d, trans);




  for (i = 0; kcov_count(1361) || (i < (1 << 8)) && kcov_then(1361); ++i)
    if (kcov_count(1362) || (trans[i] >= d->tralloc) && kcov_then(1362))
      {
 int oldalloc = d->tralloc;

 while (kcov_count(1363) || (trans[i] >= d->tralloc) && kcov_then(1363))
   d->tralloc *= 2;
 ((d->realtrans) = (int * *) xrealloc_1((ptr_t) (d->realtrans), (d->tralloc + 1) * sizeof (int *)));
 d->trans = d->realtrans + 1;
 ((d->fails) = (int * *) xrealloc_1((ptr_t) (d->fails), (d->tralloc) * sizeof (int *)));
 ((d->success) = (int *) xrealloc_1((ptr_t) (d->success), (d->tralloc) * sizeof (int)));
 ((d->newlines) = (int *) xrealloc_1((ptr_t) (d->newlines), (d->tralloc) * sizeof (int)));
 while (kcov_count(1364) || (oldalloc < d->tralloc) && kcov_then(1364))
   {
     d->trans[oldalloc] = ((void *)0);
     d->fails[oldalloc++] = ((void *)0);
   }
      }



  d->newlines[s] = trans['\n'];
  trans['\n'] = -1;

  if (kcov_count(1365) || (((*d).states[s].constraint)) && kcov_then(1365))
    d->fails[s] = trans;
  else
    d->trans[s] = trans;
}

static void
build_state_zero(d)
     struct dfa *d;
{
  d->tralloc = 1;
  d->trcount = 0;
  ((d->realtrans) = (int * *) xcalloc((d->tralloc + 1), sizeof (int *)));
  d->trans = d->realtrans + 1;
  ((d->fails) = (int * *) xcalloc((d->tralloc), sizeof (int *)));
  ((d->success) = (int *) xmalloc_1((d->tralloc) * sizeof (int)));
  ((d->newlines) = (int *) xmalloc_1((d->tralloc) * sizeof (int)));
  build_state(0, d);
}
# 8420 "grep.c"
char *
dfaexec(d, begin, end, newline, count, backref)
     struct dfa *d;
     char *begin;
     char *end;
     int newline;
     int *count;
     int *backref;
{
  register s, s1, tmp;
  register unsigned char *p;
  register **trans, *t;

  static sbit[(1 << 8)];
  static sbit_init;

  if (kcov_count(1366) || (! sbit_init) && kcov_then(1366))
    {
      int i;

      sbit_init = 1;
      for (i = 0; kcov_count(1367) || (i < (1 << 8)) && kcov_then(1367); ++i)
 if (kcov_count(1368) || (i == '\n') && kcov_then(1368))
   sbit[i] = 4;
 else if (kcov_count(1369) || ((1 && ((*__ctype_b_loc ())[(int) ((i))] & (unsigned short int) _ISalnum))) && kcov_then(1369))
   sbit[i] = 2;
 else
   sbit[i] = 1;
    }

  if (kcov_count(1370) || (! d->tralloc) && kcov_then(1370))
    build_state_zero(d);

  s = s1 = 0;
  p = (unsigned char *) begin;
  trans = d->trans;
  *end = '\n';

  for (;kcov_count(1371) || kcov_then(1371);)
    {

      if (kcov_count(1372) || ((t = trans[s]) != 0) && kcov_then(1372))
 do
   {
     s1 = t[*p++];
     if (kcov_count(1374) || (! (t = trans[s1])) && kcov_then(1374))
       goto last_was_s;
     s = t[*p++];
   }
        while (kcov_count(1373) || ((t = trans[s]) != 0) && kcov_then(1373));
      goto last_was_s1;
    last_was_s:
      tmp = s, s = s1, s1 = tmp;
    last_was_s1:

      if (kcov_count(1375) || (s >= 0 && p <= (unsigned char *) end && d->fails[s]) && kcov_then(1375))
 {
   if (kcov_count(1376) || (d->success[s] & sbit[*p]) && kcov_then(1376))
     {
       if (kcov_count(1377) || (backref) && kcov_then(1377))
  if (kcov_count(1378) || (d->states[s].backref) && kcov_then(1378))
    *backref = 1;
  else
    *backref = 0;
       return (char *) p;
     }

   s1 = s;
   s = d->fails[s][*p++];
   continue;
 }


      if (kcov_count(1379) || (count && (char *) p <= end && p[-1] == '\n') && kcov_then(1379))
 ++*count;


      if (kcov_count(1380) || ((char *) p > end) && kcov_then(1380))
 return ((void *)0);

      if (kcov_count(1381) || (s >= 0) && kcov_then(1381))
 {
   build_state(s, d);
   trans = d->trans;
   continue;
 }

      if (kcov_count(1382) || (p[-1] == '\n' && newline) && kcov_then(1382))
 {
   s = d->newlines[s1];
   continue;
 }

      s = 0;
    }
}



void
dfainit(d)
     struct dfa *d;
{
  d->calloc = 1;
  ((d->charclasses) = (charclass *) xmalloc_1((d->calloc) * sizeof (charclass)));
  d->cindex = 0;

  d->talloc = 1;
  ((d->tokens) = (token *) xmalloc_1((d->talloc) * sizeof (token)));
  d->tindex = d->depth = d->nleaves = d->nregexps = 0;

  d->searchflag = 0;
  d->tralloc = 0;

  d->musts = 0;
}


void
dfacomp(s, len, d, searchflag)
     char *s;
     size_t len;
     struct dfa *d;
     int searchflag;
{
  if (kcov_count(1383) || (case_fold) && kcov_then(1383))
    {
      char *copy;
      int i;

      copy = malloc(len);
      if (kcov_count(1384) || (!copy) && kcov_then(1384))
 dfaerror("out of memory");


      case_fold = 0;
      for (i = 0; kcov_count(1385) || (i < len) && kcov_then(1385); ++i)
 if (kcov_count(1386) || ((1 && ((*__ctype_b_loc ())[(int) ((s[i]))] & (unsigned short int) _ISupper))) && kcov_then(1386))
   copy[i] = tolower(s[i]);
 else
   copy[i] = s[i];

      dfainit(d);
      dfaparse(copy, len, d);
      free(copy);
      dfamust(d);
      d->cindex = d->tindex = d->depth = d->nleaves = d->nregexps = 0;
      case_fold = 1;
      dfaparse(s, len, d);
      dfaanalyze(d, searchflag);
    }
  else
    {
        dfainit(d);
        dfaparse(s, len, d);
 dfamust(d);
        dfaanalyze(d, searchflag);
    }
}


void
dfafree(d)
     struct dfa *d;
{
  int i;
  struct dfamust *dm, *ndm;

  free((ptr_t) d->charclasses);
  free((ptr_t) d->tokens);
  for (i = 0; kcov_count(1387) || (i < d->sindex) && kcov_then(1387); ++i)
    free((ptr_t) d->states[i].elems.elems);
  free((ptr_t) d->states);
  for (i = 0; kcov_count(1388) || (i < d->tindex) && kcov_then(1388); ++i)
    if (kcov_count(1389) || (d->follows[i].elems) && kcov_then(1389))
      free((ptr_t) d->follows[i].elems);
  free((ptr_t) d->follows);
  for (i = 0; kcov_count(1390) || (i < d->tralloc) && kcov_then(1390); ++i)
    if (kcov_count(1391) || (d->trans[i]) && kcov_then(1391))
      free((ptr_t) d->trans[i]);
    else if (kcov_count(1392) || (d->fails[i]) && kcov_then(1392))
      free((ptr_t) d->fails[i]);
  free((ptr_t) d->realtrans);
  free((ptr_t) d->fails);
  free((ptr_t) d->newlines);
  for (dm = d->musts; kcov_count(1393) || (dm) && kcov_then(1393); dm = ndm)
    {
      ndm = dm->next;
      free(dm->must);
      free((ptr_t) dm);
    }
}
# 8693 "grep.c"
static char *
icatalloc(old, new)
     char *old;
     char *new;
{
  char *result;
  int oldsize, newsize;

  newsize = kcov_count(1394) || ((new == ((void *)0))) && kcov_then(1394) ? 0 : strlen(new);
  if (kcov_count(1395) || (old == ((void *)0)) && kcov_then(1395))
    oldsize = 0;
  else if (kcov_count(1396) || (newsize == 0) && kcov_then(1396))
    return old;
  else oldsize = strlen(old);
  if (kcov_count(1397) || (old == ((void *)0)) && kcov_then(1397))
    result = (char *) malloc(newsize + 1);
  else
    result = (char *) realloc((void *) old, oldsize + newsize + 1);
  if (kcov_count(1398) || (result != ((void *)0) && new != ((void *)0)) && kcov_then(1398))
    (void) strcpy(result + oldsize, new);
  return result;
}

static char *
icpyalloc(string)
     char *string;
{
  return icatalloc((char *) ((void *)0), string);
}

static char *
istrstr(lookin, lookfor)
     char *lookin;
     char *lookfor;
{
  char *cp;
  int len;

  len = strlen(lookfor);
  for (cp = lookin; kcov_count(1399) || (*cp != '\0') && kcov_then(1399); ++cp)
    if (kcov_count(1400) || (strncmp(cp, lookfor, len) == 0) && kcov_then(1400))
      return cp;
  return ((void *)0);
}

static void
ifree(cp)
     char *cp;
{
  if (kcov_count(1401) || (cp != ((void *)0)) && kcov_then(1401))
    free(cp);
}

static void
freelist(cpp)
     char **cpp;
{
  int i;

  if (kcov_count(1402) || (cpp == ((void *)0)) && kcov_then(1402))
    return;
  for (i = 0; kcov_count(1403) || (cpp[i] != ((void *)0)) && kcov_then(1403); ++i)
    {
      free(cpp[i]);
      cpp[i] = ((void *)0);
    }
}

static char **
enlist(cpp, new, len)
     char **cpp;
     char *new;
     int len;
{
  int i, j;

  if (kcov_count(1404) || (cpp == ((void *)0)) && kcov_then(1404))
    return ((void *)0);
  if (kcov_count(1405) || ((new = icpyalloc(new)) == ((void *)0)) && kcov_then(1405))
    {
      freelist(cpp);
      return ((void *)0);
    }
  new[len] = '\0';

  for (i = 0; kcov_count(1406) || (cpp[i] != ((void *)0)) && kcov_then(1406); ++i)
    if (kcov_count(1407) || (istrstr(cpp[i], new) != ((void *)0)) && kcov_then(1407))
      {
 free(new);
 return cpp;
      }

  j = 0;
  while (kcov_count(1408) || (cpp[j] != ((void *)0)) && kcov_then(1408))
    if (kcov_count(1409) || (istrstr(new, cpp[j]) == ((void *)0)) && kcov_then(1409))
      ++j;
    else
      {
 free(cpp[j]);
 if (kcov_count(1410) || (--i == j) && kcov_then(1410))
   break;
 cpp[j] = cpp[i];
 cpp[i] = ((void *)0);
      }

  cpp = (char **) realloc((char *) cpp, (i + 2) * sizeof *cpp);
  if (kcov_count(1411) || (cpp == ((void *)0)) && kcov_then(1411))
    return ((void *)0);
  cpp[i] = new;
  cpp[i + 1] = ((void *)0);
  return cpp;
}




static char **
comsubs(left, right)
     char *left;
     char *right;
{
  char **cpp;
  char *lcp;
  char *rcp;
  int i, len;

  if (kcov_count(1412) || (left == ((void *)0) || right == ((void *)0)) && kcov_then(1412))
    return ((void *)0);
  cpp = (char **) malloc(sizeof *cpp);
  if (kcov_count(1413) || (cpp == ((void *)0)) && kcov_then(1413))
    return ((void *)0);
  cpp[0] = ((void *)0);
  for (lcp = left; kcov_count(1414) || (*lcp != '\0') && kcov_then(1414); ++lcp)
    {
      len = 0;
      rcp = strchr(right, *lcp);
      while (kcov_count(1415) || (rcp != ((void *)0)) && kcov_then(1415))
 {
   for (i = 1; kcov_count(1416) || (lcp[i] != '\0' && lcp[i] == rcp[i]) && kcov_then(1416); ++i)
     ;
   if (kcov_count(1417) || (i > len) && kcov_then(1417))
     len = i;
   rcp = strchr(rcp + 1, *lcp);
 }
      if (kcov_count(1418) || (len == 0) && kcov_then(1418))
 continue;
      if (kcov_count(1419) || ((cpp = enlist(cpp, lcp, len)) == ((void *)0)) && kcov_then(1419))
 break;
    }
  return cpp;
}

static char **
addlists(old, new)
char **old;
char **new;
{
  int i;

  if (kcov_count(1420) || (old == ((void *)0) || new == ((void *)0)) && kcov_then(1420))
    return ((void *)0);
  for (i = 0; kcov_count(1421) || (new[i] != ((void *)0)) && kcov_then(1421); ++i)
    {
      old = enlist(old, new[i], strlen(new[i]));
      if (kcov_count(1422) || (old == ((void *)0)) && kcov_then(1422))
 break;
    }
  return old;
}



static char **
inboth(left, right)
     char **left;
     char **right;
{
  char **both;
  char **temp;
  int lnum, rnum;

  if (kcov_count(1423) || (left == ((void *)0) || right == ((void *)0)) && kcov_then(1423))
    return ((void *)0);
  both = (char **) malloc(sizeof *both);
  if (kcov_count(1424) || (both == ((void *)0)) && kcov_then(1424))
    return ((void *)0);
  both[0] = ((void *)0);
  for (lnum = 0; kcov_count(1425) || (left[lnum] != ((void *)0)) && kcov_then(1425); ++lnum)
    {
      for (rnum = 0; kcov_count(1426) || (right[rnum] != ((void *)0)) && kcov_then(1426); ++rnum)
 {
   temp = comsubs(left[lnum], right[rnum]);
   if (kcov_count(1427) || (temp == ((void *)0)) && kcov_then(1427))
     {
       freelist(both);
       return ((void *)0);
     }
   both = addlists(both, temp);
   freelist(temp);
   if (kcov_count(1428) || (both == ((void *)0)) && kcov_then(1428))
     return ((void *)0);
 }
    }
  return both;
}

typedef struct
{
  char **in;
  char *left;
  char *right;
  char *is;
} must;

static void
resetmust(mp)
must *mp;
{
  mp->left[0] = mp->right[0] = mp->is[0] = '\0';
  freelist(mp->in);
}

static void
dfamust(dfa)
struct dfa *dfa;
{
  must *musts;
  must *mp;
  char *result;
  int ri;
  int i;
  int exact;
  token t;
  static must must0;
  struct dfamust *dm;

  result = "";
  exact = 0;
  musts = (must *) malloc((dfa->tindex + 1) * sizeof *musts);
  if (kcov_count(1429) || (musts == ((void *)0)) && kcov_then(1429))
    return;
  mp = musts;
  for (i = 0; kcov_count(1430) || (i <= dfa->tindex) && kcov_then(1430); ++i)
    mp[i] = must0;
  for (i = 0; kcov_count(1431) || (i <= dfa->tindex) && kcov_then(1431); ++i)
    {
      mp[i].in = (char **) malloc(sizeof *mp[i].in);
      mp[i].left = malloc(2);
      mp[i].right = malloc(2);
      mp[i].is = malloc(2);
      if (kcov_count(1432) || (mp[i].in == ((void *)0) || mp[i].left == ((void *)0) ||
   mp[i].right == ((void *)0) || mp[i].is == ((void *)0)) && kcov_then(1432))
 goto done;
      mp[i].left[0] = mp[i].right[0] = mp[i].is[0] = '\0';
      mp[i].in[0] = ((void *)0);
    }
# 8958 "grep.c"
  for (ri = 0; kcov_count(1433) || (ri < dfa->tindex) && kcov_then(1433); ++ri)
    {
      switch (t = dfa->tokens[ri])
 {
 case LPAREN:kcov_count(1434);
kcov_then(1434);

 case RPAREN:kcov_count(1435);
kcov_then(1435);

   goto done;
 case EMPTY:kcov_count(1436);
kcov_then(1436);

 case BEGLINE:kcov_count(1437);
kcov_then(1437);

 case ENDLINE:kcov_count(1438);
kcov_then(1438);

 case BEGWORD:kcov_count(1439);
kcov_then(1439);

 case ENDWORD:kcov_count(1440);
kcov_then(1440);

 case LIMWORD:kcov_count(1441);
kcov_then(1441);

 case NOTLIMWORD:kcov_count(1442);
kcov_then(1442);

 case BACKREF:kcov_count(1443);
kcov_then(1443);

   resetmust(mp);
   break;
 case STAR:kcov_count(1444);
kcov_then(1444);

 case QMARK:kcov_count(1445);
kcov_then(1445);

   if (kcov_count(1446) || (mp <= musts) && kcov_then(1446))
     goto done;
   --mp;
   resetmust(mp);
   break;
 case OR:kcov_count(1447);
kcov_then(1447);

 case ORTOP:kcov_count(1448);
kcov_then(1448);

   if (kcov_count(1449) || (mp < &musts[2]) && kcov_then(1449))
     goto done;
   {
     char **new;
     must *lmp;
     must *rmp;
     int j, ln, rn, n;

     rmp = --mp;
     lmp = --mp;

     if (kcov_count(1450) || (strcmp(lmp->is, rmp->is) != 0) && kcov_then(1450))
       lmp->is[0] = '\0';

     i = 0;
     while (kcov_count(1451) || (lmp->left[i] != '\0' && lmp->left[i] == rmp->left[i]) && kcov_then(1451))
       ++i;
     lmp->left[i] = '\0';

     ln = strlen(lmp->right);
     rn = strlen(rmp->right);
     n = ln;
     if (kcov_count(1452) || (n > rn) && kcov_then(1452))
       n = rn;
     for (i = 0; kcov_count(1453) || (i < n) && kcov_then(1453); ++i)
       if (kcov_count(1454) || (lmp->right[ln - i - 1] != rmp->right[rn - i - 1]) && kcov_then(1454))
  break;
     for (j = 0; kcov_count(1455) || (j < i) && kcov_then(1455); ++j)
       lmp->right[j] = lmp->right[(ln - i) + j];
     lmp->right[j] = '\0';
     new = inboth(lmp->in, rmp->in);
     if (kcov_count(1456) || (new == ((void *)0)) && kcov_then(1456))
       goto done;
     freelist(lmp->in);
     free((char *) lmp->in);
     lmp->in = new;
   }
   break;
 case PLUS:kcov_count(1457);
kcov_then(1457);

   if (kcov_count(1458) || (mp <= musts) && kcov_then(1458))
     goto done;
   --mp;
   mp->is[0] = '\0';
   break;
 case END:kcov_count(1459);
kcov_then(1459);

   if (kcov_count(1460) || (mp != &musts[1]) && kcov_then(1460))
     goto done;
   for (i = 0; kcov_count(1461) || (musts[0].in[i] != ((void *)0)) && kcov_then(1461); ++i)
     if (kcov_count(1462) || (strlen(musts[0].in[i]) > strlen(result)) && kcov_then(1462))
       result = musts[0].in[i];
   if (kcov_count(1463) || (strcmp(result, musts[0].is) == 0) && kcov_then(1463))
     exact = 1;
   goto done;
 case CAT:kcov_count(1464);
kcov_then(1464);

   if (kcov_count(1465) || (mp < &musts[2]) && kcov_then(1465))
     goto done;
   {
     must *lmp;
     must *rmp;

     rmp = --mp;
     lmp = --mp;



     lmp->in = addlists(lmp->in, rmp->in);
     if (kcov_count(1466) || (lmp->in == ((void *)0)) && kcov_then(1466))
       goto done;
     if (kcov_count(1467) || (lmp->right[0] != '\0' &&
  rmp->left[0] != '\0') && kcov_then(1467))
       {
  char *tp;

  tp = icpyalloc(lmp->right);
  if (kcov_count(1468) || (tp == ((void *)0)) && kcov_then(1468))
    goto done;
  tp = icatalloc(tp, rmp->left);
  if (kcov_count(1469) || (tp == ((void *)0)) && kcov_then(1469))
    goto done;
  lmp->in = enlist(lmp->in, tp,
     strlen(tp));
  free(tp);
  if (kcov_count(1470) || (lmp->in == ((void *)0)) && kcov_then(1470))
    goto done;
       }

     if (kcov_count(1471) || (lmp->is[0] != '\0') && kcov_then(1471))
       {
  lmp->left = icatalloc(lmp->left,
          rmp->left);
  if (kcov_count(1472) || (lmp->left == ((void *)0)) && kcov_then(1472))
    goto done;
       }

     if (kcov_count(1473) || (rmp->is[0] == '\0') && kcov_then(1473))
       lmp->right[0] = '\0';
     lmp->right = icatalloc(lmp->right, rmp->right);
     if (kcov_count(1474) || (lmp->right == ((void *)0)) && kcov_then(1474))
       goto done;

     if (kcov_count(1475) || (lmp->is[0] != '\0' && rmp->is[0] != '\0') && kcov_then(1475))
       {
  lmp->is = icatalloc(lmp->is, rmp->is);
  if (kcov_count(1476) || (lmp->is == ((void *)0)) && kcov_then(1476))
    goto done;
       }
     else
       lmp->is[0] = '\0';
   }
   break;
 default:kcov_count(1477);
kcov_then(1477);

   if (kcov_count(1478) || (t < END) && kcov_then(1478))
     {

       goto done;
     }
   else if (kcov_count(1479) || (t == '\0') && kcov_then(1479))
     {

       goto done;
     }
   else if (kcov_count(1480) || (t >= CSET) && kcov_then(1480))
     {

       resetmust(mp);
     }
   else
     {

       resetmust(mp);
       mp->is[0] = mp->left[0] = mp->right[0] = t;
       mp->is[1] = mp->left[1] = mp->right[1] = '\0';
       mp->in = enlist(mp->in, mp->is, 1);
       if (kcov_count(1481) || (mp->in == ((void *)0)) && kcov_then(1481))
  goto done;
     }
   break;
 }
# 9132 "grep.c"
      ++mp;
    }
 done:
  if (kcov_count(1482) || (strlen(result)) && kcov_then(1482))
    {
      dm = (struct dfamust *) malloc(sizeof (struct dfamust));
      dm->exact = exact;
      dm->must = malloc(strlen(result) + 1);
      strcpy(dm->must, result);
      dm->next = dfa->musts;
      dfa->musts = dm;
    }
  mp = musts;
  for (i = 0; kcov_count(1483) || (i <= dfa->tindex) && kcov_then(1483); ++i)
    {
      freelist(mp[i].in);
      ifree((char *) mp[i].in);
      ifree(mp[i].left);
      ifree(mp[i].right);
      ifree(mp[i].is);
    }
  free((char *) mp);
}
# 9187 "grep.c"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include-fixed/limits.h" 1 3 4
# 11 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include-fixed/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include-fixed/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include-fixed/limits.h" 1 3 4
# 122 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 46 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 47 "/usr/include/limits.h" 2 3 4
# 145 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 157 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 39 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 40 "/usr/include/bits/local_lim.h" 2 3 4
# 158 "/usr/include/bits/posix1_lim.h" 2 3 4
# 146 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 150 "/usr/include/limits.h" 2 3 4
# 123 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include-fixed/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include-fixed/syslimits.h" 2 3 4
# 12 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include-fixed/limits.h" 2 3 4
# 9188 "grep.c" 2
# 9228 "grep.c"
extern char *xmalloc();



# 1 "kwset.h" 1
# 22 "kwset.h"
struct kwsmatch
{
  int strchr;
  char *beg[1];
  size_t size[1];
};



typedef void *kwset_t;





extern kwset_t kwsalloc(char *);




extern char *kwsincr(kwset_t, char *, size_t);



extern char *kwsprep(kwset_t);







extern char *kwsexec(kwset_t, char *, size_t, struct kwsmatch *);


extern void kwsfree(kwset_t);
# 9233 "grep.c" 2
# 1 "obstack.h" 1
# 134 "obstack.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 149 "/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 135 "obstack.h" 2
# 144 "obstack.h"
struct _obstack_chunk
{
  char *limit;
  struct _obstack_chunk *prev;
  char contents[4];
};

struct obstack
{
  long chunk_size;
  struct _obstack_chunk* chunk;
  char *object_base;
  char *next_free;
  char *chunk_limit;
  ptrdiff_t temp;
  int alignment_mask;
  struct _obstack_chunk *(*chunkfun) ();
  void (*freefun) ();
  char *extra_arg;
  unsigned use_extra_arg:1;
  unsigned maybe_empty_object:1;



};




extern void _obstack_newchunk (struct obstack *, int);
extern void _obstack_free (struct obstack *, void *);
extern void _obstack_begin (struct obstack *, int, int,
       void *(*) (), void (*) ());
extern void _obstack_begin_1 (struct obstack *, int, int,
         void *(*) (), void (*) (), void *);
# 191 "obstack.h"
void obstack_init (struct obstack *obstack);

void * obstack_alloc (struct obstack *obstack, int size);

void * obstack_copy (struct obstack *obstack, void *address, int size);
void * obstack_copy0 (struct obstack *obstack, void *address, int size);

void obstack_free (struct obstack *obstack, void *block);

void obstack_blank (struct obstack *obstack, int size);

void obstack_grow (struct obstack *obstack, void *data, int size);
void obstack_grow0 (struct obstack *obstack, void *data, int size);

void obstack_1grow (struct obstack *obstack, int data_char);
void obstack_ptr_grow (struct obstack *obstack, void *data);
void obstack_int_grow (struct obstack *obstack, int data);

void * obstack_finish (struct obstack *obstack);

int obstack_object_size (struct obstack *obstack);

int obstack_room (struct obstack *obstack);
void obstack_1grow_fast (struct obstack *obstack, int data_char);
void obstack_ptr_grow_fast (struct obstack *obstack, void *data);
void obstack_int_grow_fast (struct obstack *obstack, int data);
void obstack_blank_fast (struct obstack *obstack, int size);

void * obstack_base (struct obstack *obstack);
void * obstack_next_free (struct obstack *obstack);
int obstack_alignment_mask (struct obstack *obstack);
int obstack_chunk_size (struct obstack *obstack);
# 9234 "grep.c" 2






struct tree
{
  struct tree *llink;
  struct tree *rlink;
  struct trie *trie;
  unsigned char label;
  char balance;
};


struct trie
{
  unsigned int accepting;
  struct tree *links;
  struct trie *parent;
  struct trie *next;
  struct trie *fail;
  int depth;
  int shift;
  int maxshift;
};


struct kwset
{
  struct obstack obstack;
  int words;
  struct trie *trie;
  int mind;
  int maxd;
  unsigned char delta[((__SCHAR_MAX__ * 2U + 1U) + 1)];
  struct trie *next[((__SCHAR_MAX__ * 2U + 1U) + 1)];
  char *target;
  int mind2;
  char *trans;
};



kwset_t
kwsalloc(trans)
     char *trans;
{
  struct kwset *kwset;

  kwset = (struct kwset *) xmalloc(sizeof (struct kwset));
  if (kcov_count(1484) || (!kwset) && kcov_then(1484))
    return 0;

  _obstack_begin ((&kwset->obstack), 0, 0, (void *(*) ()) xmalloc, (void (*) ()) free);
  kwset->words = 0;
  kwset->trie
    = (struct trie *) (( ((&kwset->obstack))->temp = ((sizeof (struct trie))), (kcov_count(1485) || ((((&kwset->obstack))->chunk_limit - ((&kwset->obstack))->next_free < ((&kwset->obstack))->temp)) && kcov_then(1485) ? (_obstack_newchunk (((&kwset->obstack)), ((&kwset->obstack))->temp), 0) : 0), ((&kwset->obstack))->next_free += ((&kwset->obstack))->temp), ( (kcov_count(1486) || (((&kwset->obstack))->next_free == ((&kwset->obstack))->object_base) && kcov_then(1486) ? ((((&kwset->obstack))->maybe_empty_object = 1), 0) : 0), ((&kwset->obstack))->temp = ((((&kwset->obstack))->object_base) - (char *)0), ((&kwset->obstack))->next_free = (((((((&kwset->obstack))->next_free) - (char *)0)+((&kwset->obstack))->alignment_mask) & ~ (((&kwset->obstack))->alignment_mask)) + (char *)0), (kcov_count(1487) || ((((&kwset->obstack))->next_free - (char *)((&kwset->obstack))->chunk > ((&kwset->obstack))->chunk_limit - (char *)((&kwset->obstack))->chunk)) && kcov_then(1487) ? (((&kwset->obstack))->next_free = ((&kwset->obstack))->chunk_limit) : 0), ((&kwset->obstack))->object_base = ((&kwset->obstack))->next_free, ((((&kwset->obstack))->temp) + (char *)0)));
  if (kcov_count(1488) || (!kwset->trie) && kcov_then(1488))
    {
      kwsfree((kwset_t) kwset);
      return 0;
    }
  kwset->trie->accepting = 0;
  kwset->trie->links = 0;
  kwset->trie->parent = 0;
  kwset->trie->next = 0;
  kwset->trie->fail = 0;
  kwset->trie->depth = 0;
  kwset->trie->shift = 0;
  kwset->mind = __INT_MAX__;
  kwset->maxd = -1;
  kwset->target = 0;
  kwset->trans = trans;

  return (kwset_t) kwset;
}



char *
kwsincr(kws, text, len)
     kwset_t kws;
     char *text;
     size_t len;
{
  struct kwset *kwset;
  register struct trie *trie;
  register unsigned char label;
  register struct tree *link;
  register int depth;
  struct tree *links[12];
  enum { L, R } dirs[12];
  struct tree *t, *r, *l, *rl, *lr;

  kwset = (struct kwset *) kws;
  trie = kwset->trie;
  text += len;



  while (kcov_count(1489) || (len--) && kcov_then(1489))
    {
      label = kcov_count(1490) || (kwset->trans) && kcov_then(1490) ? kwset->trans[(unsigned char) *--text] : *--text;




      link = trie->links;
      links[0] = (struct tree *) &trie->links;
      dirs[0] = L;
      depth = 1;

      while (kcov_count(1491) || (link && label != link->label) && kcov_then(1491))
 {
   links[depth] = link;
   if (kcov_count(1492) || (label < link->label) && kcov_then(1492))
     dirs[depth++] = L, link = link->llink;
   else
     dirs[depth++] = R, link = link->rlink;
 }




      if (kcov_count(1493) || (!link) && kcov_then(1493))
 {
   link = (struct tree *) (( ((&kwset->obstack))->temp = ((sizeof (struct tree))), (kcov_count(1494) || ((((&kwset->obstack))->chunk_limit - ((&kwset->obstack))->next_free < ((&kwset->obstack))->temp)) && kcov_then(1494) ? (_obstack_newchunk (((&kwset->obstack)), ((&kwset->obstack))->temp), 0) : 0), ((&kwset->obstack))->next_free += ((&kwset->obstack))->temp), ( (kcov_count(1495) || (((&kwset->obstack))->next_free == ((&kwset->obstack))->object_base) && kcov_then(1495) ? ((((&kwset->obstack))->maybe_empty_object = 1), 0) : 0), ((&kwset->obstack))->temp = ((((&kwset->obstack))->object_base) - (char *)0), ((&kwset->obstack))->next_free = (((((((&kwset->obstack))->next_free) - (char *)0)+((&kwset->obstack))->alignment_mask) & ~ (((&kwset->obstack))->alignment_mask)) + (char *)0), (kcov_count(1496) || ((((&kwset->obstack))->next_free - (char *)((&kwset->obstack))->chunk > ((&kwset->obstack))->chunk_limit - (char *)((&kwset->obstack))->chunk)) && kcov_then(1496) ? (((&kwset->obstack))->next_free = ((&kwset->obstack))->chunk_limit) : 0), ((&kwset->obstack))->object_base = ((&kwset->obstack))->next_free, ((((&kwset->obstack))->temp) + (char *)0)));

   if (kcov_count(1497) || (!link) && kcov_then(1497))
     return "memory exhausted";
   link->llink = 0;
   link->rlink = 0;
   link->trie = (struct trie *) (( ((&kwset->obstack))->temp = ((sizeof (struct trie))), (kcov_count(1498) || ((((&kwset->obstack))->chunk_limit - ((&kwset->obstack))->next_free < ((&kwset->obstack))->temp)) && kcov_then(1498) ? (_obstack_newchunk (((&kwset->obstack)), ((&kwset->obstack))->temp), 0) : 0), ((&kwset->obstack))->next_free += ((&kwset->obstack))->temp), ( (kcov_count(1499) || (((&kwset->obstack))->next_free == ((&kwset->obstack))->object_base) && kcov_then(1499) ? ((((&kwset->obstack))->maybe_empty_object = 1), 0) : 0), ((&kwset->obstack))->temp = ((((&kwset->obstack))->object_base) - (char *)0), ((&kwset->obstack))->next_free = (((((((&kwset->obstack))->next_free) - (char *)0)+((&kwset->obstack))->alignment_mask) & ~ (((&kwset->obstack))->alignment_mask)) + (char *)0), (kcov_count(1500) || ((((&kwset->obstack))->next_free - (char *)((&kwset->obstack))->chunk > ((&kwset->obstack))->chunk_limit - (char *)((&kwset->obstack))->chunk)) && kcov_then(1500) ? (((&kwset->obstack))->next_free = ((&kwset->obstack))->chunk_limit) : 0), ((&kwset->obstack))->object_base = ((&kwset->obstack))->next_free, ((((&kwset->obstack))->temp) + (char *)0)));

   if (kcov_count(1501) || (!link->trie) && kcov_then(1501))
     return "memory exhausted";
   link->trie->accepting = 0;
   link->trie->links = 0;
   link->trie->parent = trie;
   link->trie->next = 0;
   link->trie->fail = 0;
   link->trie->depth = trie->depth + 1;
   link->trie->shift = 0;
   link->label = label;
   link->balance = 0;


   if (kcov_count(1502) || (dirs[--depth] == L) && kcov_then(1502))
     links[depth]->llink = link;
   else
     links[depth]->rlink = link;


   while (kcov_count(1503) || (depth && !links[depth]->balance) && kcov_then(1503))
     {
       if (kcov_count(1504) || (dirs[depth] == L) && kcov_then(1504))
  --links[depth]->balance;
       else
  ++links[depth]->balance;
       --depth;
     }


   if (kcov_count(1505) || (depth && ((dirs[depth] == L && --links[depth]->balance)
   || (dirs[depth] == R && ++links[depth]->balance))) && kcov_then(1505))
     {
       switch (links[depth]->balance)
  {
  case (char) -2:kcov_count(1507);
kcov_then(1507);

    switch (dirs[depth + 1])
      {
      case L:kcov_count(1509);
kcov_then(1509);

        r = links[depth], t = r->llink, rl = t->rlink;
        t->rlink = r, r->llink = rl;
        t->balance = r->balance = 0;
        break;
      case R:kcov_count(1510);
kcov_then(1510);

        r = links[depth], l = r->llink, t = l->rlink;
        rl = t->rlink, lr = t->llink;
        t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;
        l->balance = kcov_count(1511) || (t->balance != 1) && kcov_then(1511) ? 0 : -1;
        r->balance = kcov_count(1512) || (t->balance != (char) -1) && kcov_then(1512) ? 0 : 1;
        t->balance = 0;
        break;
      default:
kcov_count(1508);
kcov_then(1508);
}
    break;
  case 2:kcov_count(1513);
kcov_then(1513);

    switch (dirs[depth + 1])
      {
      case R:kcov_count(1515);
kcov_then(1515);

        l = links[depth], t = l->rlink, lr = t->llink;
        t->llink = l, l->rlink = lr;
        t->balance = l->balance = 0;
        break;
      case L:kcov_count(1516);
kcov_then(1516);

        l = links[depth], r = l->rlink, t = r->llink;
        lr = t->llink, rl = t->rlink;
        t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;
        l->balance = kcov_count(1517) || (t->balance != 1) && kcov_then(1517) ? 0 : -1;
        r->balance = kcov_count(1518) || (t->balance != (char) -1) && kcov_then(1518) ? 0 : 1;
        t->balance = 0;
        break;
      default:
kcov_count(1514);
kcov_then(1514);
}
    break;
  default:
kcov_count(1506);
kcov_then(1506);
}

       if (kcov_count(1519) || (dirs[depth - 1] == L) && kcov_then(1519))
  links[depth - 1]->llink = t;
       else
  links[depth - 1]->rlink = t;
     }
 }

      trie = link->trie;
    }



  if (kcov_count(1520) || (!trie->accepting) && kcov_then(1520))
    trie->accepting = 1 + 2 * kwset->words;
  ++kwset->words;


  if (kcov_count(1521) || (trie->depth < kwset->mind) && kcov_then(1521))
    kwset->mind = trie->depth;
  if (kcov_count(1522) || (trie->depth > kwset->maxd) && kcov_then(1522))
    kwset->maxd = trie->depth;

  return 0;
}



static void
enqueue(tree, last)
     struct tree *tree;
     struct trie **last;
{
  if (kcov_count(1523) || (!tree) && kcov_then(1523))
    return;
  enqueue(tree->llink, last);
  enqueue(tree->rlink, last);
  (*last) = (*last)->next = tree->trie;
}




static void
treefails(tree, fail, recourse)
     register struct tree *tree;
     struct trie *fail;
     struct trie *recourse;
{
  register struct tree *link;

  if (kcov_count(1524) || (!tree) && kcov_then(1524))
    return;

  treefails(tree->llink, fail, recourse);
  treefails(tree->rlink, fail, recourse);



  while (kcov_count(1525) || (fail) && kcov_then(1525))
    {
      link = fail->links;
      while (kcov_count(1526) || (link && tree->label != link->label) && kcov_then(1526))
 if (kcov_count(1527) || (tree->label < link->label) && kcov_then(1527))
   link = link->llink;
 else
   link = link->rlink;
      if (kcov_count(1528) || (link) && kcov_then(1528))
 {
   tree->trie->fail = link->trie;
   return;
 }
      fail = fail->fail;
    }

  tree->trie->fail = recourse;
}



static void
treedelta(tree, depth, delta)
     register struct tree *tree;
     register unsigned int depth;
     unsigned char delta[];
{
  if (kcov_count(1529) || (!tree) && kcov_then(1529))
    return;
  treedelta(tree->llink, depth, delta);
  treedelta(tree->rlink, depth, delta);
  if (kcov_count(1530) || (depth < delta[tree->label]) && kcov_then(1530))
    delta[tree->label] = depth;
}


static int
hasevery(a, b)
     register struct tree *a;
     register struct tree *b;
{
  if (kcov_count(1531) || (!b) && kcov_then(1531))
    return 1;
  if (kcov_count(1532) || (!hasevery(a, b->llink)) && kcov_then(1532))
    return 0;
  if (kcov_count(1533) || (!hasevery(a, b->rlink)) && kcov_then(1533))
    return 0;
  while (kcov_count(1534) || (a && b->label != a->label) && kcov_then(1534))
    if (kcov_count(1535) || (b->label < a->label) && kcov_then(1535))
      a = a->llink;
    else
      a = a->rlink;
  return !!a;
}



static void
treenext(tree, next)
     struct tree *tree;
     struct trie *next[];
{
  if (kcov_count(1536) || (!tree) && kcov_then(1536))
    return;
  treenext(tree->llink, next);
  treenext(tree->rlink, next);
  next[tree->label] = tree->trie;
}



char *
kwsprep(kws)
     kwset_t kws;
{
  register struct kwset *kwset;
  register int i;
  register struct trie *curr, *fail;
  register char *trans;
  unsigned char delta[((__SCHAR_MAX__ * 2U + 1U) + 1)];
  struct trie *last, *next[((__SCHAR_MAX__ * 2U + 1U) + 1)];

  kwset = (struct kwset *) kws;




  if (kcov_count(1537) || (kwset->mind < 256) && kcov_then(1537))
    for (i = 0; kcov_count(1538) || (i < ((__SCHAR_MAX__ * 2U + 1U) + 1)) && kcov_then(1538); ++i)
      delta[i] = kwset->mind;
  else
    for (i = 0; kcov_count(1539) || (i < ((__SCHAR_MAX__ * 2U + 1U) + 1)) && kcov_then(1539); ++i)
      delta[i] = 255;



  if (kcov_count(1540) || (kwset->words == 1 && kwset->trans == 0) && kcov_then(1540))
    {

      kwset->target = (( ((&kwset->obstack))->temp = ((kwset->mind)), (kcov_count(1541) || ((((&kwset->obstack))->chunk_limit - ((&kwset->obstack))->next_free < ((&kwset->obstack))->temp)) && kcov_then(1541) ? (_obstack_newchunk (((&kwset->obstack)), ((&kwset->obstack))->temp), 0) : 0), ((&kwset->obstack))->next_free += ((&kwset->obstack))->temp), ( (kcov_count(1542) || (((&kwset->obstack))->next_free == ((&kwset->obstack))->object_base) && kcov_then(1542) ? ((((&kwset->obstack))->maybe_empty_object = 1), 0) : 0), ((&kwset->obstack))->temp = ((((&kwset->obstack))->object_base) - (char *)0), ((&kwset->obstack))->next_free = (((((((&kwset->obstack))->next_free) - (char *)0)+((&kwset->obstack))->alignment_mask) & ~ (((&kwset->obstack))->alignment_mask)) + (char *)0), (kcov_count(1543) || ((((&kwset->obstack))->next_free - (char *)((&kwset->obstack))->chunk > ((&kwset->obstack))->chunk_limit - (char *)((&kwset->obstack))->chunk)) && kcov_then(1543) ? (((&kwset->obstack))->next_free = ((&kwset->obstack))->chunk_limit) : 0), ((&kwset->obstack))->object_base = ((&kwset->obstack))->next_free, ((((&kwset->obstack))->temp) + (char *)0)));
      for (i = kwset->mind - 1, curr = kwset->trie; kcov_count(1544) || (i >= 0) && kcov_then(1544); --i)
 {
   kwset->target[i] = curr->links->label;
   curr = curr->links->trie;
 }

      for (i = 0; kcov_count(1545) || (i < kwset->mind) && kcov_then(1545); ++i)
 delta[(unsigned char) kwset->target[i]] = kwset->mind - (i + 1);
      kwset->mind2 = kwset->mind;


      for (i = 0; kcov_count(1546) || (i < kwset->mind - 1) && kcov_then(1546); ++i)
 if (kcov_count(1547) || (kwset->target[i] == kwset->target[kwset->mind - 1]) && kcov_then(1547))
   kwset->mind2 = kwset->mind - (i + 1);
    }
  else
    {


      for (curr = last = kwset->trie; kcov_count(1548) || (curr) && kcov_then(1548); curr = curr->next)
 {

   enqueue(curr->links, &last);

   curr->shift = kwset->mind;
   curr->maxshift = kwset->mind;


   treedelta(curr->links, curr->depth, delta);


   treefails(curr->links, curr->fail, kwset->trie);



   for (fail = curr->fail; kcov_count(1549) || (fail) && kcov_then(1549); fail = fail->fail)
     {



       if (kcov_count(1550) || (!hasevery(fail->links, curr->links)) && kcov_then(1550))
  if (kcov_count(1551) || (curr->depth - fail->depth < fail->shift) && kcov_then(1551))
    fail->shift = curr->depth - fail->depth;




       if (kcov_count(1552) || (curr->accepting && fail->maxshift > curr->depth - fail->depth) && kcov_then(1552))
  fail->maxshift = curr->depth - fail->depth;
     }
 }



      for (curr = kwset->trie->next; kcov_count(1553) || (curr) && kcov_then(1553); curr = curr->next)
 {
   if (kcov_count(1554) || (curr->maxshift > curr->parent->maxshift) && kcov_then(1554))
     curr->maxshift = curr->parent->maxshift;
   if (kcov_count(1555) || (curr->shift > curr->maxshift) && kcov_then(1555))
     curr->shift = curr->maxshift;
 }



      for (i = 0; kcov_count(1556) || (i < ((__SCHAR_MAX__ * 2U + 1U) + 1)) && kcov_then(1556); ++i)
 next[i] = 0;
      treenext(kwset->trie->links, next);

      if (kcov_count(1557) || ((trans = kwset->trans) != 0) && kcov_then(1557))
 for (i = 0; kcov_count(1558) || (i < ((__SCHAR_MAX__ * 2U + 1U) + 1)) && kcov_then(1558); ++i)
   kwset->next[i] = next[(unsigned char) trans[i]];
      else
 for (i = 0; kcov_count(1559) || (i < ((__SCHAR_MAX__ * 2U + 1U) + 1)) && kcov_then(1559); ++i)
   kwset->next[i] = next[i];
    }


  if (kcov_count(1560) || ((trans = kwset->trans) != 0) && kcov_then(1560))
    for (i = 0; kcov_count(1561) || (i < ((__SCHAR_MAX__ * 2U + 1U) + 1)) && kcov_then(1561); ++i)
      kwset->delta[i] = delta[(unsigned char) trans[i]];
  else
    for (i = 0; kcov_count(1562) || (i < ((__SCHAR_MAX__ * 2U + 1U) + 1)) && kcov_then(1562); ++i)
      kwset->delta[i] = delta[i];

  return 0;
}




static char *
bmexec(kws, text, size)
     kwset_t kws;
     char *text;
     size_t size;
{
  struct kwset *kwset;
  register unsigned char *d1;
  register char *ep, *sp, *tp;
  register int d, gc, i, len, md2;

  kwset = (struct kwset *) kws;
  len = kwset->mind;

  if (kcov_count(1563) || (len == 0) && kcov_then(1563))
    return text;
  if (kcov_count(1564) || (len > size) && kcov_then(1564))
    return 0;
  if (kcov_count(1565) || (len == 1) && kcov_then(1565))
    return memchr(text, kwset->target[0], size);

  d1 = kwset->delta;
  sp = kwset->target + len;
  gc = ((unsigned char) (sp[-2]));
  md2 = kwset->mind2;
  tp = text + len;


  if (kcov_count(1566) || (size > 12 * len) && kcov_then(1566))

    for (ep = text + size - 11 * len;kcov_count(1567) || kcov_then(1567);)
      {
 while (kcov_count(1568) || (tp <= ep) && kcov_then(1568))
   {
     d = d1[((unsigned char) (tp[-1]))], tp += d;
     d = d1[((unsigned char) (tp[-1]))], tp += d;
     if (kcov_count(1569) || (d == 0) && kcov_then(1569))
       goto found;
     d = d1[((unsigned char) (tp[-1]))], tp += d;
     d = d1[((unsigned char) (tp[-1]))], tp += d;
     d = d1[((unsigned char) (tp[-1]))], tp += d;
     if (kcov_count(1570) || (d == 0) && kcov_then(1570))
       goto found;
     d = d1[((unsigned char) (tp[-1]))], tp += d;
     d = d1[((unsigned char) (tp[-1]))], tp += d;
     d = d1[((unsigned char) (tp[-1]))], tp += d;
     if (kcov_count(1571) || (d == 0) && kcov_then(1571))
       goto found;
     d = d1[((unsigned char) (tp[-1]))], tp += d;
     d = d1[((unsigned char) (tp[-1]))], tp += d;
   }
 break;
      found:
 if (kcov_count(1572) || (((unsigned char) (tp[-2])) == gc) && kcov_then(1572))
   {
     for (i = 3; kcov_count(1573) || (i <= len && ((unsigned char) (tp[-i])) == ((unsigned char) (sp[-i]))) && kcov_then(1573); ++i)
       ;
     if (kcov_count(1574) || (i > len) && kcov_then(1574))
       return tp - len;
   }
 tp += md2;
      }



  ep = text + size;
  d = d1[((unsigned char) (tp[-1]))];
  while (kcov_count(1575) || (d <= ep - tp) && kcov_then(1575))
    {
      d = d1[((unsigned char) ((tp += d)[-1]))];
      if (kcov_count(1576) || (d != 0) && kcov_then(1576))
 continue;
      if (kcov_count(1577) || (tp[-2] == gc) && kcov_then(1577))
 {
   for (i = 3; kcov_count(1578) || (i <= len && ((unsigned char) (tp[-i])) == ((unsigned char) (sp[-i]))) && kcov_then(1578); ++i)
     ;
   if (kcov_count(1579) || (i > len) && kcov_then(1579))
     return tp - len;
 }
      d = md2;
    }

  return 0;
}


static char *
cwexec(kws, text, len, kwsmatch)
     kwset_t kws;
     char *text;
     size_t len;
     struct kwsmatch *kwsmatch;
{
  struct kwset *kwset;
  struct trie **next, *trie, *accept;
  char *beg, *lim, *mch, *lmch;
  register unsigned char c, *delta;
  register int d;
  register char *end, *qlim;
  register struct tree *tree;
  register char *trans;


  kwset = (struct kwset *) kws;
  if (kcov_count(1580) || (len < kwset->mind) && kcov_then(1580))
    return 0;
  next = kwset->next;
  delta = kwset->delta;
  trans = kwset->trans;
  lim = text + len;
  end = text;
  if (kcov_count(1581) || ((d = kwset->mind) != 0) && kcov_then(1581))
    mch = 0;
  else
    {
      mch = text, accept = kwset->trie;
      goto match;
    }

  if (kcov_count(1582) || (len >= 4 * kwset->mind) && kcov_then(1582))
    qlim = lim - 4 * kwset->mind;
  else
    qlim = 0;

  while (kcov_count(1583) || (lim - end >= d) && kcov_then(1583))
    {
      if (kcov_count(1584) || (qlim && end <= qlim) && kcov_then(1584))
 {
   end += d - 1;
   while (kcov_count(1585) || ((d = delta[c = *end]) && end < qlim) && kcov_then(1585))
     {
       end += d;
       end += delta[(unsigned char) *end];
       end += delta[(unsigned char) *end];
     }
   ++end;
 }
      else
 d = delta[c = (end += d)[-1]];
      if (kcov_count(1586) || (d) && kcov_then(1586))
 continue;
      beg = end - 1;
      trie = next[c];
      if (kcov_count(1587) || (trie->accepting) && kcov_then(1587))
 {
   mch = beg;
   accept = trie;
 }
      d = trie->shift;
      while (kcov_count(1588) || (beg > text) && kcov_then(1588))
 {
   c = kcov_count(1589) || (trans) && kcov_then(1589) ? trans[(unsigned char) *--beg] : *--beg;
   tree = trie->links;
   while (kcov_count(1590) || (tree && c != tree->label) && kcov_then(1590))
     if (kcov_count(1591) || (c < tree->label) && kcov_then(1591))
       tree = tree->llink;
     else
       tree = tree->rlink;
   if (kcov_count(1592) || (tree) && kcov_then(1592))
     {
       trie = tree->trie;
       if (kcov_count(1593) || (trie->accepting) && kcov_then(1593))
  {
    mch = beg;
    accept = trie;
  }
     }
   else
     break;
   d = trie->shift;
 }
      if (kcov_count(1594) || (mch) && kcov_then(1594))
 goto match;
    }
  return 0;

 match:



  if (kcov_count(1595) || (lim - mch > kwset->maxd) && kcov_then(1595))
    lim = mch + kwset->maxd;
  lmch = 0;
  d = 1;
  while (kcov_count(1596) || (lim - end >= d) && kcov_then(1596))
    {
      if (kcov_count(1597) || ((d = delta[c = (end += d)[-1]]) != 0) && kcov_then(1597))
 continue;
      beg = end - 1;
      if (kcov_count(1598) || (!(trie = next[c])) && kcov_then(1598))
 {
   d = 1;
   continue;
 }
      if (kcov_count(1599) || (trie->accepting && beg <= mch) && kcov_then(1599))
 {
   lmch = beg;
   accept = trie;
 }
      d = trie->shift;
      while (kcov_count(1600) || (beg > text) && kcov_then(1600))
 {
   c = kcov_count(1601) || (trans) && kcov_then(1601) ? trans[(unsigned char) *--beg] : *--beg;
   tree = trie->links;
   while (kcov_count(1602) || (tree && c != tree->label) && kcov_then(1602))
     if (kcov_count(1603) || (c < tree->label) && kcov_then(1603))
       tree = tree->llink;
     else
       tree = tree->rlink;
   if (kcov_count(1604) || (tree) && kcov_then(1604))
     {
       trie = tree->trie;
       if (kcov_count(1605) || (trie->accepting && beg <= mch) && kcov_then(1605))
  {
    lmch = beg;
    accept = trie;
  }
     }
   else
     break;
   d = trie->shift;
 }
      if (kcov_count(1606) || (lmch) && kcov_then(1606))
 {
   mch = lmch;
   goto match;
 }
      if (kcov_count(1607) || (!d) && kcov_then(1607))
 d = 1;
    }

  if (kcov_count(1608) || (kwsmatch) && kcov_then(1608))
    {
      kwsmatch->strchr = accept->accepting / 2;
      kwsmatch->beg[0] = mch;
      kwsmatch->size[0] = accept->depth;
    }
  return mch;
}
# 9937 "grep.c"
char *
kwsexec(kws, text, size, kwsmatch)
     kwset_t kws;
     char *text;
     size_t size;
     struct kwsmatch *kwsmatch;
{
  struct kwset *kwset;
  char *ret;

  kwset = (struct kwset *) kws;
  if (kcov_count(1609) || (kwset->words == 1 && kwset->trans == 0) && kcov_then(1609))
    {
      ret = bmexec(kws, text, size);
      if (kcov_count(1610) || (kwsmatch != 0 && ret != 0) && kcov_then(1610))
 {
   kwsmatch->strchr = 0;
   kwsmatch->beg[0] = ret;
   kwsmatch->size[0] = kwset->mind;
 }
      return ret;
    }
  else
    return cwexec(kws, text, size, kwsmatch);
}


void
kwsfree(kws)
     kwset_t kws;
{
  struct kwset *kwset;

  kwset = (struct kwset *) kws;
  ( (&kwset->obstack)->temp = (char *)(0) - (char *) (&kwset->obstack)->chunk, (kcov_count(1611) || (((&kwset->obstack)->temp > 0 && (&kwset->obstack)->temp < (&kwset->obstack)->chunk_limit - (char *) (&kwset->obstack)->chunk)) && kcov_then(1611) ? (int) ((&kwset->obstack)->next_free = (&kwset->obstack)->object_base = (&kwset->obstack)->temp + (char *) (&kwset->obstack)->chunk) : (((obstack_free) ((&kwset->obstack), (&kwset->obstack)->temp + (char *) (&kwset->obstack)->chunk), 0), 0)));
  free(kws);
}
# 10515 "grep.c"
static void Gcompile(char *, size_t);
static void Ecompile(char *, size_t);
static char *EGexecute(char *, size_t, char **);
static void Fcompile(char *, size_t);
static char *Fexecute(char *, size_t, char **);
# 10529 "grep.c"
struct matcher matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep", Gcompile, EGexecute },
  { "ggrep", Gcompile, EGexecute },
  { "egrep", Ecompile, EGexecute },
  { "posix-egrep", Ecompile, EGexecute },
  { "gegrep", Ecompile, EGexecute },
  { "fgrep", Fcompile, Fexecute },
  { "gfgrep", Fcompile, Fexecute },
  { 0, 0, 0 },
};





static struct dfa dfa_1;


static struct re_pattern_buffer regex;




static kwset_t kwset;




static int lastexact;

void
dfaerror(mesg)
     char *mesg;
{
  fatal(mesg, 0);
}

static void
kwsinit()
{
  static char trans[((__SCHAR_MAX__ * 2U + 1U) + 1)];
  int i;

  if (kcov_count(1612) || (match_icase) && kcov_then(1612))
    for (i = 0; kcov_count(1613) || (i < ((__SCHAR_MAX__ * 2U + 1U) + 1)) && kcov_then(1613); ++i)
      trans[i] = (kcov_count(1614) || ((1 && ((*__ctype_b_loc ())[(int) ((i))] & (unsigned short int) _ISupper))) && kcov_then(1614) ? tolower(i) : (i));

  if (kcov_count(1615) || (!(kwset = kwsalloc(kcov_count(1616) || (match_icase) && kcov_then(1616) ? trans : (char *) 0))) && kcov_then(1615))
    fatal("memory exhausted", 0);
}





static void
kwsmusts()
{
  struct dfamust *dm;
  char *err;

  if (kcov_count(1617) || (dfa_1.musts) && kcov_then(1617))
    {
      kwsinit();



      for (dm = dfa_1.musts; kcov_count(1618) || (dm) && kcov_then(1618); dm = dm->next)
 {
   if (kcov_count(1619) || (!dm->exact) && kcov_then(1619))
     continue;
   ++lastexact;
   if (kcov_count(1620) || ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0) && kcov_then(1620))
     fatal(err, 0);
 }


      for (dm = dfa_1.musts; kcov_count(1621) || (dm) && kcov_then(1621); dm = dm->next)
 {
   if (kcov_count(1622) || (dm->exact) && kcov_then(1622))
     continue;
   if (kcov_count(1623) || ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0) && kcov_then(1623))
     fatal(err, 0);
 }
      if (kcov_count(1624) || ((err = kwsprep(kwset)) != 0) && kcov_then(1624))
 fatal(err, 0);
    }
}

static void
Gcompile(pattern, size)
     char *pattern;
     size_t size;
{

  const

  char *err;

  re_set_syntax((((1) << 1) | (((1) << 1) << 1) | (((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  dfasyntax((((1) << 1) | (((1) << 1) << 1) | (((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1), match_icase);

  if (kcov_count(1625) || ((err = re_compile_pattern(pattern, size, &regex)) != 0) && kcov_then(1625))
    fatal(err, 0);

  dfainit(&dfa_1);





  if (kcov_count(1626) || (match_words || match_lines) && kcov_then(1626))
    {






      char *n = xmalloc(size + 50);
      int i = 0;

      strcpy(n, "");

      if (kcov_count(1627) || (match_lines) && kcov_then(1627))
 strcpy(n, "^\\(");
      if (kcov_count(1628) || (match_words) && kcov_then(1628))
 strcpy(n, "\\(^\\|[^0-9A-Za-z_]\\)\\(");

      i = strlen(n);
      memcpy((n + i), (pattern), (size));
      i += size;

      if (kcov_count(1629) || (match_words) && kcov_then(1629))
 strcpy(n + i, "\\)\\([^0-9A-Za-z_]\\|$\\)");
      if (kcov_count(1630) || (match_lines) && kcov_then(1630))
 strcpy(n + i, "\\)$");

      i += strlen(n + i);
      dfacomp(n, i, &dfa_1, 1);
    }
  else
    dfacomp(pattern, size, &dfa_1, 1);

  kwsmusts();
}

static void
Ecompile(pattern, size)
     char *pattern;
     size_t size;
{

  const

  char *err;

  if (kcov_count(1631) || (strcmp(matcher, "posix-egrep") == 0) && kcov_then(1631))
    {
      re_set_syntax((((((1) << 1) << 1) | ((((1) << 1) << 1) << 1) | (((((1) << 1) << 1) << 1) << 1) | (((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)));
      dfasyntax((((((1) << 1) << 1) | ((((1) << 1) << 1) << 1) | (((((1) << 1) << 1) << 1) << 1) | (((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)), match_icase);
    }
  else
    {
      re_set_syntax(((((1) << 1) << 1) | ((((1) << 1) << 1) << 1) | (((((1) << 1) << 1) << 1) << 1) | (((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)));
      dfasyntax(((((1) << 1) << 1) | ((((1) << 1) << 1) << 1) | (((((1) << 1) << 1) << 1) << 1) | (((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)), match_icase);
    }

  if (kcov_count(1632) || ((err = re_compile_pattern(pattern, size, &regex)) != 0) && kcov_then(1632))
    fatal(err, 0);

  dfainit(&dfa_1);





  if (kcov_count(1633) || (match_words || match_lines) && kcov_then(1633))
    {






      char *n = xmalloc(size + 50);
      int i = 0;

      strcpy(n, "");

      if (kcov_count(1634) || (match_lines) && kcov_then(1634))
 strcpy(n, "^(");
      if (kcov_count(1635) || (match_words) && kcov_then(1635))
 strcpy(n, "(^|[^0-9A-Za-z_])(");

      i = strlen(n);
      memcpy((n + i), (pattern), (size));
      i += size;

      if (kcov_count(1636) || (match_words) && kcov_then(1636))
 strcpy(n + i, ")([^0-9A-Za-z_]|$)");
      if (kcov_count(1637) || (match_lines) && kcov_then(1637))
 strcpy(n + i, ")$");

      i += strlen(n + i);
      dfacomp(n, i, &dfa_1, 1);
    }
  else
    dfacomp(pattern, size, &dfa_1, 1);

  kwsmusts();
}

static char *
EGexecute(buf, size, endp)
     char *buf;
     size_t size;
     char **endp;
{
  register char *buflim, *beg, *end, save;
  int backref, start, len;
  struct kwsmatch kwsm;
  static struct re_registers regs;


  buflim = buf + size;

  for (beg = end = buf; kcov_count(1638) || (end < buflim) && kcov_then(1638); beg = end + 1)
    {
      if (kcov_count(1639) || (kwset) && kcov_then(1639))
 {

   beg = kwsexec(kwset, beg, buflim - beg, &kwsm);
   if (kcov_count(1640) || (!beg) && kcov_then(1640))
     goto failure;


   end = memchr(beg, '\n', buflim - beg);
   if (kcov_count(1641) || (!end) && kcov_then(1641))
     end = buflim;
   while (kcov_count(1642) || (beg > buf && beg[-1] != '\n') && kcov_then(1642))
     --beg;
   save = *end;
   if (kcov_count(1643) || (kwsm.strchr < lastexact) && kcov_then(1643))
     goto success;
   if (kcov_count(1644) || (!dfaexec(&dfa_1, beg, end, 0, (int *) 0, &backref)) && kcov_then(1644))
     {
       *end = save;
       continue;
     }
   *end = save;

   if (kcov_count(1645) || (!backref) && kcov_then(1645))
     goto success;
 }
      else
 {

   save = *buflim;
   beg = dfaexec(&dfa_1, beg, buflim, 0, (int *) 0, &backref);
   *buflim = save;
   if (kcov_count(1646) || (!beg) && kcov_then(1646))
     goto failure;

   end = memchr(beg, '\n', buflim - beg);
   if (kcov_count(1647) || (!end) && kcov_then(1647))
     end = buflim;
   while (kcov_count(1648) || (beg > buf && beg[-1] != '\n') && kcov_then(1648))
     --beg;

   if (kcov_count(1649) || (!backref) && kcov_then(1649))
     goto success;
 }


      regex.not_eol = 0;
      if (kcov_count(1650) || ((start = re_search(&regex, beg, end - beg, 0, end - beg, &regs)) >= 0) && kcov_then(1650))
 {
   len = regs.end[0] - start;
   if (kcov_count(1651) || (!match_lines && !match_words || match_lines && len == end - beg) && kcov_then(1651))
     goto success;






   if (kcov_count(1652) || (match_words) && kcov_then(1652))
     while (kcov_count(1653) || (start >= 0) && kcov_then(1653))
       {
  if (kcov_count(1654) || ((start == 0 || !((1 && ((*__ctype_b_loc ())[(int) ((beg[start - 1]))] & (unsigned short int) _ISalnum)) || (beg[start - 1]) == '_'))
      && (len == end - beg || !((1 && ((*__ctype_b_loc ())[(int) ((beg[start + len]))] & (unsigned short int) _ISalnum)) || (beg[start + len]) == '_'))) && kcov_then(1654))
    goto success;
  if (kcov_count(1655) || (len > 0) && kcov_then(1655))
    {

      --len;
      regex.not_eol = 1;
      len = re_match(&regex, beg, start + len, start, &regs);
    }
  if (kcov_count(1656) || (len <= 0) && kcov_then(1656))
    {

      if (kcov_count(1657) || (start == end - beg) && kcov_then(1657))
        break;
      ++start;
      regex.not_eol = 0;
      start = re_search(&regex, beg, end - beg,
          start, end - beg - start, &regs);
      len = regs.end[0] - start;
    }
       }
 }
    }

 failure:
  return 0;

 success:
  *endp = kcov_count(1658) || (end < buflim) && kcov_then(1658) ? end + 1 : end;
  return beg;
}

static void
Fcompile(pattern, size)
     char *pattern;
     size_t size;
{
  char *beg, *lim, *err;

  kwsinit();
  beg = pattern;
  do
    {
      for (lim = beg; kcov_count(1660) || (lim < pattern + size && *lim != '\n') && kcov_then(1660); ++lim)
 ;
      if (kcov_count(1661) || ((err = kwsincr(kwset, beg, lim - beg)) != 0) && kcov_then(1661))
 fatal(err, 0);
      if (kcov_count(1662) || (lim < pattern + size) && kcov_then(1662))
 ++lim;
      beg = lim;
    }
  while (kcov_count(1659) || (beg < pattern + size) && kcov_then(1659));

  if (kcov_count(1663) || ((err = kwsprep(kwset)) != 0) && kcov_then(1663))
    fatal(err, 0);
}

static char *
Fexecute(buf, size, endp)
     char *buf;
     size_t size;
     char **endp;
{
  register char *beg, *try, *end;
  register size_t len;
  struct kwsmatch kwsmatch;

  for (beg = buf; kcov_count(1664) || (beg <= buf + size) && kcov_then(1664); ++beg)
    {
      if (kcov_count(1665) || (!(beg = kwsexec(kwset, beg, buf + size - beg, &kwsmatch))) && kcov_then(1665))
 return 0;
      len = kwsmatch.size[0];
      if (kcov_count(1666) || (match_lines) && kcov_then(1666))
 {
   if (kcov_count(1667) || (beg > buf && beg[-1] != '\n') && kcov_then(1667))
     continue;
   if (kcov_count(1668) || (beg + len < buf + size && beg[len] != '\n') && kcov_then(1668))
     continue;
   goto success;
 }
      else if (kcov_count(1669) || (match_words) && kcov_then(1669))
 for (try = beg; kcov_count(1670) || (len && try) && kcov_then(1670);)
   {
     if (kcov_count(1671) || (try > buf && ((1 && ((*__ctype_b_loc ())[(int) (((unsigned char) try[-1]))] & (unsigned short int) _ISalnum)) || ((unsigned char) try[-1]) == '_')) && kcov_then(1671))
       break;
     if (kcov_count(1672) || (try + len < buf + size && ((1 && ((*__ctype_b_loc ())[(int) (((unsigned char) try[len]))] & (unsigned short int) _ISalnum)) || ((unsigned char) try[len]) == '_')) && kcov_then(1672))
       {
  try = kwsexec(kwset, beg, --len, &kwsmatch);
  len = kwsmatch.size[0];
       }
     else
       goto success;
   }
      else
 goto success;
    }

  return 0;

 success:
  if (kcov_count(1673) || ((end = memchr(beg + len, '\n', (buf + size) - (beg + len))) != 0) && kcov_then(1673))
    ++end;
  else
    end = buf + size;
  *endp = end;
  while (kcov_count(1674) || (beg > buf && beg[-1] != '\n') && kcov_then(1674))
    --beg;
  return beg;
}
